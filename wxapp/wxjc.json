{"title": "微信小程序开发之页面分享 onShareAppMessage 分享参数用处 ", "author": "Rolan", "put_time": "2019-8-19 00:08", "content": "今天下午突然听到群里有人说微信小程序工具更新了,文档也更新了不少内容.顾不上吃冬至的饺子.我就冲进来了.先说分享功能,目前真机尚不能调试.开发工具上可以看看效果.后续还会更新.Page()中加上如下代码后在右上角就会出现三个小白点title:分享的标题.desc:分享一段描述.path:这个参数有点意思.以前在微信中的分享一般都是url.这里是当前页面这里应该是pages/index?id=123这里的id目前还不知道是什么.也就是说以后你可以在微信中像分享一个网页一样分享一个页面了.onShareAppMessage: function () {\r\n    return {\r\n      title: '垃圾分类黑板报',\r\n      desc: '垃圾分类就选垃圾分类黑板报!',\r\n      path: '/page/user?id=123'\r\n    }\r\n  }分享参数用处:我这里没有用到路径后的参数,说个场景:参数是用户昵称,A分享了XXX小程序到微信群里,B点开小程序,弹个toast,”来自A的分享”."}
{"title": "解决小程序中webview页面多层history返回问题 ", "author": "Rolan", "put_time": "2019-8-21 00:15", "content": "小程序开发中遇到的问题：小程序中嵌套了一个webview页面，webview页面中有静默授权（A1页面静默授权后重定向到A2页面），点小程序原生的返回按钮会返回到A1页面，然后页面就会反复静默授权预期表现：点小程序原生的返回按钮后返回到小程序上个页面解决方案：通过\thistory.pushState 添加历史记录名目，\thistory.onpopstate 监听历史记录条目发生变化时，调用小程序API\twx.navigateBackwindow.addEventListener('popstate', (event) => {\r\n    wx.miniProgram.navigateBack();\r\n});\r\nconst code = getSearch('code'); // 伪代码，获取查询参数\r\nif (!code) { // 页面A1\r\n    if (isWeixin()) {\r\n        // 微信环境\r\n        const redirectUrl = window.location.href + '&code=1';\r\n        window.location.href = 'https://open.weixin.qq.com/connect/oauth2/authorize' + '?appid=' + appId +\r\n        '&redirect_uri=' + encodeURIComponent(redirectUrl) +\r\n        '&response_type=code&scope=snsapi_userinfo' +\r\n        '#wechat_redirect'; // 静默授权伪代码\r\n    } else {\r\n        alert('当前不是微信环境');\r\n    }\r\n} else { // 页面A2\r\n    history.pushState({page: 1}, null, window.location.href);\r\n}刚开始想的解决办法是用localStorage，跳转到A2时存储一个值，返回到A1时获取这个值，如果有值就清除这个值并且回退到小程序页面。听起来似乎也可行，但小程序的缓存和微信的缓存是同步的，如果在微信环境中直接访问A1页面，重定向到A2会存值，如果直接关闭页面，不会被清除，那么在小程序中访问时就直接回退了。"}
{"title": "微信小程序使用车牌号输入法 ", "author": "Rolan", "put_time": "2019-8-21 00:21", "content": "在做小程序时，做了一个关于车的项目，然后需要添加车辆信息、添加车牌号，使用车牌键盘输入，当时我把这个需求给砍了，然后在添加车辆信息时，老大看到数据库里我乱填的车牌号，又让我把他加上了^o^1.效果图2.相关代码使用组件形式实现键盘输入组件代码index.wxml<view class=\"carPlate\" wx:if=\"{{show}}\">\r\n  <block wx:if=\"{{type==1}}\">\r\n    <view class=\"wordList\">\r\n      <view class=\"wordItem\" wx:for=\"{{cityKeyword1}}\" wx:key=\"{{item}}\" bindtap=\"handleClick\" data-type=\"1\" data-item=\"{{item}}\">{{item}}</view>\r\n    </view>\r\n    <view class=\"wordList\">\r\n      <view class=\"wordItem\" wx:for=\"{{cityKeyword2}}\" wx:key=\"{{item}}\" bindtap=\"handleClick\" data-type=\"1\" data-item=\"{{item}}\">{{item}}</view>\r\n    </view>\r\n    <view class=\"wordList\">\r\n      <view class=\"wordItem\" wx:for=\"{{cityKeyword3}}\" wx:key=\"{{item}}\" bindtap=\"handleClick\" data-type=\"1\" data-item=\"{{item}}\">{{item}}</view>\r\n    </view>\r\n    <view class=\"wordList\">\r\n      <view class=\"wordItem\" wx:for=\"{{cityKeyword4}}\" wx:key=\"{{item}}\" bindtap=\"handleClick\" data-type=\"1\" data-item=\"{{item}}\">{{item}}</view>\r\n    </view>\r\n  </block>\r\n  <block wx:else>\r\n    <view class=\"wordList\">\r\n      <view class=\"wordItem\" wx:for=\"{{keyNumber}}\" wx:key=\"{{item}}\" bindtap=\"handleClick\" data-type=\"2\" data-item=\"{{item}}\">{{item}}</view>\r\n    </view>\r\n    <view class=\"wordList\">\r\n      <view class=\"wordItem\" wx:for=\"{{wordList1}}\" wx:key=\"{{item}}\" bindtap=\"handleClick\" data-type=\"2\" data-item=\"{{item}}\">{{item}}</view>\r\n    </view>\r\n    <view class=\"wordList\">\r\n      <view class=\"wordItem\" wx:for=\"{{wordList2}}\" wx:key=\"{{item}}\" bindtap=\"handleClick\" data-type=\"2\" data-item=\"{{item}}\">{{item}}</view>\r\n      <view class=\"wordItem wordClear\" bindtap=\"handleClick\" data-item=\"delete\">\r\n        <image src=\"/images/input-clear.png\" class=\"clearImg\"></image>\r\n      </view>\r\n    </view>\r\n    <view class=\"wordList\">\r\n      <view class=\"wordItem\" wx:for=\"{{wordList3}}\" wx:key=\"{{item}}\" bindtap=\"handleClick\" data-item=\"{{item}}\">{{item}}</view>\r\n      <view class=\"wordItem wordConfirm\" bindtap=\"handleClick\" data-item=\"confirm\">确定</view>\r\n    </view>\r\n  </block>\r\n</view>index.css.carPlate{\r\n  position: fixed;\r\n  padding: 12rpx 12rpx 30rpx;\r\n  left: 0;\r\n  bottom: 0;\r\n  width: 100%;\r\n  /* height: 150px; */\r\n  font-size: 30rpx;\r\n  background: #fff;\r\n  box-sizing: border-box;\r\n  border-top: 1px solid rgb(211, 207, 207);\r\n  z-index: 200;\r\n}\r\n.wordList{\r\n  display: flex;\r\n  width: 100%;\r\n  justify-content: space-between;\r\n  align-items: center;\r\n}\r\n.wordItem{\r\n  margin: 5rpx;\r\n  width: 70rpx;\r\n  height: 70rpx;\r\n  line-height: 70rpx;\r\n  text-align: center;\r\n  border: 1px solid #eee;\r\n  border-radius: 10rpx;\r\n}\r\n.wordConfirm{\r\n  width: 130rpx;\r\n  color: #fff;\r\n  background: #473af0;\r\n}\r\n.wordClear{\r\n  width: 100rpx;\r\n}\r\n.clearImg{\r\n  width: 60rpx;\r\n  height: 60rpx;\r\n  vertical-align: middle;\r\n}index.jsComponent({\r\n\r\n  properties: {\r\n    type: {\r\n      type: Number,\r\n      default: 1,\r\n    },\r\n    show: {\r\n      type: Boolean,\r\n      default: false,\r\n    }\r\n  },\r\n\r\n  data: {\r\n    cityKeyword1: '京沪浙苏粤鲁晋冀豫',\r\n    cityKeyword2: '川渝辽吉黑皖鄂湘赣',\r\n    cityKeyword3: '闽陕甘宁蒙津贵云',\r\n    cityKeyword4: '桂琼青新藏港澳台',\r\n    keyNumber: '1234567890',\r\n    wordList1: 'QWERTYUIOP',\r\n    wordList2: 'ASDFGHJKL',\r\n    wordList3: 'ZXCVBNM',\r\n  },\r\n\r\n  methods: {\r\n    handleClick(e) {\r\n      let value = e.currentTarget.dataset.item;\r\n      let type = e.currentTarget.dataset.type;\r\n      switch(value) {\r\n        case 'confirm':\r\n          this.triggerEvent('confirm');\r\n          break;\r\n        case 'delete':\r\n          this.triggerEvent('delete');\r\n          break;\r\n        default: \r\n          this.triggerEvent('change', { value, type });\r\n      }\r\n    }\r\n  }\r\n})3.父组件引入我想实现点击输入后有上拉的效果，开始我想使用offset来实现的，但是下班后洗衣服想了下，不太好实现，我就想到了我以前做购物车时，有用到transform，原理差不多，我就把他用上了然后就是点击键盘外实现收起键盘，开始我想到的就是在父组件的最外层定义关闭事件，父级里面的盒子都使用catch方法阻止冒泡，但想下阻止冒泡好像又有点不合情理，就又把阻止冒泡给去掉了父组件index.wxml<view class=\"container\" bindtap=\"handlePlateConfirm\">\r\n  <view class=\"translateView\" style=\"transform: translateY({{translateSpace}}px)\">\r\n    <view class=\"list\">\r\n      <view class=\"item\">\r\n        <view class=\"label\">*车牌号码</view>\r\n        <view class=\"contentBox\" catchtap=\"handleClick\">\r\n          <view class=\"inputBox\" wx:if=\"{{carNo}}\">{{carNo}}</view>\r\n          <view class=\"promptText\" wx:else>请输入车牌号</view>\r\n        </view>\r\n      </view>\r\n    </view>\r\n  </view>\r\n</view>\r\n<car-plate show=\"{{showPlateInput}}\" bindchange=\"handlePlateChange\" type=\"{{inputType}}\" bindconfirm=\"handlePlateConfirm\" binddelete=\"handlePlateDelete\" />父组件index.jsPage({\r\n  data: {\r\n    carNo: '',\r\n    translateSpace: 0,\r\n    inputType: 1, // 车牌输入类型，1简称，2数字或者字母,\r\n    showPlateInput: false,\r\n  },\r\n  /* 用于点击弹出键盘输入，space为键盘弹出后向上拉取的距离 */\r\n  handleClick(e) {\r\n    /* 150为键盘的高度 */\r\n    let space = -(e.currentTarget.offsetTop - 150);\r\n    /* regExp用于判断当前已输入的车牌号是否是中文，并让键盘显示中文还是英文输入 */\r\n    let regExp = /^[\\u4e00-\\u9fa5]+/;\r\n    let inputType = 1;\r\n    if(regExp.test(this.data.carNo)) {\r\n      inputType = 2;\r\n    }\r\n\r\n    this.setData({\r\n      translateSpace: space,\r\n      showPlateInput: true,\r\n      inputType\r\n    })\r\n  },\r\n  /* 键盘输入操作 */\r\n  handlePlateChange(e) {\r\n    let value = e.detail.value;\r\n    let type = e.detail.type;\r\n    let carNo = this.data.carNo;\r\n    carNo += value;\r\n\r\n    if(type == 1) {\r\n      this.setData({\r\n        inputType: 2\r\n      })\r\n    }\r\n    this.setData({\r\n      carNo\r\n    })\r\n  },\r\n  /* 点击键盘上的确定 */\r\n  handlePlateConfirm() {\r\n    /* isCarPlate用于判断输入的车牌号是否符合规范 */\r\n    if (!this.isCarPlate(this.data.carNo)) {\r\n      wx.showToast({\r\n        title: '请输入正确的车牌号',\r\n        icon: 'none',\r\n        duration: 2000\r\n      })\r\n      return false;\r\n    }\r\n    this.setData({\r\n      translateSpace: 0,\r\n      showPlateInput: false,\r\n      inputType: 1\r\n    })\r\n  },\r\n  /* 用于键盘输入删除 */\r\n  handlePlateDelete(e) {\r\n    let carNo = this.data.carNo;\r\n    carNo = carNo.substring(0, carNo.length - 1);\r\n    if(carNo.length == 0) {\r\n      this.setData({\r\n        inputType: 1\r\n      })\r\n    }\r\n    this.setData({\r\n      carNo,\r\n    })\r\n  },\r\n  /* 判断车牌号 */\r\n  isCarPlate(value) {\r\n    return /^(([京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼使领][A-Z](([0-9]{5}[DF])|([DF]([A-HJ-NP-Z0-9])[0-9]{4})))|([京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼使领][A-Z][A-HJ-NP-Z0-9]{4}[A-HJ-NP-Z0-9挂学警港澳使领]))$/.test(value);\r\n  }\r\n})父组件index.css.container{\r\n  height: 100vh;\r\n  background: #fff;\r\n}\r\n.translateView{\r\n  background: #eee;\r\n}\r\n.list{\r\n  margin-bottom: 20rpx;\r\n  background: #fff;\r\n}\r\n.list:last-child{\r\n  margin: 0;\r\n}\r\n.item{\r\n  display: flex;\r\n  padding: 0 26rpx;\r\n  width: 100%;\r\n  height: 116rpx;\r\n  box-sizing: border-box;\r\n  align-items: center;\r\n  border-bottom: 1px solid #eee;\r\n}\r\n.item:last-child{\r\n  border: none;\r\n}\r\n.label{\r\n  margin-right: 10rpx;\r\n  width: 140rpx;\r\n}\r\n.contentBox{\r\n  display: flex;\r\n  width: calc(100% - 150rpx);\r\n  height: 90rpx;\r\n  align-items: center;\r\n  justify-content: space-between;\r\n}\r\n.promptText{\r\n  color: #c7c7c7;\r\n}\r\n.inputBox{\r\n  width: 100%;\r\n  height: 80rpx;\r\n  line-height: 80rpx;\r\n}正在努力学习中，若对你的学习有帮助，留下你的印记呗（点个赞咯^_^）"}
{"title": "小程序拼接图片链接无底洞探究 ", "author": "Rolan", "put_time": "2019-8-21 00:42", "content": "由于小程序包大小限制，我们一般都会将icon存放到cdn上。现在的开发流程需要在\t开发测试环境 下图片使用开发域名，线上使用生产域名。问题重现在小程序onLaunch的时候读取配置文件获取当前环境，并得到开发环境图片域名:./app.jsconst { imgHostDev, imgHostProd, env } = require('./app.config.js')\r\nApp({\r\n  onLaunch: function () {\r\n    this.globalData.imageHost = env == 'dev' ? imgHostDev : imgHostProd\r\n  },\r\n  globalData: {\r\n    imageHost: ''\r\n  }\r\n})\r\n复制代码在页面中：./pages/index/index.jsconst app = getApp()\r\n\r\nPage({\r\n  data: {\r\n    imgHost: ''\r\n  },\r\n  onLoad: function () {\r\n    this.setData({\r\n      imgHost: app.globalData.imageHost\r\n    })\r\n  }\r\n})\r\n复制代码./pages/index/index.wxml<image src=\"{{imgHost}}/4jZ1L1qECEOsikW2JKsyHQ==/109951164304393164.jpg\" mode=\"aspectFit\"></image>\r\n复制代码图片渲染出来了，但是在开发者工具中有报错VM1334:1 Failed to load local image resource /4jZ1L1qECEOsikW2JKsyHQ==/109951164304393164.jpg the server responded with a status of 500 (HTTP/1.1 500 Internal Server Error)\r\n手机预览就看不到图片。。。分析看一下报错信息，说本地不存在\t/4jZ1L1qECEOsikW2JKsyHQ==/109951164304393164.jpg 这个文件。 也就是说页面在执行onLoad之前就已经渲染了，这个时候\timgHost 值为空字符串，image的src拿到的图片链接就是\t/4jZ1L1qECEOsikW2JKsyHQ==/109951164304393164.jpg ，image标签就以为这是本地图片导致的。修复当然修复的方法有很多，可以将\timgHost 在初始化的时候就赋值：const app = getApp()\r\n\r\nPage({\r\n  data: {\r\n    imgHost: app.globalData.imageHost\r\n  },\r\n  onLoad: function () {\r\n\r\n  }\r\n})\r\n复制代码也可以在标签中做判断<image src=\"{{imgHost ? imgHost + '/4jZ1L1qECEOsikW2JKsyHQ==/109951164304393164.jpg' : ''}}\" mode=\"aspectFit\"></image>\r\n复制代码更多尝试之前都是渲染网络图片，如果读取本地图片更换不同文件夹中的同名图片呢？发现也是如此。如果图片链接里有多个变量，就建议在wxs文件中写一个方法来配置图片"}
{"title": "小程序自定义弹层禁止页面滚动方案详解 ", "author": "Rolan", "put_time": "2019-8-21 00:52", "content": "方案一：通过小程序自定义组件\tscroll-view 实现布局，动态修改\tscroll-y 属性组件及属性介绍：\tdevelopers.weixin.qq.com/miniprogram…缺点： 布局局限于\tscroll-view 组件， 大部分需求都满足不了方案二：自定义弹层蒙层或者外层容器添加\tcatchtouchmove 事件<view class=\"mask-box\" catchtouchmove=\"preventTouchMove\">\r\n    <!--弹层内容-->\r\n</view>\r\n复制代码缺点： 弹层滑动不了；适用于自定义弹层不滑动的布局。方案三：动态添加给最外层元素增加\tposition:fixed 样式<view style=\"{{isMask ? 'position:fixed; top: 0; left: 0;' : ''}}\">\r\n  <!--内容区-->\r\n</view>\r\n复制代码缺点： 当\tisMask 为\ttrue 时，页面始终会回到顶部；体验过不了关；方案四：通过动态修改样式处理 （推荐）原理： 小程序没提供\tAPI 给我们动态修改\tpage 样式， 那我们换个思路，最开始给\tpage 设置\toverflow: hidden , 最外层布局设置\toverflow: auto 但是设置\theight 属性时还是有坑。 如下：height: 100vh 时，上拉加载、下拉刷新在安卓端失效，ios没问题； 适用于当前页面不需要上拉、下拉刷新page 设置\toverflow: hidden 时， 安卓端页面整体滑动不了； 适用于底层布局不需要滑动page 设置\toverflow: visible ， 以上问题均解决 （推荐）代码如下： wxml:view class=\"content {{isMask? 'page-hidden' : ''}}\">\r\n复制代码wxss:page {\r\n  overflow: visible;\r\n  height: 100%;\r\n}\r\n.group-buying-list{\r\n  height: 100%;\r\n  overflow: auto;\r\n  -webkit-overflow-scrolling: touch;\r\n}\r\n.page-hidden{\r\n  overflow: hidden\r\n}\r\n复制代码若有疑问欢迎留言指正"}
{"title": "【小程序 + 云开发】体重排行榜 上手笔记 ", "author": "Rolan", "put_time": "2019-8-22 00:23", "content": "前一段时间上线的小程序记录体重功能运行基本稳定，没想到还真的有小伙伴们用，而且还热心的反馈问题，真是感谢，刚刚发布了一个体重记录排行榜，记录一下笔记吧。\r\n\r\n收集用户昵称与头像\r\n定时任务与关联查询\r\n查询排序\r\n\r\n\r\n\r\n收集用户昵称与头像\r\n之前的功能里没有储存用户信息，只是在分享的时候获取昵称和头像生成图片，不过排行榜的功能肯定是需要的，就建了一个users的表，在登录时收集昵称，如果用户拒绝也不能影响记录体重功能的使用。\r\n\r\nPage({\r\n  data: {\r\n    isAuthorize:'loading'  // 是否授权\r\n  },\r\n  /**\r\n   * 生命周期函数--监听页面加载\r\n   */\r\n  async onLoad(options) {\r\n\r\n    let getSetting =  promisify(wx.getSetting)\r\n\r\n    // 是否授权判断\r\n    let isAuthorize = await getSetting().then(res => {\r\n        if (res.authSetting['scope.userInfo']) {\r\n          this.getInfo()\r\n          return true\r\n        }else{\r\n          return false\r\n        }\r\n    })\r\n    this.setData({isAuthorize})\r\n\r\n    // 授权通过 执行登录\r\n    isAuthorize ? this.toAddPage() : ''\r\n    wx.checkSession({\r\n      success (a) {\r\n        //session_key 未过期，并且在本生命周期一直有效\r\n      },\r\n      fail () {\r\n        // session_key 已经失效，需要重新执行登录流程\r\n        wx.login() //重新登录\r\n      }\r\n    })\r\n  },\r\n  async bindGetUserInfo(e){\r\n  \r\n    if(e.detail.userInfo == undefined ){\r\n    \r\n      wx.showToast({\r\n        icon: 'none',\r\n        title: '好气哦，排行榜数据不能显示你的昵称。'\r\n      })\r\n\r\n      setTimeout(()=> {\r\n        // 执行登录\r\n        this.toAddPage()\r\n      },3000)\r\n\r\n    }else{\r\n\r\n      await this.saveName(e.detail.userInfo)\r\n      wx.hideLoading()\r\n      // 执行登录\r\n      this.toAddPage()\r\n    }\r\n  },\r\n    getInfo(){\r\n        wx.getUserInfo({\r\n          success: (res) => {\r\n            this.saveName(res.userInfo)\r\n          }\r\n        })\r\n      },\r\n  // 更新昵称\r\n  saveName(Param){\r\n    return new Promise((resolve, reject)=> {\r\n      wx.cloud.init()\r\n      // 云函数调用\r\n      wx.cloud.callFunction({\r\n           name: 'addTest',\r\n           data: {\r\n            ...Param\r\n           },\r\n           success: res => {\r\n              wx.showToast({\r\n                title: '昵称更新成功',\r\n              })\r\n\r\n              resolve(res)\r\n           },\r\n           fail: err => { \r\n              wx.showToast({\r\n                icon: 'none',\r\n                title: '昵称更新失败'\r\n              })\r\n              reject(err)\r\n           }\r\n         })\r\n    })\r\n  },\r\n  // 执行登录\r\n  toAddPage(){\r\n    wx.cloud.init({})\r\n    wx.cloud.callFunction({\r\n      name: 'login',\r\n      data: {},\r\n      success: res => {\r\n        app.globalData.openid = res.result.openid\r\n        wx.switchTab({\r\n          url: '/pages/add/add'\r\n        })\r\n      },\r\n    })\r\n\r\n  },\r\n复制代码定时任务与关联查询\r\n特意新建了一张表，用来存排行榜的数据，目前云开发还没有多表关联查询的功能，如果自己匹配挺耗费配额，就弄了一个表存起来数据，每天定时跑出排行榜的数据。\r\n说下流程\r\n1、批量删除表里的数据\r\n2、查询今日签到信息\r\n3、查询用户昵称\r\n4、储存信息\r\n主要用async + for...of 实现异步串行的读、存效果，下边是代码。\r\n// 云函数入口文件\r\nconst cloud = require('wx-server-sdk')\r\n\r\ncloud.init()\r\nconst db = cloud.database()\r\nconst _ = db.command\r\nconst moment = require('moment')\r\n\r\n// 昨日签到列表\r\nconst getList = () => {\r\n    return db.collection('list').where({\r\n\t\t      // date:'2019-08-03'\r\n          date:moment().format('YYYY-MM-DD')\r\n          // date:moment().subtract(1, 'days').format('YYYY-MM-DD')\r\n\t\t    }).get()\r\n}\r\n\r\n// 获取昵称\r\nconst getName = (openId) => {\r\n    return db.collection('users').where({\r\n\t\t      _openid: openId\r\n\t\t    }).get()\r\n}\r\n\r\n\r\n// 保存排行榜\r\nconst addTopUserInfo = (openId,Param) => {\r\n    return db.collection('topList').add({\r\n        data: {\r\n            _openid: openId,\r\n            ...Param\r\n        }\r\n    })\r\n}\r\n\r\n\r\n// 云函数入口函数\r\nexports.main = async (event, context) => {\r\n  const wxContext = cloud.getWXContext()\r\n\r\n  try {\r\n    console.log(moment().subtract(1, 'days').format('YYYY-MM-DD'))\r\n\r\n    // 删除之前数据\r\n    let removeList = await db.collection('topList').where({'_openid':_.neq('123')}).remove()\r\n\r\n    // 获取列表数据\r\n  \tlet result\r\n  \tawait getList().then(res => {\r\n  \t\tresult = res.data\r\n  \t})\r\n\r\n    console.log(result)\r\n\r\n    let arr = []\r\n    // 循环存储\r\n    for(let item of result) {\r\n       await getName(item._openid).then(res => {\r\n          res.data.length == 1 ? item.name = res.data[0].nickName : item.name = '匿名用户'\r\n          res.data.length == 1 ? item.url = res.data[0].avatarUrl : item.avatarUrl = '../../images/null.png'\r\n\r\n        })\r\n    }\r\n\r\n    for(let item of result) {\r\n      await addTopUserInfo(item._openid,item).then(res => {\r\n        console.log(res,1)\r\n      }) \r\n    }\r\n    console.log('end')\r\n    \r\n  \treturn result\r\n\r\n  }catch(e){\r\n\r\n  }\r\n}\r\n\r\n复制代码定时任务在云函数的描述文件中定义，详见官方文档\r\n{\r\n  \"triggers\": [\r\n    {\r\n      \"name\": \"myTrigger\",\r\n      \"type\": \"timer\",\r\n      \"config\": \"0 0 23 * * * *\"\r\n    }\r\n  ]\r\n}\r\n\r\n复制代码查询排序\r\n新建排行榜页面，在页面中使用，limit为指定条数，orderBy指定排序条件，很简单了。\r\nwx.cloud.init()\r\n    const db = wx.cloud.database()\r\n    db.collection('topList').limit(100).orderBy('index', 'desc').get({\r\n      success:  (res) => {\r\n        console.log(res)\r\n        this.setData({\r\n          resault:res.data\r\n        })\r\n      }\r\n    })\r\n复制代码\r\n欢迎使用，哈哈哈"}
{"title": "小程序echart图层级显示问题 ", "author": "Rolan", "put_time": "2019-8-22 00:26", "content": "前言\r\n使用过echart插件开发小程序的同学，应该都会遇到这个问题。尤其常见的是需求是：顶部固定，其他内容可以滚动 ，这时你会发现绘制的图形是会穿透所固定的顶部，并且无论你怎么给顶部区域设置css的z-index都是无效的。\r\n来看下案发现场例子：\r\n\r\n\r\n其实微信官方有写到，诸如canvas，video等组件是使用客户端创建的原生组件，而原生组件的层级是最高的，所以页面中的其他组件无论设置 z-index 为多少，都无法盖在原生组件上。为了解决这个问题，官方提供了cover-view 与 cover-image这两个组件，这两个组件其实也是使用原生组件进行渲染，所以可以在显示层级上覆盖其他原生组件，但是也有一些明显使用限制：\r\n\r\n我从实际开发来看，最棘手的限制就是cover-view能嵌套的组件太少，内部只能嵌套cover-view,cover-image及button，样式上不支持单边border，单边radius，及shadow阴影。\r\n下面这张是设计师原图，可以看到顶部tab按钮是用到了单边radius，这就无法实现了。\r\n\r\n实战踩坑分享(基于taro框架开发)\r\n头部实现\r\n其实这里只需要将普通的view组件换成cover-view即可，fixed定位于顶部\r\n画线\r\n既然无法实现单边border，那要怎么画单条线呢？\r\n聪明的你可能想到了利用移动端1px线条的画法，例如：\r\n    background-size: 100% 1px;\r\n    background-repeat: no-repeat;\r\n    background-position: bottom left;\r\n    background-image: linear-gradient(0, #ededed, #ededed 50%, transparent 50%);\r\n复制代码遗憾的是经过测试，该写法无效；\r\n\r\n需要注意的是，很多情况下开发者工具模拟器可以达到正常想要效果，真机就不能，所以开发时一定要用真机调试\r\n\r\n这边就利用一个空壳cover-view实现，例如底部线条：\r\n.cover-border-b{\r\n        position: absolute;\r\n        bottom: 0;\r\n        left: 0;\r\n        width: 100%;\r\n        height: 2px; // 这边开发用了taro框架，实际高度相当于小程序2rpx单位\r\n        background-color: #ededed; // 边框颜色\r\n   }\r\n复制代码使用：放置直接父元素下面，并将其父元素设置position:relative属性;\r\n<CoverView className='cover-border-b'></CoverView>\r\n复制代码弹出层选择器\r\n穿透问题\r\n同理，将弹出层实现全部换成cover-view，上面提到过cover-view能嵌套的组件只有cover-view,cover-image及button,这样有个很大的问题就是无法使用picker组件了。\r\n遇到的坑\r\n正常情况下，弹出层都会以一个单独的组件抽离出来。这边实践发现，抽离出来后，却无法直接在组件中通过this.props.children获取到数据进行渲染：\r\n<FloatLayoutCover>\r\n        <CoverView>test text</CoverView>\r\n        <CoverView>test text</CoverView>\r\n        <CoverView>test text</CoverView>\r\n</FloatLayoutCover>\r\n复制代码以上写法真机中是无法渲染出数据的，测试发现只传文字时才会进行渲染：\r\n<FloatLayoutCover>\r\n        test text\r\n        test text\r\n        test text\r\n</FloatLayoutCover>\r\n复制代码但这个写法是毫无意义的，都无法对其设置样式。最后是以数据形式传入，在组件内部对数据进行处理：\r\n<FloatLayoutCover\r\n     title='选择时间'\r\n     isOpened={panelShow}\r\n     onConfirm={this.handleResult.bind(this)}\r\n     showCloseIcon={false}\r\n     contentHeight={400}\r\n     data={data}\r\n     activeIndex={activeIndex}\r\n>\r\n</FloatLayoutCover>\r\n复制代码<CoverView className='layout-body' style={{height: contentHeight + 'rpx'}}>\r\n     {\r\n        data.map((item, index) => {\r\n            return \r\n              <CoverView \r\n                  className={`${index === activeIndex && 'active'} option-item`} \r\n                  onClick={() => this.props.onConfirm(index)}>\r\n              {item}\r\n            </CoverView>\r\n       })\r\n     }\r\n</CoverView>\r\n复制代码最后实现效果：\r\n\r\n最后\r\n如果你也是基于taro框架进行echart开发的话，在初始编译完成打开项目运行的时候（npm run dev:weapp），应该也会遇到下面这个报错。\r\n\r\n被这个问题坑了很长一段时间，最后发现是每次重新编译时，taro框架不仅仅是将我存放echart.js文件移动到dist对应目录下，还对它进行了某种处理，导致实际运行的dist目录下的echart.js文件被破坏了，只能每次冷编译完成后，手动将开发目录下的echart.js替换掉dist目录下编译生成的。\r\n如果你对此问题有更好的办法，欢迎留言，谢谢。"}
{"title": "研究了多个出行类小程序后，我们发现了留住用户的秘密 ", "author": "Rolan", "put_time": "2019-8-26 00:02", "content": "上一期，我们聊到小程序“蓝牙能力”就像篮球场上力挽狂澜的“第六人”。这次微信公开课与晓程序观察（yinghoo-tech）一起，继续研究“蓝牙”能力在出行场景里发挥的作用。我们发现除了智能家居、共享充电设备领域，蓝牙在出行领域更是一个“神器”，堪比“好邻居”蜘蛛侠一样，能解决各种身边的问题。日常出行中这些“奇葩”景象不陌生： 过高速收费站时，人工收费通道排长龙，ETC通道廖无几人；充值交通卡时，明明手机就能解决，很多人却去窗口“人挤人”；好不容易发现一辆共享单车，却因网络太差而开不了锁，只好放弃... 这些新技术的出现，原本是为方便我们出行生活的，如今却因为网络问题，或者是体验不好成为“bug”，如ETC难办、充值App下载有门槛、共享单车网络开锁不稳定等。另一方面，对于开发者来说，因此流失用户也不值当。 “小程序+蓝牙”，是怎么来解决这些问题的？ 我们邀请到ETC助手、e行卡、卡亭、青桔单车等四款小程序的开发者，来谈谈如何发挥蓝牙的“超能力”。12.5亿车主需要的ETC业务 小程序+蓝牙都不能少截至2019年6月，全国汽车保有量达2.5亿。在国家ETC政策的推动下，办理ETC成了全国车主们纷纷关心的大事。但ETC难办，确是落实困难的主要原因。 去线下办理过ETC的朋友应该清楚，不仅网点覆盖少，办理过程更是繁琐，期间一度想要放弃，“还是踏踏实实走人工通道吧，反正也很少走高速”。现在，通过小程序，车主像是拥有了一位“私人助理”，足不出户就能办理ETC。一款叫做「ETC助手」的小程序正是使用了蓝牙能力，成为了很多车主办理ETC的首选。 「ETC助手」小程序团队感叹：“有了小程序蓝牙能力后，用户不用专门花上几个小时的时间去找ETC服务网点了。ETC设备激活只需十几秒，可以随时进行。”以前，这一步骤是线下ETC网点工作人员来完成的。另一款小程序「e行卡」也可以自助办理ETC，用户通过「e行卡」进行申请，收到电子标签（OBU）与e行卡之后，就可以自己安装激活设备了。过程很简单，先将电子标签贴在车前挡风玻璃，插入e行卡。等OBU蓝牙打开，进入「e行卡」小程序内的“装标签”，与OBU蓝牙连接成功后，按照流程操作就行。看似复杂的过程，车主实际操作起来不到1分钟就能搞定。蓝牙充当了激活ETC设备的关键角色。“蓝牙”秒速连接的能力，让车主几乎无门槛地享受到了不用停车直接过收费站的快感。 对于开发者来说，实现也不复杂，相比App蓝牙能力较高的开发难度，小程序则直接调用蓝牙能力就能完成。正是有了“蓝牙”的助攻，这两个小程序也出现了“前所未有”增长现象。 “自去年7月上线以来，现在还能保持每月100万以上的用户增长”，「e行卡」小程序团队说。ETC助手小程序的最新用户也达到了2500万。2蓝牙竟然能充公交卡？这是真的……针对出行场景，小程序蓝牙能力不仅能让有车一族更加便利，对习惯“环保出行”的用户，蓝牙能力照样能出一份力。比如，充值公交卡。 你一定有过这样的经历：早高峰，飞奔着来到地铁站，一刷卡，却显示“余额不足”，此时心中肯定是想把自己“打死”。充值公交卡这件事，似乎是一个“魔咒”，越是赶时间的时候，公交卡越容易出现“余额不足”的情况。 虽然可以选择现金充值、下载App充值，但带现金和下载App本身就是一道“槛”。 而“小程序+蓝牙”，可以“神奇”地实现充值。以「卡亭」小程序为例，用户只需找到充值设备，将公交卡放入卡槽内，然后打开手机蓝牙，用微信扫描二维码充值即可，既方便又高效。（小程序蓝牙公交卡充值机器）它充值的逻辑就是，小程序通过蓝牙与充值设备形成连接，然后将充值后的数据同步到公交卡，而蓝牙能力在这一过程中起到了核心作用。开发难度上也不大，直接将蓝牙能力放进小程序即可。3解锁共享单车有时候蓝牙比4G更好用有时候，明明触手可及，却又“不可触摸”。说的就是网络信号弱时，打开了共享单车小程序，但没法连接单车。原来3秒就能开锁的简单动作，就变成了长时间的等待甚至开不了锁。因此，拓展更多解锁方式，是共享单车们都在做的“功课”。「青桔单车」曾在扫码之外，还用过短信通知的方式开锁，但成本、效率上都不尽如人意。于是，开发成本低、解锁速度又快的“蓝牙”脱颖而出。用户打开蓝牙，扫码进入小程序就能直接解锁。“不论什么环境下，蓝牙锁依然能保持非常高的开锁成功率。”开锁成功率的提升，也标志着用户留存的提升，青桔单车小程序项目组表示，蓝牙能力给「青桔」单车带来了5%以上的订单增量。 随着「青桔」单车对蓝牙能力的理解加深，他们也为开发者总结了一些经验：  01 尽可能去掌握蓝牙（BLE）的协议，及特性，比如通信的距离，数据传输的方式。  02 iOS、Android在通信的方式上有差异，比如IOS搜索到的蓝牙设备需要转一层才是MAC地址。  03 在进行蓝牙写动作，不能连续写，可以每次写的时候加个100ms的延时，同时传输的数据超过20字节需要进行分片发送。  04 多看文档，一定要多看文档，因为各平台对蓝牙接口的处理方式不一定相同，一定要注意细节。 细节决定成败，或许未来，不仅仅是出行、智能家居、通讯、车载设备等场景，会有更多小程序发现“蓝牙”的更多玩法。"}
{"title": "小程序技术演进史 ", "author": "Rolan", "put_time": "2019-6-25 00:22", "content": "【CSDN 编者按】小程序这个由微信带头的产物，格外鲜明地体现了移动互联网的「时机」这个词，早在微信小程序之前，有力推轻应用的百度，有来自 HTML5 中国产业联盟的 DCloud 所主张的流应用，但最终却都已经淹没在了移动互联网的历史长河之中。唯有微信小程序风生水起，更是带动了巨头们的争相入场。小程序迎来了专属于中国移动互联网的群雄逐鹿的时代。本文作者王安即是流应用的创造者，作为移动领域的老兵，他依然在矢志不移地构建移动开发工具框架及生态，从原生应用到 HTML5 再到如今的小程序，他是这段历史的见证者、参与者。从这篇文章中，我们能够鲜活地看到小程序的技术演进历程，以及对于所有开发者来说，终将去往何处。作者 | 王安责编 | 唐小引封图 | CSDN 付费下载自东方 IC出品 | CSDN（ID：CSDNnews）中国特色的移动互联网时代伴随着 QQ 小程序面向用户开放，这个手机端月活 7 亿的巨无霸正式入场。小程序，终于成为了超级 App 的标配。盘点下已经支持小程序的超级 App：微信、企业微信、QQ、支付宝、高德地图、手机淘宝、百度、百度贴吧、百度地图、今日头条、抖音……这些璀璨耀眼的名字，背后都是巨大的流量。在这群超级 App 的支持下，中国的移动互联网格局被彻底改变。这个有中国特色的移动互联网时代，被称为“小程序时代”。这是继手机支付后，中国的移动互联网领先世界的第二个代表事物。中国的技术标准、开发者生态，第一次得到大规模的普及应用，而且很明显，小程序在功能和体验上均超过了 HTML5。中国人能建立开发者生态吗？这个命题曾一度让人怀疑。小程序完成了这一步突破，这是一场值得歌颂的中国技术生态发展史。让我们来回顾下这场技术生态革命，是如何开始，又将要去向何方。罗马不是一天建成的小程序不是一天发明出来的HTML5 于 2007 年在 W3C 立项，与 iPhone 发布同年。乔布斯曾期待 HTML5 能帮助 iPhone 打造起应用生态系统。但 HTML5 的发展速度并不如预期，它虽然成功地实现了打破 IE+Flash 垄断局面的目标，却没有达到承载优秀的移动互联网体验的地步。于是在 iPhone 站稳脚跟后，发布了自己的 App Store，开启了移动互联网的原生应用时代。随后的 Android，本来是基于 Linux 的 OS，与之同期的 MeeGo 等竞争对手采用 C + HTML5 的双模应用生态策略，然而 C 的开发难度太大，HTML5 体验又不行。Android 依靠 Java 技术生态，在竞争中脱颖而出。于是 在移动互联网初期，应用生态被定了基调 —— 原生开发。在那个时候，硬件不行，也没有其他办法，原生开发才能在低配硬件上带来商用体验。但大家都在怀念 HTML，那种无需安装更新、即点即用，直达二级页面的特点，一直让人迷恋。图源：CSDN 付费下载自东方 IC国内有一批做浏览器的厂商，尝试去改进 HTML5，他们提出了 轻应用 的概念。通过给 WebView 扩展原生能力，补充 JS API，让 HTML5 应用可以实现更多功能。不过这类业务没有取得成功，HTML5 的问题不止是功能不足，性能体验是它更严重的问题，而体验问题，不是简单地扩展 JS 能力能搞定的。这类业务发展的顶峰，是微信的 JS SDK。作为国内事实上最大的手机浏览器，微信为它的浏览器内核扩充了大量 JS API，让开发者可以用 JS 调用微信支付、扫码等众多 HTML5 做不到的功能。微信 JS SDK 说明文档但微信团队对这套方案的体验仍然不满意，微信钱包栏目里打车、理财等很多应用虽然嵌入了 JS SDK，但每次点击要等半天白屏，让人用着很痛苦，他们在业内开始寻找新的解决方案。业内早有专业团队看到了相同的问题。与浏览器不同，Hybrid 应用是另一个细分领域。它们为开发者提供使用 JS 编写跨平台应用的工具，为了让 JS 应用更接近原生应用的功能体验，这个行业的从业者做出了很多尝试。笔者所在的 DCloud 即是其中之一，我们 提出了改进 HTML5 的“性工能”障碍的解决方案 —— 通过工具、引擎优化、开发模式调整，让开发者可以通过 JS 写出更接近原生 App 体验的应用。多 WebView 模式，原生接管转场动画、下拉刷新、Tab 分页，预载 WebView……各种优化技术不停迭代，终于让 Hybrid 应用取得了性能体验的突破。Hybrid 应用和普通的轻应用相比，还有一个巨大的差别：一个是 Client/Server，一个是 Browser/Server。简单来说，Hybrid 应用是 JS 编写的需要安装的 App，而轻应用是在线网页。C/S 的应用在每次页面加载时，仅需要联网获取 JSON 数据；而 B/S 应用除了 JSON 数据外，还需要每次从服务器加载页面 DOM、样式、逻辑代码，所以 B/S 应用的页面加载很慢，体验很差。可是这样的 C/S 应用虽然体验好，却失去了 HTML5 的动态性，仍然需要安装、更新，无法即点即用、直达二级页面。那么 C/S 应用的动态性是否可以解决呢？对此，我们提出了流应用概念，把之前 Hybrid 应用里的运行于客户端的 JS 代码，先打包发布到服务器，制定流式加载协议，手机端引擎动态下载这些 JS 代码到本地，并且为了第一次加载速度更快，实现了应用的边下载边运行。就像流媒体的边下边播一样，应用也可以实现边用边下。在这套方案的保障下，终于解决了之前的各种难题： 让 JS 应用功能体验达到原生，并且可即点即用、可直达二级页面。如今看来，这已经变成了常识。但在当年，先驱们做了无数艰辛探索。这套技术，需要让客户端引擎提前预置在手机上，就像流媒体的普及，建立在 Flash 的装机量巨大的基础上，那么普及这个客户端引擎就变得很重要。2015 年，360 和 DCloud 合作，在 360 手机助手里内嵌了这个客户端引擎，推出了业内第一个商用的小程序，360 称之为 360 微应用。微应用实现了在 360 手机助手的应用下载页面，同时出现了“秒开”按钮，点击后直接使用。并且在 360 手机助手的扫码里，应用的分享里，都实现了扫码获得一个应用，点击分享消息获得一个应用。在 360 手机助手 3.4 版本中上线的中国第一个小程序为了做大生态，DCloud 把这套技术标准，捐献给了 HTML5 中国产业联盟，随后，联盟开始推动更多的超级 App 和手机厂商加入，共同推进动态 App 产业的发展。然而事情并不顺利，巨头们有自己的利益诉求。虽然有一批厂商同意加入联盟共建生态，但最关键的角色，真正的国民应用“微信”，最终决定自立标准、自研引擎，当然技术原理与流应用是基本一致的。2016 年 1 月 11 日，微信公开课，张小龙罕见露面，公布了微信应用号的计划，为这个大事件亲自站台。2016 年 9 月 21 日，微信宣布更名应用号为小程序，面向首批开发者内测。从此，这个词被正式定了下来，“小程序”，成为后续一个时代的代名词。而“流应用”、“微应用”则淹没在历史长河中成为一个令人唏嘘的故事。2017 年 1 月 9 日，微信公开课，小程序面向用户正式推出。从此后，阿里巴巴、手机厂商联盟、百度、今日头条，陆续推出了自己的小程序平台，其中也有很多波折与故事，在有偶然、有必然的过程中，形成了今天的局面。小程序大潮卷入了更多人，并形成了更大的浪潮，最终迎来了不可逆转的小程序时代。生态难，难于上青天发明能解决功能体验和动态性的技术方案，虽然难，但不是最难的事情。最难的是开发者生态的建设。最初 HTML5 中国产业联盟的策略是在 HTML5 上扩展强化，复用现有的 HTML5 生态。当微信的标准完全自立重建时，业内人士都悬着一颗心。在全球，基于 Web 的技术生态已经非常成熟，各种开发工具、框架、组件、模板...提升着开发者的效率。小程序丢弃了国际标准组织 W3C 的 DOM 和 Window 标准，仅仅采用基础 JavaScript。这意味着 HTML5 生态的各种轮子无法复用，要完全重造一个新的小程序开发生态。当初微信推广 JS SDK 时，是那么地顺其自然，开发者纷纷开始使用，因为对于开发者，只是在他们的 H5 版本上补充一些 API 而已。而 小程序初期，充满了开发者的质疑声 ：我的业务迭代那么久，让我重新做一个版本，你的生态到底能不能支撑我的投入？微信用持续而快速的版本升级、高管的站台，告诉大家微信做小程序的决心，并最终通过 2017 年底的跳一跳，引爆了小程序。从此大家的问题不再是我要不要做小程序了，而转向了：既然要做，怎么才能提升小程序的开发效率、降低开发成本？任何一种技术，或者开发模式的演进，在不断成熟的过程中，都遵循着类似的成熟规律：技术标准 -> 基础平台 -> 开发工具 -> 培训市场 -> 框架诞生 -> 周边生态逐步完善 -> 轮子之上的轮子在 HTML5 生态里，已经发展到最终极的形态，比如 Vue 是一个重要框架，而基于 Vue 的各种丰富的 UI 库、测试框架，则是轮子之上的轮子。多层轮子代表着生态的繁荣，也意味着开发者的开发效率更高。可微信的全新标准出现时，它把开发者推回了原始社会，一切都要重来。这在当时看来，并不是一个必然会成功的事情（ 其实直到现在，比如图表类轮子，小程序仍然比不过 HTML5 ）。时至今日，讨论这个标准的选择对错已经没有意义。当支付宝、百度、今日头条都开始参考这个标准做小程序时，时代已经不可阻挡。所幸，最终的结果是，中国人做成了。 在国际标准之外，在中国，终于建立起了自己的技术生态。并且这个生态，给用户带来了更好的体验，给开发者带来了更多流量和变现效率的提升，这是一个比 HTML5 更优秀的生态。野蛮的技术生态成长速度两年时间，中国的小程序开发者如何从原始社会进阶到现代文明？这也是一段有趣的历史。我们来看看小程序技术生态是如何快速成长，走完上面所说的这套技术成熟路线，也就是从技术标准到轮子之上的轮子的。在 Web 世界里，已经成熟到了原生 JS 用量很少的时代了，开发人员大量使用 Vue 等框架，并且在 Vue 的基础之上，又有更多轮子。当中国的开发人员面临重头开始时，他们感受到效率对比的差距，既然时代已不可阻挡，那就拥抱它。勤劳的中国技术人开始蓬勃地建设起了小程序各种周边技术生态。其中比较重要的是 开发框架的迭代 ，我们看看每个小程序开发框架为什么会诞生、流行和衰落。最初的微信小程序，一片荒蛮，一份文档 + 一个难用的 IDE，很多效率工具比如 npm、预处理器这些都不支持，而这些已经是大型项目离不开的工具。于是，第一个标志性的框架出现了 —— WePY。WePY 紧随微信小程序在 2017 年发布，原本是腾讯其他部门的一个个人工程师的作品。在那个年代，WePY 有效地解决了小程序不支持 npm、预处理器的痛点，被引爆后，腾讯官方才把这个框架收编到官方的 GitHub 下。不过 WePY 也面临很多问题，它使用了私有语法，这让它在生态建设上面临很大难度，IDE 着色、语法提示、语法校验、格式化、人员招聘培训等各方面问题制约着它的流行和普及。面对这些问题，人们开始思考，有什么更好的方式，可以复用现有技术生态来快速完善小程序生态？这时候下一个重要框架借势诞生，美团前端在 2018 年初开源了 MPVue。MPVue 采用 Vue 语法来开发小程序，通过对 Vue.js 的底层改造，实现了编译到微信小程序。MPVue 良好地借助了 Vue 的技术生态，周边工具如 IDE、校验器、格式化等支持直接复用、人员招聘培训等生态建设压力大幅下降，受到了大量开发者的欢迎。看着熟悉 Vue 的开发者终于有了趁手的轮子，那熟悉 React 的开发者怎会无动于衷？京东团队是 React 的重度用户，还自研了 JDreact，于是他们开发了 Taro 框架，一款基于 React 语法编写小程序的框架。但 Taro 并不是想简单做一个 MPVue 在 React 世界里的翻版，Taro 相比 MPVue，想要解决更多重要问题。Taro 面世较晚，此时微信、支付宝、百度、头条都已发布或宣传了自己的小程序，开发者面临一个多端开发和适配的问题。于是 Taro 率先支持多端开发，它甚至还能发布到 H5 和 App。图源：京东凹凸实验室当时小程序领域还有一个重要变化，微信开始支持小程序自定义组件。组件是一个成熟框架不可缺的东西，不管是 Vue 还是 React 都有丰富的组件生态。在过去，MPVue 时代，是把 Vue 组件也编译成页面模板，这带来一个很大的性能问题，在复杂页面里（比如长列表）使用组件，更新组件状态会导致整个页面的数据全部从 JS 逻辑层向视图层通讯一次，大量数据通讯会非常卡顿。注意：小程序的逻辑层运行在 V8 或 JSCore 下，和视图层是分离的，通讯阻塞很容易引发性能问题。于是 Taro 把 React 组件编译为新出的微信小程序自定义组件，这种组件在数据更新时，只会更新组件内部的数据，而不是整个页面更新数据，从而大幅减少了数据通信量。这一轮的后浪推前浪很猛，Taro 在性能和多端支持上，都超越了 MPVue。看着 React 阵营取得如此成绩，Vue 阵营自然会继续追击。我们基于 Vue 开发了 uni-app ，它实现了自定义组件编译模式，并在算法上做了很多优化。 另外，之前 MPVue 对 Vue 的语法支持度不太完善，比如过滤器等不支持，在 uni-app 中我们进行了解决。同样，uni-app 也看到了前浪的其他问题：Taro 虽然迈出了多端的第一步，但多端支持能力比较弱，每个平台仍然各自开发大量代码。核心原因，是Taro 在 H5 端和 App 端，并不是一个完整的小程序技术架构，无法保持最大程度的统一。于是 uni-app 在 App 端，使用了一个技术架构相同的小程序引擎，本身就可以直接运行小程序应用，这个引擎搭配小程序代码打包为 App，开发者一行代码不用改，可以同时发布小程序和 App。当然，其 App 引擎从 Hybrid 应用起家，它提供的 API 要比小程序多很多，因为 App 的需求会比小程序丰富，它还支持把 WebView 渲染引擎替换为 Weex 渲染引擎。之后 uni-app 又发布了 H5 版的小程序引擎，原理与小程序的 PC 模拟器相同，实现了良好的跨 H5 版的发布。 于是 uni-app 比较完美地实现了开发一次，7 个平台发布。第一层轮子就这样迅速发展了起来，Web 世界里最成熟的 Vue、React 技术生态被导入了小程序开发生态中。然后轮子之上的轮子开始如火如荼的建设。以 UI 库为例，之前的 UI 库，有 Vue 库、React 库，有 PC 库、H5 库和小程序库，种类繁多，甚至说混乱。比如在 Vue 阵营中，Vant 和 iView 这两个 UI 库，都是同时维护两个版本，它们即有 H5 版，又有小程序版。不止框架作者麻烦，开发者想在多端使用这些 UI 库时，会发现在不同端还需要引入不同的 UI 库，写法都不一样，这让开发者很崩溃。既然已经可以多端开发应用，于是 在多端开发的领域里，开始出现轮子之上的轮子，多端 UI 库 。首先是 Taro 推出了 Taro UI，实现了 H5 和小程序 UI 库的统一，不过可惜 Taro UI 不支持 App 端。然后 uni-app 推出了 uni UI，这个 UI 库同时支持多家小程序、H5、App。由于 uni-app 和 MPVue 同属 Vue 阵营，它们的组件是互通的。于是这两家联合举办了一场插件大赛，建立了插件市场。在中国的前端开发者领域，有很多和国外不一样的地方：一个是国内有小程序，第二个是国内 Vue 的开发者体量远超过 React 和 Angular。这里面很大的原因，是 Vue.js 的作者尤雨溪，是中国人。Vue 和 React 百度指数对比在庞大的 Vue 用户体量支持下，uni-app 和 MPVue 的周边生态迅速发展起来，开发工具、周边轮子、教育培训等生态快速完善。目前在 Vue 阵营下，开发者在 Web 生态下所需的轮子，在多端开发下基本也都有了。短短两年时间，小程序开发生态里几拨迭代，轮子之上的轮子不断涌现，快速进入了成熟期。结语产业还在继续发展，每当底层有重大技术变更时，上层框架世界就会发生新机会。当年 HTML5 标准不统一，浏览器兼容性问题严重，诞生了 jQurey 的机会。而在移动互联网下半场，浏览器兼容已经不再是核心问题，jQurey 的地位被更适合移动互联网的 Vue 替代。我们不知道未来还会有什么新的框架出世，但我们知道方向：对于开发者而言，总是会向着更高的开发效率、更高的性能、更高的投入产出比前进。对于开发商，目前的小程序，虽然发展了 2 年，但流量增长空间仍然巨大，微信之外，很多超级 App 的势能将逐渐释放，整个小程序产业的日活总量有数亿的提升空间。如果开发商能追上这拨红利，就能获得更多增长。而多端框架的出现，可以帮助开发商更好的把握这拨红利。中国的技术发展，此刻正在经历一个分水岭，从全面的技术进口，到开始建设自己的标准和开发者生态。迟早，会开始向外输出，引领世界的进步。不管中美是否开打贸易战，这一转变都是必须做的事情。中国的移动支付、小程序、5G，很多领域已经走在了全球前面。中国人发明的 Vue 已经在影响全球。虽然还有很多困难仍需克服，但我们每个开发者，都是新时代的见证者，更是新生态的建设者！作者简介：王安，DCloud 公司创始人，HTML5 中国产业联盟秘书长。2003 年开始从事移动互联网工作，十几年编程和商业经验，连续创业者。声明：作者独立观点，不代表 CSDN 立场。"}
{"title": "微信小程序开发系列教程第七章：编辑名片页面开发 ", "author": "admin", "put_time": "2016-10-12 22:14", "content": "编辑名片有两条路径，分为新增名片流程与修改名片流程。用户手填新增名片流程：首先跳转到我们的新增名片页面 1 需要传递用户的当前 userId，wx.navigateTo 带值跳转。Manual 为 true 设置用户走的是新增路线。新增名片页面 1 基本布局如下：取到 userId。使用微信自带的 input 组件验证也非常好用，如 maxLength 属性，可以限制用户输入长度，如我这的姓名长度是最大 5 位，直接数字 5 即可。也可以自定义一些验证效果，具体可以根据需求进行一些验证配置，取到用户输入的值，进行操作。这里绑定了自带的模态框提示组件。其中 modalHidden2 是模态框开关。另外 proptText 是需要提示的内容。即使很多输入框也支持数据动态改变，非常方便。实际效果，非常快捷，比以前省去很多事情，编写小程序，发现最大的好处可能就是我们不必去考虑一系列兼容性问题。最后还有个头像上传图片，测试了下目前上传到后台服务器还有点问题，应该是内测版本不太完善导致吧。设置的直接是背景图片。提交表单与跳转。提交表单使用的是自带的 bindsubmit 事件组件，在 button 组件上添加 formType=”submit” 即可，还有点需注意的是使用表单提交功能时 input 需加上 name 属性，这个传递方式是以键值对的形式传递的。这时候跳转到编辑页 2 页面，这个页面是根据用户填写的手机号码识别到匹配的公司，页面非常简单，一个数据循环而已，单选框日后可能还需要美化一下。同样也是一些数据绑定以及验证效果。实际渲染效果可以看到。这个和第一个编辑页面逻辑基本不相上下，一些基本验证与提交，这里就讲到前面两步骤即可，编辑页面3也是同理，这里不再过多啰嗦。修改名片流程效果图与需求，修改名片是一次性把以前填写的个人信息全部渲染出来，供用户来改动：名片图片模块，上传图片暂时还有点问题，这里就是模仿了个跳转组件，比较建议需要跳转的页面还是使用 wx.navigateTo 控制好一点，wx.navigateTo 提供了给我们不同的 3 个跳转路由，封装的都很好，而且跳转页面很多牵连到传值之类的，可以达到统一管理也可以避免一些看不到的 bug 吧，总之还是根据业务需求来定：姓名手机必填模块：个人信息模块，直接循环（block）出来：Onload 时我们请求必填与选填数据：* requiredGroup 必填中文信息* notRequiredGroup 选题中文信息* requiredGroupEn 必填英文信息* notRequiredGroupEn 选题英文信息```//请求名片对应的公司的中文信息的属性组数据，分为必填和选填//选题项变量以 no 开头requester.getOfflineCardInfoGroupFields(userId, cardId,function (res) {//debuggervar userName = res.card.userName;var mobile = res.card.mobile;var requiredGroup = res.requiredGroupCh;var notRequiredGroup = res.notRequiredGroupCh;var requiredGroupEn = res.requiredGroupEn;var notRequiredGroupEn = res.notRequiredGroupEn;var reqLen = requiredGroup.fields.length;var nreqLen = notRequiredGroup.fields.length;var reqLenEn = requiredGroupEn.fields.length;var nreqLenEn = notRequiredGroupEn.fields.length;self.setData({userName: userName,mobile: mobile,requireFields: requiredGroup.fields,notRequireFields: notRequiredGroup.fields,requireFieldsEn: requiredGroupEn.fields,notRequireFieldsEn: notRequiredGroupEn.fields,l1: reqLen,l2: nreqLen + reqLen,l3: reqLenEn + nreqLen + reqLen});self.forceUpdate();}, function (code, msg) {console.info(\"code=\" + code + \"&msg=\" + msg);});```中英文信息必填与选填渲染：这里表单提交数据转换有点复杂（大家根据业务需求来做，不必花时间研究这里的方法），获取的是数组，按照后台需要的数据格式进行转换传递过去。今天再回去理下首页 A、B、C 定点跳转功能实现方法。首先是右边小索引布局以及数据绑定，数据绑定和名片夹列表上的字母一样，该字母下面有名片则渲染出来，没有则不需要渲染，id同样是当前字母与右边显示的内容一样：数据 sort，和 group.name 数据一样：这里是因为 # 不支持设为 id（就是 id=”#”），故而进行了一个转化。点击事件：获取到当前 ID，以及绑定数据 toView 为当前 ID。首先名片列表，名片上的字母索引都在 scroll-view 里面，这个 scroll-view 必须设置好固定的高度，设置成 100% 与 100vh 是无效的，y 轴的滚动开关打开，scroll-into-view 需要跳转到它子元素的 id 上。可以看下：这个 group.name==sortmsg，等于就是 A==A,B==B 同理。在这里如顶部有些菜单栏的话，你就要注意好布局了，不然会出现向下偏移这个菜单栏的高度，其实你只要和字母索引同级下即可避免此问题（这里的顶部菜单以模板分离出去了，分离模板的时候需注意下，需要在这里绑定模板的一些数据会出现失效，具体没有继续深入研究下去）。跳转功能基本实现（ohter 就是 # 底部）。"}
{"title": "微信小程序开发教程第五章：名片夹详情页开发 ", "author": "admin", "put_time": "2016-10-12 22:39", "content": "先看下「名片盒」详情页的效果图：备注下大致需求：顶部背后是轮播图，二维码按钮弹出模态框信息、点击微信栏、点击存入手机，地址栏需要地图展示，名片分享也是模态框指引。首先是轮播图，autoplay 自动播放，interval 轮播的时间，duration 切换速度，可以根据自己需求去添加。Delete：是删除按钮，加载进来是隐藏的，需用户点轮播图进去后，轮播图全屏显示才出来。noClickImg 与 ClickImg：切换全屏与非全屏轮播图，绑定了点击事件 changeClick 来切换，只是改变样式即可。Block：图片列表。Number_img：当前轮播 index（currentNumber），与图片 length 集合（cardnum）。其中 currentNumber：//轮播图发生改变时改变数字//初始化数据Data:{currentNumber:1}slidechange:function(e){var number = e.detail.current;this.setData({currentNumber:number+1})},这里可以看到全屏状态下当关闭按钮被点击后 getBackStyle，把 changeClick 切换到 imgFullScrenn 待命。再次点击返回原样式，切换后事件又走回到 getBackStyle 了，灵活运用。刷新下开发者工具可以看到具体效果如下：详情页可以看到信息基本都是样式一样，可以使用微信提供的循环 block。下面是详情页里面的个人信息数据，如果有信息就显示出来，没有数据的不显示，这里使用//中文信息               var chinaMessage = res.card.groups[0].fields;var personMessage= []               for(var i = 0;i                personMessage.push(chinaMessage[i])               }               //为空或者null是不显示判断              for(var k in personMessage){                if(personMessage[k].value==null || personMessage[k].value==\"\"){                personMessage[k][\"display\"] = \"none\";                }else{                personMessage[k][\"display\"] = \"block\";                }               }具体以 json 数据格式来处理，我们需要做的就是给它绑定 display 的值，然后我们调用即可。微信此版本的 setData 不支持异步更新数据，故而我们在发生真实网络数据请求时一定要在后面加上 forceUpdata()，强制触发视图渲染，否则会出现很多莫名其妙的 bug。这里说明下：如是服务器真实数据。可以看到会报错，可能是 js 的执行顺序，依次往下走，此时网络数据还在请求中。定义一个变量即可。当然这里的数据都是 push 上来的。以下是二维码弹出信息。这是弹出模态框二维码信息，布好局初始化是none状态。那里需要它直接绑定数据即可：This.setData({//模态框名字:”显示？隐藏”})方法是让它显示。需要用他的地方调用方法即可。(支持重复调用)详情页公司位置地图直接调用微信提供的接口实现（群里的 demo 有实现方式）。可以看下实现的效果："}
{"title": "小程序登录数据解密 ", "author": "Rolan", "put_time": "2019-6-19 00:13", "content": "小程序开发中，需要用户授权登陆并获取用户的数据，快速对接用户系统。openId与unionid的区别openId : 用户在当前小程序的唯一标识 unionId : 如果开发者拥有多个移动应用、网站应用、和公众帐号（包括小程序），可通过unionid来区分用户的唯一性，因为只要是同一个微信开放平台帐号下的移动应用、网站应用和公众帐号（包括小程序），用户的unionid是唯一的。换句话说，同一用户，对同一个微信开放平台下的不同应用，unionId是相同的。详情登录微信开放平台(open.weixin.qq.com) 。GET  https://api.weixin.qq.com/sns/jscode2session?appid=xx&secret=xx&js_code=xx&grant_type=authorization_code\r\n\r\n属性类型默认值必填说明\r\nappid    string    是    小程序 appId    \r\nsecret    string    是    小程序 appSecret    \r\njs_code    string    是    登录时获取的 code    \r\ngrant_type    string    是    授权类型，此处只需填写 authorization_code    \r\n\r\n\r\nObject\r\n返回的 JSON 数据包\r\n属性类型说明\r\nopenid    string    用户唯一标识    \r\nsession_key    string    会话密钥    \r\nunionid    string    用户在开放平台的唯一标识符，在满足 UnionID 下发条件的情况下会返回，详见 UnionID 机制说明。    \r\nerrcode    number    错误码    \r\nerrmsg    string    错误信息解密类class WxBizDataCrypt\r\n{\r\n    private $appid;\r\n    private $sessionKey;\r\n\r\n    /**\r\n     * 构造函数\r\n     * @param $sessionKey string 用户在小程序登录后获取的会话密钥\r\n     * @param $appid string 小程序的appid\r\n     */\r\n    public function __construct( $appid, $sessionKey)\r\n    {\r\n        $this->sessionKey = $sessionKey;\r\n        $this->appid = $appid;\r\n    }\r\n\r\n\r\n    /**\r\n     * 检验数据的真实性，并且获取解密后的明文.\r\n     * @param $encryptedData string 加密的用户数据\r\n     * @param $iv string 与用户数据一同返回的初始向量\r\n     * @param $data string 解密后的原文\r\n     *\r\n     * @return int 成功0，失败返回对应的错误码\r\n     */\r\n    public function decryptData( $encryptedData, $iv, &$data )\r\n    {\r\n        if (strlen($this->sessionKey) != 24) {\r\n            return ErrorCode::$IllegalAesKey;\r\n        }\r\n        $aesKey=base64_decode($this->sessionKey);\r\n\r\n\r\n        if (strlen($iv) != 24) {\r\n            return ErrorCode::$IllegalIv;\r\n        }\r\n        $aesIV=base64_decode($iv);\r\n\r\n        $aesCipher=base64_decode($encryptedData);\r\n\r\n        $result=openssl_decrypt( $aesCipher, \"AES-128-CBC\", $aesKey, 1, $aesIV);\r\n\r\n        $dataObj=json_decode( $result );\r\n        if( $dataObj  == NULL )\r\n        {\r\n            return ErrorCode::$IllegalBuffer;\r\n        }\r\n        if( $dataObj->watermark->appid != $this->appid )\r\n        {\r\n            return ErrorCode::$IllegalBuffer;\r\n        }\r\n        $data = $result;\r\n        return ErrorCode::$OK;\r\n    }\r\n}代码如下仅供参考转载时请注明出处及相应链接，本文永久地址：https://blog.yayuanzi.com/25402.html"}
{"title": "基于uni-app的缓存器 ", "author": "Rolan", "put_time": "2019-6-19 00:34", "content": "在前端开发应用程序中，性能一直都是被大家所重视的一点，然而判断一个应用程序的性能最直观的就是看页面打开的速度。其中提高页页面反应速度的一个方式就是使用缓存。一个优秀的缓存策略可以缩短页面请求资源的距离，减少延迟，并且由于缓存文件可以重复利用，还可以减少带宽，降低网络负荷。前端常用缓存技术在这里我就不再描述，下面基于Storage对其进行增强，采用Map 基本相同的api。阅读以下内容时遇到不懂的，请先科普阮一峰老师的ECMAScript 6 入门下面是基本代码，会在此基础上进行增强class MinCache {\r\n  // 将数据存储在本地缓存中指定的 name 中\r\n  set (name, data) {\r\n    try {\r\n      uni.setStorageSync(name, data)\r\n    } catch (e) {\r\n      console.log(e)\r\n    }\r\n  }\r\n  // 从本地缓存中获取指定 name 对应的内容\r\n  get (name) {\r\n    let data\r\n    try {\r\n      data = uni.getStorageSync(name)\r\n    } catch (e) {\r\n      console.log(e)\r\n    }\r\n    return data\r\n  }\r\n  // 从本地缓存中移除指定 key\r\n  delete (name) {\r\n    try {\r\n      uni.removeStorageSync(name)\r\n    } catch (e) {\r\n      console.log(e)\r\n    }\r\n  }\r\n  // 返回一个布尔值，表示 name 是否在本地缓存之中\r\n  has (name) {\r\n    const value\r\n    try {\r\n      const res = uni.getStorageInfoSync()\r\n      value = res.keys.includes(name)\r\n    } catch (e) {\r\n      console.log(e)\r\n    }\r\n    return value\r\n  }\r\n  // 清理本地数据缓存\r\n  clear () {\r\n    try {\r\n      uni.clearStorageSync()\r\n    } catch (e) {\r\n      console.log(e)\r\n    }\r\n  }\r\n}\r\n\r\nexport default MinCache复制代码我们知道缓存往往是有危害的，那么我们最好规定个时间来去除数据。class CacheCell {\r\n  constructor (data, timeout) {\r\n    this.data = data\r\n    // 设置超时时间，单位秒\r\n    this.timeout = timeout\r\n    // 对象创建时候的时间\r\n    this.createTime = Date.now()\r\n  }\r\n}复制代码set (name, data, timeout = 1200) {\r\n    const cachecell = new CacheCell(data, timeout)\r\n    try {\r\n      uni.setStorageSync(name, cachecell)\r\n    } catch (e) {\r\n      console.log(e)\r\n    }\r\n  }\r\n  get (name) {\r\n    let data = null\r\n    try {\r\n      data = uni.getStorageSync(name)\r\n      if (!data) return null\r\n      const currentTime = Date.now()\r\n      const overTime = (currentTime - data.createTime) / 1000\r\n      if (overTime > data.timeout) {\r\n        try {\r\n          uni.removeStorageSync(name)\r\n          data = null\r\n        } catch (e) {\r\n          console.log(e)\r\n        }\r\n      }\r\n    } catch (e) {\r\n      console.log(e)\r\n    }\r\n    return data\r\n  }复制代码使用了过期时间进行缓存的方式，已经可以满足绝大部分的业务场景。uni-app的Storage在不同端的实现不同：H5端为localStorage，浏览器限制5M大小，是缓存概念，可能会被清理App端为原生的plus.storage，无大小限制，不是缓存，持久化各个小程序端为其自带的storage api，数据存储生命周期跟小程序本身一致，即除用户主动删除或超过一定时间被自动清理，否则数据都一直可用。微信小程序单个 key 允许存储的最大数据长度为 1MB，所有数据存储上限为 10MB。支付宝小程序单条数据转换成字符串后，字符串长度最大200*1024。同一个支付宝用户，同一个小程序缓存总上限为10MB。百度、头条小程序文档未说明大小限制除此之外，H5端还支持websql、indexedDB、sessionStorage；App端还支持SQLite、IO文件等本地存储方案。我们可以看出来Storage在一些端中是有大小限制的，其实我们的数据只是想要缓存，不一定要持久化。也就是说在应用程序生命周期内使用就行，而且直接操作Storage也不是很好。我们知道ES6中有Map可以做缓存下面代码时基于Map封装的let cacheMap =  new Map()\r\nlet instance = null\r\nlet timeoutDefault = 1200\r\n\r\nfunction isTimeout (name) {\r\n  const data = cacheMap.get(name)\r\n  if (!data) return true\r\n  if (data.timeout === 0) return false\r\n  const currentTime = Date.now()\r\n  const overTime = (currentTime - data.createTime) / 1000\r\n  if (overTime > data.timeout) {\r\n    cacheMap.delete(name)\r\n    return true\r\n  }\r\n  return false\r\n}\r\n\r\nclass CacheCell {\r\n  constructor (data, timeout) {\r\n    this.data = data\r\n    this.timeout = timeout\r\n    this.createTime = Date.now()\r\n  }\r\n}\r\n\r\nclass Cache {\r\n  set (name, data, timeout = timeoutDefault) {\r\n    const cachecell = new CacheCell(data, timeout)\r\n    return cacheMap.set(name, cachecell)\r\n  }\r\n  get (name) {\r\n    return isTimeout(name) ? null : cacheMap.get(name).data\r\n  }\r\n  delete (name) {\r\n    return cacheMap.delete(name)\r\n  }\r\n  has (name) {\r\n    return !isTimeout(name)\r\n  }\r\n  clear () {\r\n    return cacheMap.clear()\r\n  }\r\n  setTimeoutDefault (num) {\r\n    if (timeoutDefault === 1200) {\r\n      return timeoutDefault = num\r\n    }\r\n    throw Error('缓存器只能设置一次默认过期时间')\r\n  }\r\n}\r\n\r\nclass ProxyCache {\r\n  constructor () {\r\n    return instance || (instance = new Cache())\r\n  }\r\n}\r\n\r\nexport default ProxyCache复制代码对Storage和Map封装的缓存进行整合我们来分析一下Storage和Map共用一套api在命名上解决以下划线_开头命名的缓存到Storage，并且Map也有副本尽量不操作Storage(读取速度慢)那就必须在应用程序初始化的时候把Storage加载进Map像Vue插件一样使用let cacheMap =  new Map()\r\nlet timeoutDefault = 1200\r\n\r\nfunction isTimeout (name) {\r\n  const data = cacheMap.get(name)\r\n  if (!data) return true\r\n  if (data.timeout === 0) return false \r\n  const currentTime = Date.now()\r\n  const overTime = (currentTime - data.createTime) / 1000\r\n  if (overTime > data.timeout) {\r\n    cacheMap.delete(name)\r\n    if (name.startsWith('_')) {\r\n      try {\r\n        uni.removeStorageSync(name)\r\n      } catch (e) {\r\n        console.log(e)\r\n      }\r\n    }\r\n    return true\r\n  }\r\n  return false\r\n}\r\n\r\nclass CacheCell {\r\n  constructor (data, timeout) {\r\n    this.data = data\r\n    this.timeout = timeout\r\n    this.createTime = Date.now()\r\n  }\r\n}\r\n\r\nclass MinCache {\r\n  constructor (timeout) {\r\n    try {\r\n      const res = uni.getStorageInfoSync()\r\n      res.keys.forEach(name => {\r\n        try {\r\n          const value = uni.getStorageSync(name)\r\n          cacheMap.set(name, value)\r\n        } catch (e) {\r\n          console.log(e)\r\n        }\r\n      })\r\n    } catch (e) {\r\n      console.log(e)\r\n    }\r\n    timeoutDefault = timeout\r\n  }\r\n  set (name, data, timeout = timeoutDefault) {\r\n    const cachecell = new CacheCell(data, timeout)\r\n    let cache = null\r\n    if (name.startsWith('_')) {\r\n      try {\r\n        uni.setStorageSync(name, cachecell)\r\n        cache = cacheMap.set(name, cachecell)\r\n      } catch (e) {\r\n        console.log(e)\r\n      }\r\n    } else {\r\n      cache = cacheMap.set(name, cachecell)\r\n    }\r\n    return cache\r\n  }\r\n  get (name) {\r\n    return isTimeout(name) ? null : cacheMap.get(name).data\r\n  }\r\n  delete (name) {\r\n    let value = false\r\n    if (name.startsWith('_')) {\r\n      try {\r\n        uni.removeStorageSync(name)\r\n        value = cacheMap.delete(name)\r\n      } catch (e) {\r\n        console.log(e)\r\n      }\r\n    } else {\r\n      value = cacheMap.delete(name)\r\n    }\r\n    return value\r\n  }\r\n  has (name) {\r\n    return !isTimeout(name)\r\n  }\r\n  clear () {\r\n    let value = false\r\n    try {\r\n      uni.clearStorageSync()\r\n      cacheMap.clear()\r\n      value = true\r\n    } catch (e) {\r\n      console.log(e)\r\n    }\r\n    return value\r\n  }\r\n}\r\n\r\nMinCache.install = function (Vue, {timeout = 1200} = {}) {\r\n  Vue.prototype.$cache = new MinCache(timeout)\r\n}\r\n\r\nexport default MinCache复制代码使用方法name以下划线_开头命名的缓存到Storage，并且Map也有副本事件名参数说明返回值setname缓存的key,data缓存的数据,timeout(必须数字单位s)缓存时间，默认缓存1200s, timeout设置为0表示永久缓存设置缓存数据Map集合getname缓存的key获取数据(缓存过期将返回null)返回缓存的数据datahasname缓存的key检查值true/falsedeletename缓存的key删除数据true/falseclear-清空Storage和Map缓存数据true/false// 注册缓存器\r\nVue.use(MinCache)\r\n// 设置默认缓存时间\r\n// Vue.use(MinCache, {timeout: 600})复制代码// 'name'不是以下划线开头的表示会缓存到Map中，在程序生命周期内有并且在有效时间内有效\r\nthis.$cache.set('name', 'MinCache')\r\n\r\n// 过期时间设置为0表示不会过期\r\n// 注意：'test'并不是以下划线命名表示在程序生命周期永久缓存\r\nthis.$cache.set('test', 'testdemo', 0)\r\n\r\n// 过期时间设置为0表示不会过期\r\n// 注意：'_imgURL'是以下划线命名表示永久缓存到Storage\r\nthis.$cache.set('_imgURL', 'data', 0)复制代码// 获取缓存的数据\r\nthis.imgURL = this.$cache.get('_imgURL')\r\nthis.name = this.$cache.get('name')\r\nthis.test = this.$cache.get('test')复制代码具体使用方法可以参考\tgithubuni-app路由的封装"}
{"title": "小程序如何做全局重新加载 ", "author": "Rolan", "put_time": "2019-6-4 00:44", "content": "背景：随着业务的增加，我们服务器需要计算大量的用户数据，导致用户跟客服反应页面不能正常展示。反馈给开发后，我们一看，是服务器异常的错误。So，产品想看下我们到底有多少用户页面不能正常展示？方案：后端人员直接在阿里云后台去查哪些接口异常 前端做一个服务器报错页，这样产品在小程序后台能看到这个页面的PV,UV技术方案因为业务庞大，所以我们不可能区在每个页面加上重新加载的逻辑。所以初步考虑使用全局重新加载。需要解决的问题都有哪些？1、首先我们要有网络请求失败的全局控制权（要不然就需要在每个页面处理失败的情况） 2、需要定义好网络失败后是如何跳转到重载页（R）的（用wx.redirectTo，wx.reLaunch还是其他） 3、点击错误页的“重新加载”，如何返回或跳转到出错页(E)（用wx.redirectTo，wx.reLaunch还是其他） 4、跳转到出错页后，如何重新加载数据（把所有请求都放在Page.onShow()里面?） 5、那如果从出错页的上个界面(P)传到出错页（E）options，那重载页（R）又将如何处理？ 6、点击重新加载跟返回，我们希望效果效果一样，又该如何操作？实践的方式如下1、第一个问题： 比较好解决，我们基于wx.request已经封装了为fetch（如果还在用wx.request的项目可以考虑封装下，好处多多）。基于fetch我们可以用res.statusCode来判断服务器是否出错。 2、第二个问题： 暂且先不说具体的跳转方式是怎样的，就跳转的url这个怎么定义也需要我们来讨论下。为什么这么说，因为我们的架构涉及到了分包。分包加载意味着我们的代码不仅仅是在pages下面，还放在了package下。 基于此，我们在跳转的时候，url能直接写成'../serverError/serverError'吗？在主包下面可以正常跳转，但是在分包下，路径是'package/serverError/serverError'，这样跳肯定不行。url应该是根目录下的路径，所以'/pages/serverError/serverError'。 路径确认后，我们可以跳转了。如果是wx.redirectTo（关闭当前页面，跳转到应用内的某个页面），想象下关闭E跳转到R，点击重新加载，再关闭R跳转到E，这么跳转路径复杂，用户体验不好，并且options的参数需要逐级传递。wx.reLaunch类似。我们用所以我们选择wx.navigateTo。 3、第三个问题： 综合问题二的解释，跳回到E，我们用wx.navigateBack。 4、第四个问题： 如果从R用wx.navigateBack回到E的话，肯定会触发E.onShow()方法。但是有些请求我们除了写在Page.onShow()里，还有些是写在Page.onLoad()里的，所以我们必须想办法调起E.onLoad()。 大家对于getCurrentPages()这个方法肯定不陌生，官方定义是来获取当前页面栈，我们一般用它来获取当前页面路径。其实在这个过程中，我们是能拿到当前页面的实例的，并且实例里面有route（页面路径）options（页面传递参数）data(页面初始参数)以及各种function()等等。 利用previousPageClass()我们可以拿到E的实例，也就可以拿到E.options，当然我们也可以调E.onLoad()。 util.js// 获取当前路径function currentPagePath() {  let pageData = getCurrentPages()  if (pageData.length >= 1) {    let len = pageData.length - 1    let data = pageData[len]    return data.route  } else {    return ''  }}// 获取上个界面的实例function previousPageClass() {  let pageData = getCurrentPages()  if (pageData.length >= 2) {    let len = pageData.length - 2    let preClass = pageData[len]    return preClass  } else {    return ''  }}module.exports = {  currentPagePath,  previousPageClass}第五个问题： 基于问题的四的方案，我们可以调E.onLoad(E.options)来将我们的参数回传回去。 第六个问题： 点击返回，相当于页面卸载，也就是执行了R.onUnload(),这个时候我们只需要执行E.onLoad(E.options)这个方法，把options传过去，以及调用起E.onLoad()就OK了。 但是点击重新加载，我们是调的wx.navigateBack()，这个方法也会走R.onUnload()。这是时候可能有些苦恼了，我们隐藏掉返回按钮？发现官方并没有提供此方法。禁用R.onUnload()，好像也不行。因为R.onUnload()是在点击重新加载后才执行的，所以我们可以记录下用户是否点击了重新加载的行为。然后我们通过记录的行为，即便用户点击了重新加载，然后触发了R.onUnload()，我们不去执行E.onLoad(E.options)就OK了。 // pages/serverError/serverError.jsimport { previousPageClass } from '../../utils/util.js'let isClickReload = falsePage({  onLoad: function (options) {    isClickReload = false  },  onUnload: function () {    if(!isClickReload) {      this.callbackParams()    }      },  /**   * 点击事件   */  clickReload: function (e) {    isClickReload = true    wx.navigateBack()    this.callbackParams()  },  // 点击返回，参数回传  callbackParams: function () {    let preOptions = previousPageClass().options    previousPageClass().onLoad(preOptions)  }})至此所有问题，基本都已解决。 Demo代码附上，欢迎参考。"}
{"title": "滴滴小程序框架Mpx支持小程序跨平台开发，可直接转换已有微信小程序 ... ", "author": "Rolan", "put_time": "2019-6-4 00:49", "content": "Mpx是一款致力于提高小程序开发体验和效率的增强型小程序框架，目前在滴滴公司内部支撑了包括滴滴出行小程序，滴滴出行广场小程序，青桔单车，黑马电单车，小桔养车，小桔加油在内的小程序生态；自去年11月开源以来，Mpx也吸纳了众多外部开发者的加入，基于Mpx开发了开走吧，好免街，花忆等小程序。\r\n长期以来，Mpx优秀的开发体验和强大的稳定性得到了内外开发者的一致认可和好评，这非常符合Mpx的设计初衷。但是在各大厂商陆续推出自己的小程序平台，且各家的技术标准都不统一的今天，单纯地提高某一个平台的开发体验已经不能满足广大小程序开发者们的诉求，一套代码在多小程序平台运行已经成为一个现实上的刚需。为了解决这个小程序开发的痛点，Mpx发布了2.0版本，适配了目前业内已经发布的所有小程序平台(微信、支付宝、百度、头条、qq)，并且提供了直接将现有微信小程序编译输出到其他平台运行的能力。\r\nMpx2.0版本新增的主要特性主要包含：\r\n\r\n完整支持了目前业内已发布的所有小程序平台(微信，支付宝，百度，qq，头条)；\r\nMpx小程序跨平台开发，支持将已有的Mpx微信项目编译输出到其他已支持的小程序平台中运行，点击查看详情；\r\n小程序原生组件跨平台编译，支持将已有的微信原生组件编译输出到其他已支持的小程序平台中运行；\r\n深度分包优化，编译过程中进行精准分包资源判断，所有分包only的资源(组件、js、外部样式、外部模板、wxs，图像媒体等)都会精确输出到分包目录中；\r\nrender函数中完整支持wxs模块，关于render函数点击查看详情；\r\n支持了模板引入，内联wxs，自定义tabbar，独立分包，workers，云开发等原生能力，进一步完善原生兼容性。\r\n\r\n同业内主流的小程序跨端框架相比，Mpx更专注于小程序开发本身，在小程序开发中具备以下优势：\r\n\r\n基于小程序自身的技术标准进行增强，没有进行过重的DSL转换，开发时遇到的坑会更少；\r\n完全兼容原生小程序技术规范，0成本迁移原生小程序项目;\r\n跨平台开发以跨小程序平台为目标，大部分差异抹平工作在编译阶段进行，大大减少运行时适配层增加的包体积；\r\n支持业内微信小程序组件库(如vant、iView等)直接转换到其他小程序平台运行;\r\n非常重视小程序性能，提供了深度的setData和包体积优化。\r\n\r\n关于Mpx更详细的介绍可以查看官方文档和这篇文章。\r\nGithub：github.com/didi/mpx\r\n跨平台开发\r\n作为2.0版本的核心能力，Mpx的跨平台开发能力允许用户直接将已有小程序项目编译输出到其他已支持的小程序平台中运行。微信小程序作为小程序概念的提出者，有着最广泛的生态覆盖，因此我们优先支持了将微信小程序编译为其他平台小程序的能力。基于这个能力，用户不仅能跨平台编译微信Mpx项目，甚至能够将微信的原生自定义组件也编译到其他小程序平台进行运行，这意味着我们的跨平台项目能够直接使用一些社区内已有的UI组件库生态(如vant、iView等)，极大地提高了跨平台开发的适用范围。\r\n设计理念\r\nMpx框架的核心设计理念在于增强，增强是指在小程序已有的原生能力基础上做加法，拓展小程序的开发能力，提高小程序的开发体验和效率。这个设计理念使Mpx给开发者带来了更强的确定性和可预期性，更低的学习上手和调试成本。基于这个理念，Mpx在不同的小程序平台中进行了差异性的增强适配，并参考各个平台的模板指令风格提供了不同的增强模板指令集，让用户在各小程序平台中都可以以增强的方式去最大限度地使用平台自有的原生能力。\r\n我们在对Mpx提供跨平台能力的支持时也遵循了增强的核心设计理念。简单来讲，Mpx的跨平台能力是在多平台能力的基础上，在编译和运行时增加了一层转换层，将源平台的代码转换为目标平台的代码之后，再按照既有的目标平台的处理逻辑进行增强，同时我们也提供了一套完善的条件编译机制，让用户自行实现少数框架无法转换的部分。\r\n\r\nMpx跨平台开发流程示意图\r\nMpx跨平台能力设计思路明显区别于业内已有的其他小程序跨平台框架，主要差异在于：\r\n\r\nMpx以小程序本身的DSL作为基准，而没有使用web框架(React,Vue)的DSL；\r\nMpx主要通过编译和运行时转换的方式处理平台差异，没有提供额外的差异抹平层(基础组件库等)。\r\n\r\n之所以采用这种设计，主要基于以下原因：\r\n\r\nMpx主要以跨小程序平台为目标，目前各大小程序平台的技术规范具有一定相似性，绝大部分平台差异能够通过编译和运行时手段抹平，同时省去的差异抹平层也能够进一步减少框架运行时体积；\r\n使用小程序本身的DSL作为基准允许用户直接在已有项目中使用跨平台能力，对于原生小程序项目或组件也能够使用该能力进行跨平台输出；\r\n结合完善的条件编译支持，该方案能够在满足用户跨平台需求的同时仍然允许用户最大限度地使用各个小程序平台提供的能力，完全延续了Mpx增强的核心设计理念。\r\n\r\n使用方法\r\nMpx跨平台开发的使用方式非常简单，用户只需在MpxWebpackPlugin创建时传入mode和srcMode参数指定源平台和目标平台，当srcMode和mode不一致时，框架会读取相应的配置对项目进行编译和运行时转换。\r\n// 微信转支付宝\r\nnew MpxWebpackPlugin({\r\n  // mode指定目标平台，可选值有(wx|ali|swan|qq|tt)\r\n  mode: 'ali',\r\n  // srcMode指定源码平台，默认值同目标平台一致 \r\n  srcMode: 'wx' \r\n})\r\n复制代码差异抹平\r\n目前各大厂商的小程序技术规范在宏观层面上大致保持一致，但是技术细节方面存在很多差异，大致划分为以下几个部分：\r\n\r\n模板语法/基础组件差异\r\njson配置差异\r\nwxs语法差异\r\n页面/组件对象差异\r\napi调用差异\r\nwebview bridge差异\r\n\r\n其中，对于模板语法/基础组件、json配置和wxs中的静态差异，我们主要通过编译手段进行转换处理，对于这部分差异中无法转换的部分会在编译阶段报错指出；而对于页面/组件对象、api调用和webview bridge中js运行时的差异，我们主要通过运行时手段进行处理，对应的无法转换部分也会在运行时中报错指出。\r\n值得注意的是，我们在跨平台转换中做的工作不仅是对可转换的技术标准进行转换映射，对于一些目标平台中不存在的能力，我们也尽可能地通过编译和运行时手段提供了模拟和支持，最大限度地减少用户在跨平台开发中需要付出的额外工作量。以差异性最大但现实场景也最多的微信转支付宝为例，Mpx模拟提供了许多微信中支持但支付宝中未支持的能力：\r\n\r\n组件自定义事件\r\n组件间关系\r\n获取子组件实例\r\nobservers/property observer\r\n内联wxs\r\n外部样式类\r\n\r\n对于原生自定义组件的跨平台转换，我们会对其进行简单的运行时注入，使其能够使用Mpx框架提供的运行时转换能力。\r\n条件编译\r\n对于框架无法抹平的差异部分，会在编译和运行时报错指出，对于这部分错误，我们提供了完善的条件编译机制让用户能够自行编写目标平台的patch进行修复，该能力也能用于实现具有平台差异性的业务逻辑。\r\n上文中提到Mpx通过读取用户传入的mode和srcMode来决定是否以及如何对项目进行转换，mode和srcMode分别代表整个项目构建的目标平台和源平台，条件编译能够让用户在项目中创建声明了自身平台属性(localSrcMode)的文件和代码块。在项目构建中，框架会优先加载带有localSrcMode声明且localSrcMode与项目目标平台匹配(localSrcMode===mode)的文件和代码块，这部分文件和代码块需要完全依照自身声明的平台标准进行编写，Mpx不会对其进行任何编译和运行时的跨平台转换。\r\nMpx提供了三种维度的条件编译，分别是文件维度，区块维度和代码维度，用户可以根据平台差异的覆盖范围灵活选择使用。\r\n性能优化\r\nMpx框架专注于小程序开发，在性能优化方面我们做过很多尝试和努力，主要集中在两个方面：\r\n\r\n运行时的setData优化\r\n编译构建时的包体积优化\r\n\r\nsetData优化\r\n数据响应是Mpx运行时增强的核心能力，该能力让用户在小程序开发中能够像Vue中一样使用watch和computed特性，并且用直接赋值的方式操作数据驱动视图更新，而不需要手动调用setData方法，换言之框架接管了小程序中的setData调用。\r\n通过各大小程序平台的设计原理和性能优化建议可以得知，setData对于小程序的性能表现非常重要，而setData优化的两大方向在于：\r\n\r\n尽可能减少setData调用的频次\r\n尽可能减少单次setData传输的数据\r\n\r\n为了实现setData的优化，我们在模板编译过程中对于每个组件的模板都生成了一个渲染函数(render function)，该函数模拟模板的渲染逻辑，在每次执行时访问当次渲染所需的数据，并将当次访问过的数据路径记录下来作为函数返回值返回。\r\n在运行时，框架会在每个组件创建时创建一个render watcher，该watcher追踪渲染函数，当渲染依赖数据发生变更时异步执行渲染函数，在render watcher回调中得到渲染函数返回的数据路径，基于这些路径与上一次的缓存数据进行diff比对，过滤掉未发生变化的数据后得到最小必要数据，最后调用setData将最小必要数据发送到真实的小程序渲染层更新视图。\r\n基于这个机制，当数据发生变更时，只有当前渲染依赖的那部分数据发生变更才会异步地触发render watcher的执行，而每次执行后也只有实际发生变更的那部分数据会被setData发送到渲染层。这样用户就能自由地根据业务需求来操作数据，无需关注setData的调用优化，框架能够自动进行程序上最优的setData调用，在提升用户开发体验的同时也提升了程序性能。\r\n在1.x版本中，渲染函数内无法执行wxs的逻辑，对于含有wxs的组件有可能降级到全量设置数据的模式，在2.0版本中，我们将wxs模块转译处理为js可执行的代码后注入到js bundle中，含有wxs的渲染函数也能够正常访问并执行wxs逻辑。\r\n\r\nsetData优化示意图\r\n包体积优化\r\n类似于运行时对于setData的接管，Mpx在编译阶段接管了项目的资源管理。得益于webpack强大的插件机制，Mpx开发了一个深度定制的webpack插件，基于webpack完成小程序的打包构建工作。用户在使用Mpx开发小程序时可以不受限制地使用npm依赖、最新的es特性和css预处理器等现代web开发能力。与此同时，Mpx在包体积优化上也做了很多工作，让用户专注于业务开发而无需花费过多精力进行包体积管理，我们所做的优化工作如下：\r\n\r\n打包构建工作完全基于依赖分析，任何没有被引用的资源都不会出现在dist当中；\r\n对于npm组件和页面的构建也完全基于依赖分析按需打包，不会copy整个miniprogram_dist目录，也不需要执行构建npm，使用体验和包体积均优于微信小程序自身的npm支持方案；\r\n基于webpack提供的能力进行公共模块抽取和代码压缩等优化工作；\r\n完善的分包支持，对所有资源进行从属分析，将所有分包only的资源都输出到分包目录中。\r\n\r\n分包作为微信小程序中优化包体积的核心手段(类似于异步按需加载)，Mpx对其进行了完善的支持。为了精确地标记出分包only的资源，我们在构建时将主包和分包的依赖收集步骤拆分开来串行处理，先处理主包，再处理分包。在主包的处理过程中，将主包页面中引用的所有非js资源(组件、外部样式、外部模板、wxs，图像媒体等)都记录下来，在处理分包时，对分包内引用的非js资源都进行检查，如果被主包引用过则输出到主包中，否则标记为分包only的资源输出到分包目录下。\r\n对于js模块资源，我们在脚手架中生成的构建配置中提供了辅助函数，便于用户进行分包bundle的配置，经过该配置后，分包only的公用模块会被打入分包bundle输出到分包目录下，其余的公共模块会正常打入主bundle中。\r\n在跨平台开发中，我们建议用户使用Mpx提供的packages来定义分包，这样在转换到不支持分包的小程序平台时会自动降级为同步包进行处理。\r\n\r\n分包构建示意图\r\n渐进迁移\r\nMpx提供了良好的渐进迁移支持，对于使用原生或其他小程序框架的开发者来说，采用渐进迁移的方式逐步引入Mpx进行开发成本并不大。\r\n在2.0版本中我们进一步完善了Mpx的原生兼容性，跟进支持了各个小程序平台最新的技术能力，如自定义tabbar，独立分包，分包预加载，workers，云开发等能力，同时补齐了一些1.x版本遗漏的支持。得益于此，对于使用原生小程序开发的开发者来说，迁移Mpx的成本几乎为0，用户只需将对应页面组件的构造函数替换为Mpx提供的createPage/createCompnent，即可使用Mpx提供的各种增强能力。\r\n对于使用其他框架的开发者，Mpx也提供了局部构建的机制，允许用户将特定的页面和组件单独构建输出为原生组件，用户只需手动或者编写脚本输出的原生组件整合进原有项目中即可。\r\n未来规划\r\n作为滴滴公司内部小程序生态的基础设施，我们会对Mpx框架进行长期的维护更新，确保能在第一时间支持各个小程序平台最新的技术特性。与此同时，我们也会进一步完善框架的基础能力，目前已排上日程待支持能力包括：\r\n\r\ni18n\r\nts支持\r\n单元测试支持\r\n\r\n在跨平台能力方面，我们也会根据社区的反馈和建议，以及小程序的标准化进程，对其进行持续的完善与更新。\r\n最后，如果你专注小程序开发，关注开发体验和产品性能，那Mpx会是你最好的选择。"}
{"title": "微信小程序之网络通信 ", "author": "Rolan", "put_time": "2019-7-22 00:32", "content": "关于网络通信，这里我使用的是wx.request,官方代码示例如下:wx.request({\r\n  url: 'test.php', //仅为示例，并非真实的接口地址\r\n  data: {\r\n    x: '',\r\n    y: ''\r\n  },\r\n  header: {\r\n    'content-type': 'application/json' // 默认值\r\n  },\r\n  success (res) {\r\n    console.log(res.data)\r\n  }\r\n})对于初学者而言，官方示例可能会看不怎么懂，所以我就以我自己当初项目驱动学习的方式(开发个人的记账小程序)来作为学习实例。以登录来说，效果图如下:此次示例包含表单校验和网络请求，代码如下:login.js// pages/login/login.js\r\nPage({\r\n\r\n  /**\r\n   * 页面的初始数据\r\n   */\r\n  data: {\r\n    username: \"\",\r\n    password: \"\"\r\n\r\n  },\r\n   register:function(e){\r\n    wx.navigateTo({\r\n      url: '../register/register'\r\n    })\r\n\r\n  },\r\n  formSubmit: function(e) {\r\n    console.log(e.detail.value.email);\r\n    console.log(e.detail.value.pwd)\r\n    var username = e.detail.value.email;\r\n    var password = e.detail.value.pwd;\r\n    var emailReg = /^[A-Za-z\\d]+([-_.][A-Za-z\\d]+)*@([A-Za-z\\d]+[-.])+[A-Za-z\\d]{2,4}$/;\r\n    if (username == null || username == \"\") {\r\n      wx.showToast({\r\n        title: \"用户名不能为空\",\r\n        icon: 'none',\r\n        duration: 1500\r\n      })\r\n    } else if (!emailReg.test(username)) {\r\n\r\n      wx.showToast({\r\n        title: \"邮箱有误\",\r\n        icon: 'none',\r\n        duration: 1500\r\n      })\r\n\r\n    } else if (password == null || password == \"\") {\r\n      wx.showToast({\r\n        title: \"密码不能为空\",\r\n        icon: 'none',\r\n        duration: 1500\r\n      })\r\n    } else {\r\n      wx.request({\r\n\r\n        url: getApp().globalData.urlPath + \"sysUser/login\",\r\n        method: \"POST\",\r\n        data: {\r\n          username: username,\r\n          password: password\r\n        },\r\n        header: {\r\n          \"Content-Type\": \"application/x-www-form-urlencoded\"\r\n        },\r\n        success: function(res) {\r\n          console.log(res.data);\r\n          if (res.statusCode == 200) {\r\n\r\n            //访问正常\r\n            if (res.data.code == \"000000\") {\r\n              wx.showToast({\r\n                title: \"登陆成功\",\r\n                icon: 'success',\r\n                duration: 2000,\r\n                success: function() {\r\n                  wx.navigateTo({\r\n                    url: '../manage/manage'\r\n                  })\r\n\r\n                  wx.setStorage({\r\n                    key: 'userId',\r\n                    data: res.data.user.userCode\r\n                  })\r\n\r\n                  wx.setStorage({\r\n                    key: 'userName',\r\n                    data: res.data.user.userName\r\n                  })\r\n                  console.log(\"test:\" + wx.getStorageSync('userName'));\r\n                }\r\n              })\r\n\r\n            } else if (res.data.code == \"111111\") {\r\n              wx.showToast({\r\n                title: \"密码错误\",\r\n                icon: 'none',\r\n                duration: 1500\r\n              })\r\n            } else {\r\n              wx.showToast({\r\n                title: \"该用户不存在\",\r\n                icon: 'none',\r\n                duration: 1500\r\n              })\r\n            }\r\n          } else {\r\n\r\n            wx.showLoading({\r\n              title: '系统异常',\r\n              fail\r\n            })\r\n\r\n            setTimeout(function() {\r\n              wx.hideLoading()\r\n            }, 2000)\r\n          }\r\n\r\n        }\r\n      })\r\n    }\r\n\r\n  }\r\n})关于login.js，主要是写通信逻辑的，与咱们平时写js差异并不大，唯一不同的就是api长得不样罢了。关于其中的getApp().globalData.urlPath，相当于全局变量，不用我每次都写一大串https之类的。表单校验的效果如图: 代码说明:显示消息提示框(相当于js的alert提示):wx.showToast({\r\n  title: \"邮箱有误\",\r\n  icon: 'none',\r\n  duration: 1500\r\n})获取input属性为name的值(相当于js中form.email.value,前提是这个表单name要为form，且form中的input要存在一个name=”email”)e.detail.value.email;跳转代码(相当于window.location.href):wx.navigateTo({\r\n url: '../manage/manage'\r\n})至于wx.request，我想只要是写过ajax的，都很好理解。login.json:{\r\n  \"usingComponents\": {}\r\n}关于这个login.json有什么用，我唯一想到的是页面的title(其实相当于html中的title)lgoin.wxml:<view class='container'>\r\n  <view class='header'>\r\n    <text>acs系统</text>\r\n  </view>\r\n    <view>\r\n    <text>\\n</text>\r\n  </view>\r\n  <view class='header'>\r\n  </view>\r\n  <form bindsubmit=\"formSubmit\">\r\n    <view class='section'>\r\n      <text>用户名：</text>\r\n      <input type='text' name=\"email\" placeholder='请输入邮箱' />\r\n    </view>\r\n    <view class='section'>\r\n      <text>密码:</text>\r\n      <input password='password' name=\"pwd\" placeholder='请输入密码' />\r\n    </view>\r\n    <view class='button'>\r\n      <button type='primary' form-type='submit'>登录</button>\r\n      <text>\\n</text>\r\n       <view bindtap='register' class=\"register\">注册</view>\r\n    </view>\r\n  </form>\r\n\r\n</view>wxml相当于视图(如html或者模板语言(jsp、volocity、freemarker、beetl等))视图除了可以写一些标签之类的，还可以写一些逻辑判断。后面会讲到的。login.wxss:/* pages/login/login.wxss */\r\nform{\r\n  width: 310px;\r\n  height: 240px;\r\n  line-height: 40px;\r\n  /* border: 1px solid red;  */\r\n}\r\ninput{\r\n  border: 1px solid #ccc;\r\n  width: 310px;\r\n  height: 40px;\r\n}\r\n.button{\r\n  margin-top: 20px;\r\n}\r\n.header text{\r\n  font-size: 25px;\r\n  color: #666;\r\n}\r\nform text{\r\n  font-size: 20px;\r\n  color: #666;\r\n}\r\n.register{\r\ncolor:black;\r\ndisplay: block;\r\nwidth: 310px;\r\nheight: 40px;\r\nborder: 1px solid #ccc;\r\ntext-align: center;\r\n}这个wxss就相当于css，定义视图的样式，决定视图长什么样(好看不好看)关于微信小程序网络通信，更多信息可以参考官方文档:wx.request"}
{"title": "小程序开发另类小技巧 --用户授权篇 ", "author": "Rolan", "put_time": "2019-7-22 00:42", "content": "getUserInfo较为特殊，不包含在本文范围内，主要针对需要授权的功能性api，例如：wx.startRecord，wx.saveImageToPhotosAlbum， wx.getLocation\r\n\r\n仓库地址：github.com/jinxuanzhen…\r\n\r\n背景\r\n小程序内如果要调用部分接口需要用户进行授权，例如获取地理位置信息，收获地址，录音等等，但是小程序对于这些需要授权的接口并不是特别友好，最明显的有两点：\r\n\r\n如果用户已拒绝授权，则不会出现弹窗，而是直接进入接口 fail 回调，\r\n没有统一的错误信息提示，例如错误码\r\n\r\n一般情况而言，每次授权时都应该激活弹窗进行提示，是否进行授权，例如：\r\n\r\n而小程序内只有第一次进行授权时才会主动激活弹窗（微信提供的），其他情况下都会直接走fail回调，微信文档也在句末添加了一句请开发者兼容用户拒绝授权的场景这种未做兼容的情况下如果用户想要使用录音功能，第一次点击拒绝授权，那么之后无论如何也无法再次开启录音权限**，很明显不符合我们的预期。\r\n所以我们需要一个可以进行二次授权的解决方案\r\n\r\n常见处理方法\r\n\r\n官方demo\r\n下面这段代码是微信官方提供的授权代码, 可以看到也并没有兼容拒绝过授权的场景查询是否授权（即无法再次调起授权）\r\n// 可以通过 wx.getSetting 先查询一下用户是否授权了 \"scope.record\" 这个 scope\r\nwx.getSetting({\r\n  success(res) {\r\n    if (!res.authSetting['scope.record']) {\r\n      wx.authorize({\r\n        scope: 'scope.record',\r\n        success () {\r\n          // 用户已经同意小程序使用录音功能，后续调用 wx.startRecord 接口不会弹窗询问\r\n          wx.startRecord()\r\n        }\r\n      })\r\n    }\r\n  }\r\n})\r\n复制代码\r\n一般处理方式\r\n那么正常情况下我们该怎么做呢？以地理位置信息授权为例：\r\nwx.getLocation({\r\n   success(res) { \r\n      console.log('success', res);\r\n   },\r\n   fail(err) {\r\n      // 检查是否是因为未授权引起的错误\r\n      wx.getSetting({\r\n         success (res) {               \r\n            // 当未授权时直接调用modal窗进行提示\r\n            !res.authSetting['scope.userLocation'] && wx.showModal({\r\n               content: '您暂未开启权限，是否开启',\r\n               confirmColor: '#72bd4a',\r\n               success: res => {              \r\n                  // 用户确认授权后，进入设置列表\r\n                  if (res.confirm) {\r\n                     wx.openSetting({\r\n                        success(res){\r\n                           // 查看设置结果\r\n                           console.log(!!res.authSetting['scope.userLocation'] ? '设置成功' : '设置失败');\r\n                        },\r\n                     });\r\n                  }\r\n               }\r\n            });\r\n         }\r\n      });\r\n   }\r\n});\r\n复制代码上面代码，有些同学可能会对在fail回调里直接使用wx.getSetting有些疑问，这里主要是因为\r\n\r\n微信返回的错误信息没有一个统一code\r\nerrMsg又在不同平台有不同的表现\r\n从埋点数据得出结论，调用这些api接口出错率基本集中在未授权的状态下\r\n\r\n这里为了方便就直接调用权限检查了 ，也可以稍微封装一下，方便扩展和复用，变成：\r\n  bindGetLocation(e) {\r\n        let that = this;\r\n        wx.getLocation({\r\n            success(res) {\r\n                console.log('success', res);\r\n            },\r\n            fail(err) {\r\n                that.__authorization('scope.userLocation');\r\n            }\r\n        });\r\n    },\r\n    bindGetAddress(e) {\r\n        let that = this;\r\n        wx.chooseAddress({\r\n            success(res) {\r\n                console.log('success', res);\r\n            },\r\n            fail(err) {\r\n                that.__authorization('scope.address');\r\n            }\r\n        });\r\n    },\r\n    __authorization(scope) {\r\n\t\t  \t/** 为了节省行数，不细写了，可以参考上面的fail回调，大致替换了下变量res.authSetting[scope] **/ \r\n    }\r\n复制代码看上去好像没有什么问题，fail里只引入了一行代码，\r\n这里如果只针对较少页面的话我认为已经够用了，毕竟**‘如非必要，勿增实体’，但是对于小打卡这个小程序来说可能涉及到的页面，需要调用的场景偏多**，我并不希望每次都人工去调用这些方法，毕竟人总会犯错\r\n\r\n梳理目标\r\n上文已经提到了背景和常见的处理方法，那么梳理一下我们的目标，我们到底是为了解决什么问题？列了下大致为下面三点：\r\n\r\n兼容用户拒绝授权的场景，即提供二次授权\r\n解决多场景，多页面调用没有统一规范的问题\r\n在底层解决，业务层不需要关心二次授权的问题\r\n\r\n\r\n扩展wx[funcName]方法\r\n为了节省认知成本和减少出错概率，我希望他是这个api默认携带的功能，也就是说因未授权出现错误时自动调起是否开启授权的弹窗\r\n为了实现这个功能，我们可能需要对wx的原生api进行一层包装了（关于页面的包装可以看：如何基于微信原生构建应用级小程序底层架构）\r\n\r\n为wx.getLocation添加自己的方法\r\n这里需要注意的一点是直接使用常见的装饰模式是会出现报错，因为wx这个对象在设置属性时没有设置set方法，这里需要单独处理一下\r\n// 直接装饰，会报错 Cannot set property getLocation of #<Object> which has only a getter \r\nlet $getLocation = wx.getLocation;\r\nwx.getLocation = function (obj) {\r\n    $getLocation(obj);\t\r\n};\r\n\r\n// 需要做一些小处理\r\nwx = {...wx};\t\t\t\t\t\t\t\t\t\t// \t对wx对象重新赋值\r\nlet $getLocation = wx.getLocation;\r\nwx.getLocation = function (obj) {\t\t\t\t\t\r\n    console.log('调用了wx.getLocation');\r\n    $getLocation(obj);\t\r\n};\r\n\r\n// 再次调用时会在控制台打印出 '调用了wx.getLocation' 字样\r\nwx.getLocation()\r\n复制代码\r\n劫持fail方法\r\n第一步我们已经控制了wx.getLocation这个api，接下来就是对于fail方法的劫持，因为我们需要在fail里加入我们自己的授权逻辑\r\n// 方法劫持\r\nwx.getLocation = function (obj) {\r\n    let originFail = obj.fail;\r\n\r\n    obj.fail = async function (errMsg) {\r\n        // 0 => 已授权 1 => 拒绝授权 2 => 授权成功\r\n        let authState = await authorization('scope.userLocation');\r\n        \r\n        // 已授权报错说明并不是权限问题引起，所以继续抛出错误\r\n        // 拒绝授权，走已有逻辑，继续排除错误\r\n        authState !== 2 && originFail(errMsg);\r\n    };\r\n    $getLocation(obj);\r\n};\r\n\r\n// 定义检查授权方法\r\nfunction authorization(scope) {\r\n    return new Promise((resolve, reject) => {\r\n        wx.getSetting({\r\n            success (res) {\r\n                !res.authSetting[scope]\r\n                    ? wx.showModal({\r\n                        content: '您暂未开启权限，是否开启',\r\n                        confirmColor: '#72bd4a',\r\n                        success: res => {\r\n                            if (res.confirm) {\r\n                                wx.openSetting({\r\n                                    success(res){\r\n                                        !!res.authSetting[scope] ? resolve(2) : resolve(1)\r\n                                    },\r\n                                });\r\n                            }else {\r\n                                resolve(1);\r\n                            }\r\n                        }\r\n                    })\r\n                    : resolve(0);\r\n            }\r\n        })\r\n    });\r\n}\r\n\r\n// 业务代码中的调用\r\n  bindGetLocation(e) {\r\n        let that = this;\r\n        wx.getLocation({\r\n            type: 'wgs84',\r\n            success(res) {\r\n                console.log('success', res);\r\n            },\r\n            fail(err) {\r\n                console.warn('fail', err);\r\n            }\r\n        });\r\n  }\r\n\r\n复制代码可以看到现在已实现的功能已经达到了我们最开始的预期，即因授权报错作为了wx.getLocation默认携带的功能，我们在业务代码里再也不需要处理任何再次授权的逻辑\r\n也意味着wx.getLocation这个api不论在任何页面，组件，出现频次如何，**我们都不需要关心它的授权逻辑（**效果本来想贴gif图的，后面发现有图点大，具体效果去git仓库跑一下demo吧）\r\n\r\n让我们再优化一波\r\n上面所述大致是整个原理的一个思路，但是应用到实际项目中还需要考虑到整体的扩展性和维护成本，那么就让我们再来优化一波\r\n代码包结构：本质上只要在app.js这个启动文件内，引用./x-wxx/index文件对原有的wx对象进行覆盖即可\r\n\r\n**简单的代码逻辑： **\r\n// 大致流程：\r\n\r\n//app.js\r\nwx = require('./x-wxx/index');\t\t\t\t\t\t// 入口处引入文件\r\n\r\n// x-wxx/index \r\nconst apiExtend = require('./lib/api-extend')；\r\nmodule.exports = (function (wxx) {\t\t\t\t    // 对原有方法进行扩展\r\n    wxx = {...wxx};\r\n    for (let key in wxx) {\r\n        !!apiExtend[key] && (()=> {\r\n\r\n            // 缓存原有函数\r\n            let originFunc = wxx[key];\r\n\r\n            // 装饰扩展的函数\r\n            wxx[key] = (...args) => apiExtend[key](...args, originFunc);\r\n        })();\r\n    }\r\n    return wxx;\r\n})(wx);\r\n\r\n// lib/api-extend\r\nconst Func = require('./Func');\r\n(function (exports) {\t\t\t\t\t\t\t\t// 需要扩展的api（类似于config）\r\n    // 获取权限\r\n    exports.authorize = function (opts, done) {\r\n        // 当调用为\"确认授权方法时\"直接执行，避免死循环\r\n        if (opts.$callee === 'isCheckAuthApiSetting') {\r\n            console.log('optsopts', opts);\r\n            done(opts);\r\n            return;\r\n        }\r\n        Func.isCheckAuthApiSetting(opts.scope, () => done(opts));\r\n    };\r\n\r\n    // 选择地址\r\n    exports.chooseAddress = function (opts, done) {\r\n        Func.isCheckAuthApiSetting('scope.address', () => done(opts));\r\n    };\r\n\r\n    // 获取位置信息\r\n    exports.getLocation = function (opts, done) {\r\n        Func.isCheckAuthApiSetting('scope.userLocation', () => done(opts));\r\n    };\r\n\r\n    // 保存到相册\r\n    exports.saveImageToPhotosAlbum = function (opts, done) {\r\n        Func.isCheckAuthApiSetting('scope.writePhotosAlbum', () => done(opts));\r\n    }\r\n\r\n    // ...more\r\n})(module.exports);\r\n复制代码\r\n更多的玩法\r\n可以看到我们无论后续扩展任何的微信api，都只需要在lib/api-extend.js 配置即可，这里不仅仅局限于授权，也可以做一些日志，传参的调整，例如：\r\n // 读取本地缓存(同步)\r\nexports.getStorageSync = (key, done) => {\r\n        let storage = null;\r\n        try {\r\n            storage = done(key);\r\n        } catch (e) {\r\n            wx.$logger.error('getStorageSync', {msg: e.type});\r\n        }\r\n        return storage;\r\n};\r\n复制代码这样是不是很方便呢，至于Func.isCheckAuthApiSetting这个方法具体实现，为了节省文章行数请自行去git仓库里查看吧\r\n\r\n关于音频授权\r\n录音授权略为特殊，以wx.getRecorderManager为例，它并不能直接调起录音授权，所以并不能直接用上述的这种方法，不过我们可以曲线救国，达到类似的效果，还记得我们对于wx.authorize的包装么，本质上我们是可以直接使用它来进行授权的，比如将它用在我们已经封装好的录音管理器的start方法进行校验\r\nwx.authorize({\r\n   scope: 'scope.record'\r\n});\r\n复制代码实际上，为方便统一管理，Func.isCheckAuthApiSetting方法其实都是使用wx.authorize来实现授权的\r\nexports.isCheckAuthApiSetting = async function(type, cb) {\r\n\r\n        // 简单的类型校验\r\n        if(!type && typeof type !== 'string') return;\r\n\r\n        // 声明\r\n        let err, result;\r\n\r\n        // 获取本地配置项\r\n        [err, result] = await to(getSetting());         // 这里可以做一层缓存，检查缓存的状态，如果已授权可以不必再次走下面的流程，直接return出去即可\r\n        if (err) {\r\n            return cb('fail');\t\t\t\t\t\t\t\t\t\t\t\t\t\r\n        }\r\n\r\n        // 当授权成功时，直接执行\r\n        if (result.authSetting[type]) {\r\n            return cb('success');\r\n        }\r\n\r\n        // 调用获取权限\r\n        [err, result] = await to(authorize({scope: type, $callee: 'isCheckAuthApiSetting'}));\r\n        if (!err) {\r\n            return cb('success');\r\n        }\r\n}\r\n复制代码\r\n关于用户授权\r\n用户授权极为特殊，因为微信将wx.getUserInfo升级了一版，没有办法直接唤起了，详见《公告》，所以需要单独处理，关于这里会拆出单独的一篇文章来写一些有趣的玩法\r\n\r\n\r\n\r\n总结\r\n最后稍微总结下，通过上述的方案，我们解决了最开始目标的同时，也为wx这个对象上的方法提供了统一的装饰接口（lib/api-extend文件），便于后续其他行为的操作比如埋点，日志，参数校验\r\n还是那么一句话吧，小程序不管和web开发有多少不同，本质上都是在js境上进行开发的，希望小程序的社区环境更加活跃，带来更多有趣的东西"}
{"title": "小程序页面通信、数据刷新、事件总线 、event bus 终极解决方案之 iny-bus ... ", "author": "Rolan", "put_time": "2019-8-6 00:48", "content": "背景介绍\r\n在各种小程序中，我们经常会遇到 这种情况\r\n有一个 列表，点击列表中的一项进入详情，详情有个按钮，删除了这一项，这个时候当用户返回到列表页时,\r\n发现列表中的这一项依然存在，这种情况，就是一个 `bug`，也就是数据不同步问题，这个时候测试小姐姐\r\n肯定会找你，让你解决，这个时候，你也许会很快速的解决，但过一会儿，测试小姐姐又来找你说，我打开了\r\n四五个页面更改了用户状态，但我一层一层返回到首页，发现有好几个页面数据没有刷新，也是一个 bug，\r\n这个时候你就犯愁了，怎么解决，常规方法有下面几种\r\n复制代码\r\n解决方法\r\n  1. 将所有请求放到 生命周期 `onShow` 中，只要我们页面重新显示，就会重新请求，数据也会刷新\r\n  2. 通过用 `getCurrentPages` 获取页面栈，然后找到对应的 页面实例，调用实例方法，去刷新数据\r\n  3. 通过设置一个全局变量，例如 App.globalData.xxx，通过改变这个变量的值，然后在对应 onShow \r\n  \t 中检查，如果值已改变，刷新数据\r\n  4. 在打开详情页时，使用 redirectTo 而不是 navigateTo，这样在打开新的页面时，会销毁当前页面，\r\n     返回时就不会回到这个里面，自然也不会有数据不同步问题\r\n复制代码\r\n存在的问题\r\n1. 假如我们将 所有 请求放到 onShow 生命周期中，自然能解决所有数据刷新问题，但是 onShow \r\n  这个生命周期，有两个问题\r\n  \r\n  第一个问题，它其实是在 onLoad 后面执行的，也就是说，假如请求耗时相同，从它发起请求到页面渲染，\r\n  会比 onLoad 慢\r\n  \r\n  第二个问题，那就是页面隐藏、调用微信分享、锁频等等都会触发执行，请求放置于 `onShow` 中就会造成\r\n  大量不需要的请求，造成服务器压力，多余的资源浪费、也会造成用户体验不好的问题\r\n\r\n2. 通过 `getCurrentPages` 获取页面栈，然后找到对应的 页面实例，调用实例方法，去刷新数据，这也\r\n不失为一个办法，但是就如微信官方文档所说\r\n\r\n  > 不要尝试修改页面栈，会导致路由以及页面状态错误。\r\n  > 不要在 App.onLaunch 的时候调用 `getCurrentPages()`，此时 page 还没有生成。\r\n\r\n  同时、当需要通信的页面有两个、三个、多个呢，这里去使用 `getCurrentPages` 就会比较困难、繁琐\r\n\r\n3. 通过设置全局变量的方法，当需要使用的地方比较少时，可以接受，当使用的地方多的时候，维护起来\r\n就会很困难，代码过于臃肿，也会有很多问题\r\n\r\n4. 使用 redirectTo 而不是 navigateTo，从用来体验来说，很糟糕，并且只存在一个页面，对于\r\ntab 页面，它也无能为力，不推荐使用\r\n复制代码\r\n最佳实践\r\n在 Vue 中， 可以通过 new Vue() 来实现一个 event bus作为事件总线，来达到事件通知的功能，在各大\r\n框架中，也有自身的事件机制实现，那么我们完全可以通过同样的方法，实现一个事件中心，来管理我们的事件，\r\n同时，解决我们的问题。iny-bus 就是这样一个及其轻量的事件库,使用 typescript 编写，100% 测试覆\r\n盖率，能运行 js 的环境，就能使用\r\n复制代码\r\n传送门\r\n源码\r\nNPM\r\n文档\r\n简单使用\r\niny-bus 使用及其简单，在需要的页面 onLoad 中添加事件监听， 在需要触发事件的地方派发事件，使监\r\n听该事件的每个页面执行处理函数，达到通信和刷新数据的目的，在小程序中的使用可以参考以下代码\r\n复制代码\r\n\r\n  // 小程序\r\n  import bus from 'iny-bus'\r\n\r\n  // 添加事件监听\r\n  // 在 onLoad 中注册, 避免在 onShow 中使用\r\n  onLoad () {\r\n    this.eventId = bus.on('事件名', (a, b, c, d) => {\r\n      // 支持多参数\r\n      console.log(a, b, c, d)\r\n\r\n      this.setData({\r\n        a,\r\n        b,\r\n        c\r\n      }\r\n      // 调用页面请求函数，刷新数据\r\n      this.refreshPageData()\r\n    })\r\n\r\n    // 添加只需要执行一次的 事件监听\r\n\r\n    this.eventIdOnce = bus.once('事件名', () => {\r\n      // do some thing\r\n    })\r\n  }\r\n\r\n  // 移除事件监听，该函数有两个参数，第二个事件id不传，会移除整个事件监听，传入ID，会移除该\r\n  页面的事件监听，避免多余资源浪费, 在添加事件监/// 听后，页面卸载(onUnload)时建议移除\r\n\r\n  onUnload () {\r\n    bus.remove('事件名', this.eventId)\r\n  }\r\n\r\n  // 派发事件，触发事件监听处更新视图\r\n  // 支持多参传递\r\n  onClick () {\r\n    bus.emit('事件名', a, b, c)\r\n  }\r\n\r\n复制代码更详细的使用和例子可以参考 Github iny-bus 小程序代码\r\niny-bus 具体实现\r\n\r\niny-bus 我们是使用 typescript 编写，同时要发布到 npm 上供大家使用，那我们就需要搭建开发环境，选择编辑打包工具，编写发布脚本，具体的细节这里不讲，只列举以下使用到的工具和库\r\n\r\n\r\n\r\n基本打包工具，这里使用非常优秀的开源库 typescript-library-starter，具体细节不展开\r\n\r\n\r\n测试工具 使用 facebook 的 jest\r\n\r\n\r\nbuild ci 使用 [travis-ci](www.travis-ci.org/）\r\n\r\n\r\n测试覆盖率上传使用 codecov\r\n\r\n\r\n具体的其他细节大家可以看源码中的 package.json，这里就一一展开讲了，我们来看具体实现\r\n\r\n\r\n\r\n具体实现\r\n\r\n\r\n首先，我们来设计我们的事件中心，iny-bus 作为事件中心，我们就需要一个容器来储存我们的事件，同时我们不希望，使用者可以直接访我们的容器，所以我们就需要私有化,例如这样\r\n\r\n\r\n\r\n\r\n  class EventBus {\r\n\r\n    private events: any[] = []\r\n\r\n  }\r\n\r\n复制代码\r\n然后，我们的事件中心希望拥有那些能力呢，比如说事件监听 on，监听了就需要派发 emit, 也就需要移除 remove,移除就需要查找，我们也需要一次性事件，比如说 once，大概是这样子\r\n\r\n\r\n  interface EventBus {\r\n\r\n    // 监听，我们需要知道一个事件名字，也需要一个 派发时的执行函数，同时，我们返回一个\r\n    // id 给使用者，方便使用者移除 事件监听\r\n    on(name: string, execute: Function): string\r\n\r\n    // once 和 on在使用创建和使用时，没什么区别，唯一的区别就在 执行一次后移除，所以在\r\n    // 创建时 和 on 没有任何区别\r\n    once(name: string, execute: Function): string\r\n\r\n    // remove, 前面提到了我们需要删除事件监听，那我们就需要 事件名称，为了多个页面可以监\r\n    // 听同一个事件，所以我们不能一次性把该事件监听全部移除\r\n    // 那么我们就用到 创建 事件时的 id 了, 同时，我们返回 我们的事件中心，可以链式调用\r\n    remove(name: string, eventId?: string): EventBus\r\n\r\n    // emit 我们需要告诉系统，我们需要派发的事件名和所携带的参数，同时返回 事件实例\r\n    emit(name: string, ...args: any[]): EventBus\r\n\r\n    // find 函数返回一个联合类型，有可能存在 该事件，也有可能返回 null\r\n    find(name: string): Event | null\r\n\r\n  }\r\n\r\n复制代码\r\n上面我们大概设计好我们的事件中心了，这个时候，我们需要明确，我们的每一个事件所拥有的能力和属性\r\n\r\n\r\n  // 每一个东西，都有一个名字，方便记忆和寻找，我们的事件\r\n  // 也需要一个 name，同时，我们的每一个事件，都有可能被监听 n 次，那么我们就需要\r\n  // 每个事件来有一个容器，存放每个事件的执行者\r\n\r\n  interface Event {\r\n\r\n    // 名称\r\n    name: string\r\n\r\n    // 执行者容器\r\n    executes: Execute[]\r\n  }\r\n\r\n  // 我们也需要确定每个执行者的类型，为了能精确的找到执行者，所以需要一个 id，这也是 用来\r\n  // 删除的id， 这里的 eventType 是来标示是否是一次性执行者， execute 则为每个执行者\r\n  // 的执行函数\r\n  interface Execute {\r\n    id: string\r\n    eventType: EventType\r\n    execute: Function\r\n  }\r\n\r\n复制代码\r\n在上面，我们提到了 eventType，这是为了标示是否为 一次性执行者，在 typescript 中，没有比 枚举 更适合这种情况了\r\n\r\n\r\n// 申明事件执行者的类型\r\n\r\ntype EventType = 1 | 2\r\n\r\n\r\nenum EventTypeEnum {\r\n  // 普通事件\r\n  NORMAL_EVENT = 1,\r\n  // 一次性事件\r\n  ONCE_EVENT = 2\r\n}\r\n\r\n复制代码\r\n基本的类型是定义完了，我们来写具体实现的代码，第一步，实现 on once 方法\r\n\r\n\r\n  \r\n  class EventBus {\r\n\r\n    /**\r\n    * 储存事件的容器\r\n    */\r\n    private events: Event[] = []\r\n\r\n    /**\r\n    * on 新增事件监听\r\n    * @param name 事件名\r\n    * @param execute 回调函数\r\n    * @returns { string } eventId 事件ID，用户取消该事件监听\r\n    */\r\n\r\n\r\n    on(name: string, execute: Function): string {\r\n      \r\n      // 因为 on 和 once 在新建上没什么区别，所以这里我们统一使用 addEvent, 但为了区分 on 和 once，我们传入了 EventType\r\n      return this.addEvent(name, EventTypeEnum.NORMAL_EVENT, execute)\r\n    }\r\n\r\n    /**\r\n    * one 只允许添加一次事件监听\r\n    * @param name 事件名\r\n    * @param execute 回调函数\r\n    * @returns { string } eventId 事件ID，用户取消该事件监听\r\n    */\r\n\r\n    once(name: string, execute: Function): string {\r\n      // 同理 on\r\n      return this.addEvent(name, EventTypeEnum.ONCE_EVENT, execute)\r\n    }\r\n\r\n  }\r\n\r\n\r\n复制代码\r\n实现 addEvent 方法\r\n\r\n\r\n  class EventBus {\r\n\r\n    /**\r\n     * 添加事件的方法\r\n    * @param name\r\n    * @param execute\r\n    */\r\n\r\n    private addEvent(name: string, eventType: EventType, execute: Function): string {\r\n      const eventId = createUid()\r\n\r\n      const events = this.events\r\n\r\n      const event = this.find(name)\r\n\r\n      if (event !== null) {\r\n        event.executes.push({ id: eventId, eventType, execute })\r\n\r\n        return eventId\r\n      }\r\n\r\n      events.push({\r\n        name,\r\n        executes: [\r\n          {\r\n            id: eventId,\r\n            eventType,\r\n            execute\r\n          }\r\n        ]\r\n      })\r\n\r\n      return eventId\r\n    }\r\n\r\n  }\r\n\r\n复制代码\r\n实现 find 方法\r\n\r\n\r\n  class EventBus {\r\n    /**\r\n     * 查找事件的方法\r\n    * @param name\r\n    */\r\n\r\n    find(name: string): Event | null {\r\n      const events = this.events\r\n\r\n      for (let i = 0; i < events.length; i++) {\r\n        if (name === events[i].name) {\r\n          return events[i]\r\n        }\r\n      }\r\n\r\n      return null\r\n    }\r\n  }\r\n\r\n复制代码\r\n实现 remove 方法\r\n\r\n\r\n  class EventBus {\r\n    /**\r\n     * remove 移除事件监听\r\n    * @param name 事件名\r\n    * @param eventId 移除单个事件监听需传入\r\n    * @returns { EventBus } EventBus EventBus 实例\r\n    */\r\n\r\n    remove(name: string, eventId: string): EventBus {\r\n      const events = this.events\r\n\r\n      for (let i = 0; i < events.length; i++) {\r\n        if (events[i].name === name) {\r\n          // 移除具体的操作函数\r\n          if (eventId && events[i].executes.length > 0) {\r\n            const eventIndex = events[i].executes.findIndex(item => item.id === eventId)\r\n\r\n            if (eventIndex !== -1) {\r\n              events[i].executes.splice(eventIndex, 1)\r\n            }\r\n          } else {\r\n            events.splice(i, 1)\r\n          }\r\n\r\n          return this\r\n        }\r\n      }\r\n\r\n      return this\r\n    }\r\n  }\r\n\r\n复制代码\r\n实现 emit 方法\r\n\r\n\r\n  class EventBus {\r\n    /**\r\n     * emit 派发事件\r\n    * @param name 事件名\r\n    * @param args 其余参数\r\n    * @returns { EventBus } EventBus EventBus 实例\r\n    */\r\n\r\n    emit(name: string, ...args: any[]): EventBus {\r\n      const events = this.events\r\n\r\n      for (let i = 0; i < events.length; i++) {\r\n        if (name === events[i].name) {\r\n          const funcs = events[i].executes\r\n\r\n          funcs.forEach((item, i) => {\r\n            item.execute(...args)\r\n\r\n            if (item.eventType === EventTypeEnum.ONCE_EVENT) {\r\n              funcs.splice(i, 1)\r\n            }\r\n          })\r\n\r\n          return this\r\n        }\r\n      }\r\n\r\n      return this\r\n    }\r\n  }\r\n\r\n复制代码\r\n作为一个事件中心，为了避免使用者错误使用，创建多个实例，我们可以使用 工厂模式，创建一个全局实例供使用者使用，同时提供使用者一个方法，创建新的实例\r\n\r\n\r\n  // 不直接 new EventBus， 而是通过 一个工厂函数来创建实例, 参考 axios 源码\r\n  function createInstance (): EventBusInstance {\r\n\r\n    const bus = new EventBus()\r\n\r\n    return bus as EventBusInstance\r\n  }\r\n\r\n  const bus = createInstance()\r\n\r\n  // 扩展 create 方法，用于 使用者 创建新的 bus 实例\r\n  bus.create = function create () {\r\n    return createInstance()\r\n  }\r\n复制代码总结\r\niny-bus 的核心代码，其实就这么多，总的来说，非常少，但是能解决我们在小程序中遇到的大量 通信 和 数据刷新问题，是采用 各大平台小程序 原生开发时，页面通信的不二之选，同时，100% 的测试覆盖率，确保了 iny-bus 在使用中的稳定性和安全性，当然，每个库都是从简单走向复杂，功能慢慢完善，如果\r\n大家在使用或者源码中发现了bug或者可以优化的点，欢迎大家提 pr 或者直接联系我\r\n最后，如果 iny-bus 给你提供了帮助或者让你有任何收获，请给 作者 点个赞，感谢大家 点赞"}
{"title": "小程序在线答题系统设计 ", "author": "Rolan", "put_time": "2019-8-6 00:58", "content": "前言帮一个可爱的小姐姐改一个uni-app构建的微信小程序时，在使用textarea组件时遇到的一点小问题。描述问题：在uni-app中,<textarea>的auto-hetght属性会出现高度不够，文字能够上下移动的问题,具体见下图:当输入的文字过多时,textarea内的文字可以上下滚动。 这不属于产品的需求，产品要的是输入框高度随着文字的变化而变化不能出现滚动条，而在uni-app打包的微信小程序中却出现了滚动解决思路排查原生微信小程序中是否有该问题 在微信小程序原生语法中尝试使用该组件：    <textarea placeholder=\"sxx是猪\" class=\"textarea\" auto-height=\"true\"></textarea>\r\nHTML.textarea{\r\n  margin-top: 80rpx;\r\n  width: 80vw;\r\n  border: 1rpx solid red;\r\n  min-height: 100rpx;\r\n  font-size: 20px\r\n}\r\nCSS发现在原生微信小程序语法中,使用auto-height属性，输入框高度会随着文字的增加而增加。在uni-app中新建项目，打包编译至微信小程序开发工具查看效果<textarea auto-height=\"true\" placeholder=\"sxx是猪\" class=\"textarea\"></textarea>\r\nHTML.textarea {\r\n        margin-top: 80upx;\r\n        width: 80vw;\r\n        border: 1rpx solid red;\r\n        min-height: 100upx;\r\n        font-size: 20px\r\n    }\r\nCSS跟在微信原生语法中写的一模一样，却产生了不同的效果。说明是uni-app编译的小程序会出现这个bug进一步排查，查看小程序工具中调试工具Wxml下的Dom以及style初始没有输入文本的时候，微信小程序的textarea有一个height:22.5px的行内样式而在uni-app(以下简称uni-app)编译的小程序下面，初始的高度只有17px输入一段相同的文本之后进行比较：sxx是猪sxx是猪sxx是猪sxx是猪sxx是猪sxx是猪sxx是猪sxx是猪sxx是猪sxx是猪sxx是猪微信小程序uni-app输入相同的内容，微信小程序高度为73px,uni-app高度也为73px,但是uni-app文本的字体高度却大于微信小程序的文本行高，所以会出现滚动尝试修改uni-app的行高.textarea {\r\n        margin-top: 80upx;\r\n        width: 80vw;\r\n        border: 1rpx solid red;\r\n        min-height: 100upx;\r\n        font-size: 20px;\r\n        line-height: 20px;\r\n    }\r\nCSS运行之后，解决问题！！原理观察得知，微信小程序中由于输入框中文字比较紧凑，uni-app中文字比较稀疏。故猜测可能是行高将文字的整体高度撑起，大于了输入框的可视区域。所uni-app中出现了滚动的效果。所以，修改uni-app的输入框中文本的行高即可解决该问题。关于文章首发于:uni-app textarea auto-hetght 文字出现上下滚动本文采用 CC BY-NC-SA 3.0 Unported 协议进行许可本文链接： https://www.ahwgs.cn/uni-app-textarea-auto-hetght.html"}
{"title": "微信小程序七夕节礼物 ", "author": "Rolan", "put_time": "2019-8-7 00:09", "content": "VSCode Node.js HbuilderX安装前端开发环境npm install -g cnpm --registry=https://registry.npm.taobao.orgcnpm install -g lessHBuilderX是国内最优秀的前端开发工具，我们用它来开发Electron项目和小程序项目{  \"pages\": [    \"pages/index/index\"  ],  \"requiredBackgroundModes\": [    \"audio\",    \"location\"  ],  \"subPackages\": [],  \"window\": {    \"navigationBarTextStyle\": \"black\",    \"navigationBarTitleText\": \"我喜欢你\",    \"navigationBarBackgroundColor\": \"#F8F8F8\",    \"backgroundColor\": \"#F8F8F8\"  },  \"usingComponents\": {}}@import './common/main.wxss';require('./common/runtime.js')require('./common/vendor.js')require('./common/main.js').content {  padding: 0 40rpx;}.content image {  width: 100%;}.content .title {  display: block;  text-align: center;  font-size: 50rpx;  font-weight: bold;}.content .operate {  text-align: center;  margin-top: 30rpx;  margin-bottom: 30rpx;}.content .operate .btn {  width: 200rpx;  height: 80rpx;  display: inline-block;}.content .operate .btn:first-of-type {  margin-right: 40rpx;}.content .message {  font-size: 34rpx;  margin: 15rpx 0;  color: #333;}<view class=\"content\"><image src=\"../../static/g1.gif\" mode=\"widthFix\"></image><text class=\"title\">小姐姐，做我女朋友吧！</text><view class=\"operate\"><button class=\"btn\" type=\"primary\" data-event-opts=\"{{[['tap',[['agree',['$event']]]]]}}\" bindtap=\"__e\">好呀</button><button class=\"btn\" type=\"warn\" data-event-opts=\"{{[['tap',[['disagree',['$event']]]]]}}\" bindtap=\"__e\">不好</button></view><block wx:for=\"{{love}}\" wx:for-item=\"one\" wx:for-index=\"__i0__\" wx:key=\"*this\"><view class=\"message\">{{one}}</view></block></view>若本号内容有做得不到位的地方（比如：涉及版权或其他问题），请及时联系我们进行整改即可，会在第一时间进行处理。"}
{"title": "微信小程序预加载图片以及占位图片 ", "author": "Rolan", "put_time": "2019-8-7 00:11", "content": "wxml页面利用三目运算：代码如下： 1 <image src=\"{{ima?ima:'../../images/4.jpg'}}\" /> （../../images/4.jpg）这里意思是预加载图片大概是一张黑白色的类似于js代码如下：Page({/*** 页面的初始数据*/data: {ima: \"\",},/*** 生命周期函数--监听页面加载*/internet:function(){  setTimeout(function(){    this.setData({  /*setData*/是为了模拟服务器传输的数据     ima:'http://pic4.nipic.com/20091217/3885730_124701000519_2.jpg',     })   }.bind(this),2000);},onLoad: function (options) {this.internet（）/*调用*/},// app.YoniClient.request(app.Func.LOGIN,)/*** 生命周期函数--监听页面初次渲染完成*/onReady: function () {},/*** 生命周期函数--监听页面显示*/onShow: function () {},/*** 生命周期函数--监听页面隐藏*/onHide: function () {},/*** 生命周期函数--监听页面卸载*/onUnload: function () {},/*** 页面相关事件处理函数--监听用户下拉动作*/onPullDownRefresh: function () {},/*** 页面上拉触底事件的处理函数*/onReachBottom: function () {},/*** 用户点击右上角分享*/onShareAppMessage: function () {}})那么如果是以数组形式的话也非常简单：wxml代码<image src='{{item.images?item.images:\"../../../images/sketch_169_102.jpg\"}}' class='news_list_img' mode='widthFix'></image>因为数组的话要用到参数item可能其他js代码如下：Page({  /**   * 页面的初始数据   */  data: {    items: [{      title: \"第一届少儿足球比赛\",      txt: \"第一届郑州足球比赛开幕式z乒启动计划\",      time: \"2017年11月20日\",      images: '',    }, {      title: \"第一届少儿足球比赛\",      txt: \"第一届郑州足球比赛开幕式z乒启动计划\",      time: \"2017年11月22日\",      images: '',    }],    ite: [{      title: \"第一届少儿足球比赛\",      txt: \"第一届郑州足球比赛开幕式z乒启动计划\",      time: \"2017年11月20日\",      images: \"http://img2.niutuku.com/desk/1208/1401/ntk-1401-8806.jpg\",    }, {      title: \"第一届少儿足球比赛\",      txt: \"第一届郑州足球比赛开幕式z乒启动计划\",      time: \"2017年11月22日\",      images: \"http://img2.niutuku.com/desk/1208/1401/ntk-1401-8806.jpg\",    }]  },/**   * 生命周期函数--监听页面加载   */  internet: function () {    let ite = this.data.ite;    setTimeout(function () {      this.setData({        items: ite,      })    }.bind(this), 2000);  },  onLoad: function (options) {this.internet()  },  /**   * 生命周期函数--监听页面初次渲染完成   */  onReady: function () {  },  /**   * 生命周期函数--监听页面显示   */  onShow: function () {  },  /**   * 生命周期函数--监听页面隐藏   */  onHide: function () {  },  /**   * 生命周期函数--监听页面卸载   */  onUnload: function () {  },  /**   * 页面相关事件处理函数--监听用户下拉动作   */  onPullDownRefresh: function () {  },  /**   * 页面上拉触底事件的处理函数   */  onReachBottom: function () {  },  /**   * 用户点击右上角分享   */  onShareAppMessage: function () {  }})setData是为了实例化数据目的为了能够放在页面将ite模拟数据赋值给定义的ite（名字随便定义）既然是数据就会有data，bind的目的是为了捆绑，后面的数字是时间间隔多少秒显示要加载出来的数据。"}
{"title": "微信小程序云端解决方案探索之路 ", "author": "Rolan", "put_time": "2019-8-7 00:58", "content": "小程序刚推出的时候，很多人都觉得它就是 H5，因为开发小程序的三大语言和 HTML、CSS、JS 是一脉相承的，即使改变了扩展名也改不了其实质。那么小程序的实质到底是不是 H5 呢？经过我们的论证分析，我们认为小程序并不是 H5 应用。主要原因如下：在小程序里面无法使用 DOM 接口，所以 HTML5 生态中一切基于 DOM 的库都无法使用（如 jQuery）小程序并非使用 URL 访问，所以没有域名的概念。这个特性有两个影响不存在跨域问题，所以访问控制是直接在微信 MP 上配置域名白名单不支持 Cookie 存储，这将导致后面我们重点研究了会话管理的实现从上面两个角度来考虑，我们认为小程序更偏向于传统的 CS 架构。那么，小程序和传统 CS 架构的区别在哪儿？主要包括下面两点：网络和续航小程序在移动端运行，网络环境会比较复杂，频繁的网络连接可能会过度消耗资源导致续航下降，所以小程序对网络和资源的优化都提出了要求。伸缩能力小程序寄托在微信平台上运行，作为一个十亿级的社交平台，业务可能会面临爆炸式的增长。如果在爆点小程序不能快速伸缩应对，那么将失去这样一个重要的机会。所以小程序对其后台架构的伸缩能力提出了比较高的要求。门槛和挑战在上面一些结论下，我们进行了一些尝试，包括上传下载、会话管理、WebSocket、视频点播等等。这次重点来分享会话管理和 WebSocket，因为我们面临的挑战主要集中在这两个案例上。会话管理我们最早开发了一个一笔到底的案例来实现会话管理，案例需要根据用户保存用户的作品，每次用户登录，都可以看到用户自己的绘画。但是，因为小程序不支持 Cookie 传输，所以会话服务需要自行实现。我们会话管理的实现目标是：完成微信要求的鉴权流程，生成用户会话利用会话确定每个请求对应哪个微信用户安全性和扩展性满足要求我们案例按照这个流程进行会话建立：其中在小程序和服务器我们分别提供 JS 和 Node SDK 来提供会话支持。这个案例完成了会话服务的功能性目标，可以提供会话建立和验证的能力。但是弊端在于，该能力只能被 Node 开发者使用，其他语言的开发者无法使用。同时，因为小程序的 appId 和 appSecret 存放在外网可以访问的服务器上，也有一定安全性问题。会话服务和我们的业务耦合在一起，也给后续的横向扩展带来了麻烦。于是，我们提出了改进的手段：会话管理服务器独立提供提供多语言的 SDKappId 和 appSecret 存放到数据库中其中多语言的 SDK 正式因为会话管理服务器的独立而可以快速开发到。优化后，会话的建立流程如下图所示：而会话的验证流程如下图所示：我们的会话服务改进取得的效果还是很明显的：流程和安全性上完全符合了微信的鉴权要求独立会话服务器，可以方便进行独立的升级和扩展，也为多语言 SDK 的开发打开了方便的大门信道服务我们面临的另外一个挑战就是 WebSocket。在进行案例分析之前，先跟大家分析一下微信支持 WebSocket 的原因。传统的 HTTPS 连接请求，每个请求都需要建立一次连接，耗费比较多的资源。同时微信有最大连接数的限制（5个），所以实时通信的需求不好做，长连接的方案也只能串行传输，这种方案耗电高体验差。当我们把目光转向 WebSocket 之后，会发现 WebSocket 通信全程只需要建立一次连接，就可以实现双向的实时通信，更省电的情况下获得更好的体验。这就是小程序支持 WebSocket 的一个重要原因，可以提高业务的体验并增加续航。鉴于很多同学可能对 WebSocket 还不了解，这里简单介绍一下。我们的 HTTP 连接是在 TCP 的基础上建立的，当服务器支持 WebSocket 的时候，可以相应一个头部，告知客户端进行协议升级。升级协议后，会复用之前的 TCP 连接，在上面实现 WebSocket 协议实现双向通信。更加详细的资料可以参考 MDN 上的说明。回到我们的案例上来，我们当时使用小程序提供的 WebSocket 做了一个实时的剪刀石头布游戏。我们使用 Socket.IO 实现其后端后，发现在小程序无法使用 Socket.IO 的客户端代码支持。我们只能自己去啃了一下 Socket.IO 的上层协议，实现了一个简版的客户端，从而实现剪刀石头布这个游戏逻辑。这个案例验证了在小程序上面 WebSocket 的可行性，但是由于客户端的实现是自行实现，和 Socket.IO 的后端配合可能会出现不可控的情况。同时，我们发现 WebSocket 的后端实现门槛比较高，并且进行横向扩展的话会更加困难。作为云服务厂商，我们首先想到的方案是使用 PaaS 提供服务来支持 WebSocket 连接。这是怎么一个思路呢？上图很好地解释了 PaaS 形式和传统 WebSocket 形式的不同之处，PaaS 实际上是要实现一个三方通信。我们看一下使用 PaaS 服务来建立 WebSocket 连接的过程：建立连接后，小程序和业务服务器之间可以通过下面的形式进行通信：经过 PaaS 的改造，我们得到了一个新的 WebSocket 方案。该方案的优劣在哪里？首先，优势比较明显，由平台来提供的服务，由平台自己完成扩展能力的支持以及稳定性和性能的保障，业务无需担心。同时，业务也无需关心 WebSocket 协议的实现，因为业务服务器和信道服务之前的通信都是传统的 HTTP，这样也可以节约业务服务器的长连接资源。但是这种方案也有它的局限之处。业务服务器和信道服务器之间采取公网通信，处于对信息安全的考虑，最好还是走 HTTPS 通信，这个过程的通信延迟比较客观。其次，三方通信的调试便利性也不如传统的连接方式。对于上面两个问题，其实我们也有对应方案。如果业务服务器在腾讯云机房运行，那么可以让业务服务器和信道服务器之间通过内网 HTTP 传输，延迟大大降低。信道服务后续也会提供调试日志供大家分析发现问题。总体来说，PaaS 方案会帮助更多开发者解决掉了门槛较高的部分。整合我们上面对于会话服务和信道服务都进行了一个有益的实践，那么这两个服务是否可以整合，信道服务里面是否可以支持会话识别？事实上我们可以做这个事情。下面的表格描述了会话服务和信道服务与服务模块之间的关系。我们可以把客户端的部分整合为客户端 SDK，把业务服务器的部分整合为服务器 SDK，并且提供会话服务器的源码开源。那么上面三个部分加起来，就是目前腾讯云的开源项目 - Wafer。Wafer 包含了会话服务和信道服务的支持，从全栈模块来提供开源的资源，并且提供了丰富的文档。有兴趣的开发者可以使用上面的连接来查看 Wafer 项目。产品化实践Wafer 帮开发者解决了小程序开发过程中信道服务和会话服务的门槛问题，但是作为小程序开发者，还要关心后台架构、资源采供、资源部署、扩展能力、安全性、域名申请等等与业务开发无关的部分。这部分，我们提出了一个一站式部署的方案。这个方案，会帮你分配好资源并自动部署下面的架构，让开发者可以专注于业务开发。自动部署的过程其实挺复杂的，有兴趣的同学可以参考下图了解。"}
{"title": "渗透测试之微信小程序破解 ", "author": "Rolan", "put_time": "2019-8-8 00:20", "content": "在移动互联的时代，手机端业务越来越多，最普遍的就是微信小程序。最近项目测试的时候发现现在的程序员的安全意识越来越好，很多业务都采用了签名来校验数据包，这样，如果不知道sign算法的话对于安全测试人员来说就无法修改数据，也就无法得知漏洞是否存在了。本次以一个微信小游戏为例，第一次尝试，发现后面水很深，要学的好多，先学习个简单的，走个流程先。微信小游戏：消灭病毒0x01 抓包打开游戏->抓包手机抓包就不再详细说了，如果抓不到数据包，网上搜下方法。按照常规操作，修改个数据，发现返回错误代码{\"code\":1000}\r\n还原原始数据，发现正常返回{\"data\":{},\"code\":0}\r\n后续试了下，发现不论哪个字段，只要数据包被篡改就返回错误。看到最后的sign字段，然后也没有session、cookie等身份校验的字段，基本上就是因为sign校验不通过导致的。所以，只要知道了sign算法，应该就可以直接篡改数据了0x02 获取wxapkg文件使用模拟器（ROOT）打开微信，搜索小程序。可能会有打不开、闪退的情况，但是不要紧，因为资源已经被下载下来了。之前不知道，一直没办法获取源码，后来网上搜到个神器，使用“ RE管理器” 可以读取到对应的文件目录。安装完之后，打开小程序，然后在“ RE管理器 ”里面打开目录： /data/data/com.tencent.mm/MicroMsg/这一大串随机字符串就是微信目录了，打开目录： /appbrand/pkg这里面就是我们安装的小程序的源码包0x03 反编译wxapkg获取源文件Github上已经有大神写的node.js版本的，当然也有其它版本的，例如python版本，不用管什么版本的，能用就行了。GitHub地址：https://github.com/qwerty472123/wxappUnpacker进入到下载好的反编译脚本目录下，在node命令窗口中依次安装需要的依赖。项目中列出来的需要安装的依赖不全，如果报错，看下issues就行了，下面是在我能运行状态下安装的依赖。/Users/w2n1ck/Desktop/wx/wxappUnpacker\r\n├─┬ css-tree@1.0.0-alpha.34\r\n│ ├── mdn-data@2.0.4\r\n│ └── source-map@0.5.7\r\n├── cssbeautify@0.3.1\r\n├── esprima@4.0.1\r\n├─┬ js-beautify@1.10.1\r\n│ ├─┬ config-chain@1.1.12\r\n│ │ ├── ini@1.3.5\r\n│ │ └── proto-list@1.2.4\r\n│ ├─┬ editorconfig@0.15.3\r\n│ │ ├── commander@2.20.0\r\n│ │ ├─┬ lru-cache@4.1.5\r\n│ │ │ ├── pseudomap@1.0.2\r\n│ │ │ └── yallist@2.1.2\r\n│ │ ├── semver@5.7.0\r\n│ │ └── sigmund@1.0.1\r\n│ ├─┬ glob@7.1.4\r\n│ │ ├── fs.realpath@1.0.0\r\n│ │ ├─┬ inflight@1.0.6\r\n│ │ │ └── wrappy@1.0.2\r\n│ │ ├── inherits@2.0.4\r\n│ │ ├─┬ minimatch@3.0.4\r\n│ │ │ └─┬ brace-expansion@1.1.11\r\n│ │ │   ├── balanced-match@1.0.0\r\n│ │ │   └── concat-map@0.0.1\r\n│ │ ├── once@1.4.0\r\n│ │ └── path-is-absolute@1.0.1\r\n│ ├─┬ mkdirp@0.5.1\r\n│ │ └── minimist@0.0.8\r\n│ └─┬ nopt@4.0.1\r\n│   ├── abbrev@1.1.1\r\n│   └─┬ osenv@0.1.5\r\n│     ├── os-homedir@1.0.2\r\n│     └── os-tmpdir@1.0.2\r\n├─┬ uglify-es@3.3.9\r\n│ ├── commander@2.13.0\r\n│ └── source-map@0.6.1\r\n├── vm2@3.8.2\r\n然后运行运行脚本node wuWxapkg.js <file>\r\n这样就成功获取到该小程序的源代码了0x04 源码分析因为开始我们已经知道上传的接口是： api/archive/upload一个文件中都有四5万行代码，一行一行分析的话，太浪费时间了（主要是我也看不懂，2333…）所以，我是根据特征直接在源码中搜的定位到具体位置可以看到数据包都经过了sign处理然后搜索关键字： sign可以看到 t 中包含的所有的字段属性和我们抓包时候的一样，基本上可以确认就是这个了。同时，在传输数据的时候，将 wx_appid 、 wx_secret 删除了搜索关键字： zn ，定位具体函数可以看到就是使用了md5进行了加密。0x05 脚本编写根据源码看到，sign是将post的所有字段和 wx_appid 、 wx_secret 一起进行了md5加密，这样，sign的算法已经知道了。但是，死活没有在源码中找到两个变量，网上搜索，发现新版本是动态加载的，然后我在“ 微信开发者工具” 中导入源码之后一直卡在85%，没办法运行，也就导致没办法动态调试获取到 wx_appid 、 wx_secret 的变量值了。随后网上搜了下这个游戏的破解文章，发现早期版本的代码中是直接硬编码这两个变量的，后面试了下，没想到还能用。这样就全部都有了，写个脚本，根据修改后的数据生成对应的sign即可。# -*- coding: utf-8 -*-\r\nimport hashlib\r\nimport json\r\nimport time\r\nimport requests\r\n\r\ndef get_sign(data):\r\n    if 'sign' in data:\r\n        data.pop('sign')\r\n    items = list(data.items())\r\n    items.append(('wx_appid', 'wxa2c324b63b2a9e5e'))\r\n    items.append(('wx_secret', '8fbd540d0b23197df1d5095f0d6ee46d'))\r\n    items.sort()\r\n    _data = \"\"\r\n    for key, value in items:\r\n        _data += (key + \"=\" + str(value) + \"&\")\r\n    _data = _data[:-1]\r\n    return hashlib.md5(_data.encode('utf-8')).hexdigest()\r\n\r\ndef request_action(action, **kws):\r\n    url = 'https://wxwyjh.chiji-h5.com/api/archive/{}'.format(action)\r\n    data = {\r\n        'plat': 'wx',\r\n        'time': int(time.time() * 1000),\r\n    }\r\n    data.update(kws)\r\n    data['sign'] = get_sign(data)\r\n    r = requests.post(url, json=data)\r\n    data = r.json()\r\n    if data['code'] == 0:\r\n        print('[ * ] {} OK.'.format(action))\r\n    return data\r\n\r\ndef get_record(openid):\r\n    r = request_action('get', openid=openid)\r\n    record = json.loads(r['data']['record'])\r\n    return record\r\n\r\nif __name__ == '__main__':\r\n    uid = 'xxxx'\r\n    record = get_record(uid)\r\n    record['money'] = '9999999999'\r\n    record['zuanShi'] = '9000'\r\n    openid = record['uid']\r\n    record['sign'] = get_sign(record)\r\n    record = json.dumps(record)\r\n    request_action('upload', openid=openid, record=record)\r\n    new_record = get_record(uid)\r\n    print(new_record)\r\n看下效果图：至此，我们就可以达到任意篡改数据的目的了。当然，看到那些排行榜的用户不爽的话，直接将他们的数据改到解放前（openid在源码中能找到），哈哈哈…PS：以上想法纯属意淫，请勿当真！！！谨以此文献给我那位“为了升级打怪天天看广告”的兄弟."}
{"title": "干货分享：小程序项目实践和经验总结 ", "author": "Rolan", "put_time": "2019-8-9 00:21", "content": "最近接触小程序开发，我特将本次开发过程中所使用到的相关知识点进行了总结，以作为经验的积累。希望给自己以后的开发，提供一些帮忙，同时提高解决问题的能力。如有错误，请大家指正。github地址；项目地址；weui：使用微信原生视觉体验样式库认识： WeUI 是一套同微信原生视觉体验一致的基础样式库，由微信官方设计团队为微信内网页和微信小程序量身设计，令用户的使用感知更加统一。官网： https://weui.io/github地址: https://github.com/weui/weui-wxss微信推出了一套官方样式库,方便大家开发,对于一些类似的UI界面我们需要引入即可,无需重复造轮子。我们只需导入weui.wxss等即可减少大量的css布局工作.关于本地图片资源路径（background）小程序只有image标签支持本地图片资源路径，wxss里的background-image不支持。如果想在css中使用背景图，解决方法：1、将本地图片用线上地址转化成base64路径。线上转化base64的地址：http://imgbase64.duoshitong.com/2、url里面的图片来源必须填写外链。如下：area{\r\n   background: url('https://mirror-gold-cdn.xitu.io/168e088859e325b9d85?imageView2/1/w/100/h/100/q/85/format/webp/interlace/1' ) no-repeat center;\r\n}websocket问题体验版支持ws协议，需要打开调试模式如果websocket是连接的域名非IP地址，则不能通过连接代理更改电脑的host来指定socket域名的解析地址如果有测试环境，建议：建一个专有的测试环境websocket域名直接使用测试环境的IP地址访问websocket关于时间格式在ios中处理方法背景： 由于ios只识别格式yyy/mm/dd格式，如\"2018-10-31 20:30:00\"格式无法识别；默认情况下数据库拿到的日期格式为“2018-08-30 12:00:00”，如果不替换“-”的话，在IOS下是不能通过getDate(datestring)获取到日期对象的。Android下两种格式均表现正常。解决方法： 通过正则替换掉所有的\"-\",如下：var dateStr = \"2018-09-08 12:30:30\"; // 后台返回的时间字符串\r\ndateStr = dateStr.replace(/-/g, '/');\r\nconsole.log(dateStr); \r\n结果为：2018/09/08 12:30:30小程序DOM上附属参数，函数中获取参数方法view.wxml: // DOM上附属参数\r\n<view \r\n  data-id='{{fangyuanItem.id}}' \r\n  data-houseitemid='{{fangyuanItem.houseItemId}}' \r\n  catchtap='viewMendianDetail'>\r\n</view>view.js:  // 函数中获取参数\r\n  page({\r\n      data:{},\r\n      viewMendianDetail: function (e) {\r\n        var roomtypeid = e.currentTarget.dataset.id;\r\n        var houseItemId = e.currentTarget.dataset.houseitemid;\r\n      }\r\n  })注意： 附属参数时，data-key,key格式为小写;小程序 navigator 无法跳转 tabBar上的页面方法一：navigator 的 open-type 设置为 switchTab代码如下：<navigator url=\"../cart/index\" open-type=\"switchTab\">\r\n   <text>首页</text>\r\n</navigator>方法二：wx.switchTab({})代码如下:index.wxml: <text catchtap=\"toIndex\">首页</text>index.js： page({\r\n    toIndex(){\r\n        wx.switchTab({  \r\n          url: '../cart/index'\r\n        }) \r\n    }\r\n })wx.navigateTo和wx.switchTab导航传参wx.navigateTo导航传参1.wx.navigateTo，url通过参数拼接传参；// 访问房型详情\r\nviewMendianDetail: function (e) {\r\n  var roomtypeid = e.currentTarget.dataset.id;\r\n  var houseItemId = e.currentTarget.dataset.houseitemid;\r\n  wx.navigateTo({\r\n    url: '/pages/index/index?houseItemId=' + houseItemId + '&roomtypeid=' + roomtypeid,\r\n  })\r\n}2.定位到的组件中通过生命周期函数onLoad接收参数对象，并设置本组件中的数据pages/index/index： onLoad: function (options) {\r\n    //console.log(options)\r\n    var houseItemId = options.houseItemId\r\n    var roomtypeid = options.roomtypeid\r\n    this.setData({\r\n        houseItemId: houseItemId,\r\n        roomTypeId: roomtypeid\r\n    })\r\n}wx.switchTab导航传参1.前提：app.js中有定义全局变量searchInfo，如下：App({\r\n    globalData: {\r\n        searchInfo:{\r\n          searchInput:\"\",\r\n          laiyuan:0\r\n        }\r\n  }\r\n});2.通过app.globalData定义全局参数，如下：a.wxml:const app = getApp()\r\npage({\r\n    data:{},\r\n    toZhaofang:function(e){\r\n        app.globalData.searchInfo = {\r\n          \"searchInput\": searchInput,\r\n          \"laiyuan\": 1\r\n        }\r\n        wx.switchTab({\r\n          url: '/pages/tabbar/zhaofang/index',\r\n        })\r\n   }\r\n})3.通过app.globalData来接收全局参数，如下：zhaofang/index.wxml: const app = getApp()\r\n page({\r\n    onLoad(){ \r\n       let searchInfo = app.globalData.searchInfo\r\n       let searchInput = searchInfo.searchInput;\r\n    }\r\n })自定义小程序转发功能默认情况下，我们需要点击小程序右上角的...才能看到转发，这样并不能对用户起到引导作用，通常的做法是使用一个button，并且设置open-type为share，这样就可以通过按钮启动分享。但是原生按钮很难看，我们可以设置一个图片，并且调整按钮的样式；效果如图：share.wxml:<button open-type=\"share\"><image src=\"/images/icon-share.png\"></image></button>share.wxss:button {\r\n    padding:0;\r\n    width:70rpx;\r\n    height:70rpx;\r\n    display:block;\r\n    border:0;\r\n    background: transparent;\r\n}\r\nbutton::after {\r\n    border:0; \r\n}注意： 尤其是对 button::after 要进行设置，否则按钮的边框是无法去掉的。通过 wx.getSystemInfo()来获取手机信息(包括宽，高)小程序提供的getSystemInfo()方法,该方法可以获取到设备的常用信息,如手机型号.设备像素比.屏幕宽高等等.最常用的就是屏幕宽高了.为了保证获取信息的准确性，wx.getSystemInfoSync是在页面初始化的时候就计算了。所以最好的方法是使用异步接口，并且在onReady函数中调用。info.js:Page({\r\n  onReady: function (options) {\r\n    this.getSystemInfo();\r\n  },\r\n  getSystemInfo:function(){\r\n    wx.getSystemInfo({\r\n      success: function (res) {\r\n         console.log(\"手机屏幕的宽度为：\" + res.screenWidth);\r\n         console.log(\"手机屏幕的高度为：\" + res.screenHeight);\r\n        console.log(\"可视网页的宽度为：\" + res.windowWidth);\r\n        console.log(\"可视网页的高度为：\" + res.windowHeight);\r\n        console.log(\"手机的系统为：\" + res.system);\r\n        console.log(\"微信版本号为：\" + res.version);\r\n      }\r\n    })\r\n  }\r\n})结果如图：模板（template）定义与传参定义： WXML提供模板（template），可以在模板中定义代码片段，然后在不同的地方调用。使用 name 属性，作为模板的名字。如：1.定义模板文件baseTemplate.wxml:<template name=\"msgItem\">\r\n  <view>\r\n    <text> {{index}}: {{msg}} </text>\r\n    <text> Time: {{time}} </text>\r\n  </view>\r\n</template>2.使用模板并通过data传递参数使用 is 属性，声明需要的使用的模板，然后将模板所需要的 data 传入。如下：user.wxml:<import src=\"../template/baseTemplate.wxml\" />\r\n <block wx:for=\"{{goodlist}}\" wx:key=\"idx\">\r\n    <template is=\"msgItem\" data=\"{{...item}}\"></template>\r\n</block>注意：1.通过data=\"{{...item}}\"的方式传递参数时，被调用的模板中，不需要再写item;2.如果要传多个数据到模板,用逗号分开,item 是对象,index是单个数据,要用键值对.<view class=\"tab-list\" wx:for=\"{{list}}\" wx:key=\"index\">\r\n   <template is=\"day-tab\" data=\"{{item,index:index,target:target}}\" wx:key=\"index\"></template>\r\n</view>user.js,数据定义格式如下：page({\r\n   data:{\r\n       goodlist:[\r\n           { index: 0,msg: 'this is a template',time: '2016-06-18'},\r\n           { index: 1,msg: 'this is a template1',time: '2017-06-18'},\r\n           { index: 2,msg: 'this is a template2',time: '2018-06-18'}\r\n       ]\r\n   }\r\n})城市选择组件picker使用效果如图：组件介绍：picker：从底部弹起的滚动选择器。代码如下：picker.wxml:<picker  \r\n    mode='selector' \r\n    range=\"{{region}}\" \r\n    range-key=\"{{'cityName'}}\" \r\n    value='{{indexCity}}'\r\n    bindchange=\"chooseCity\" \r\n    >\r\n    <view class=\"picker\">  \r\n        {{region[indexCity].cityName}}\r\n    </view>  \r\n</picker>picker.js:page({\r\n   data:{\r\n       region:[\r\n           {\"cityName\":\"北京市\",\"cityId\":\"12345\"},\r\n           {\"cityName\":\"上海市\",\"cityId\":\"67890\"},\r\n           {\"cityName\":\"武汉市\",\"cityId\":\"54321\"},\r\n       ]\r\n   },\r\n   chooseCity(e){\r\n     var value = e.detail.value;  // index下标\r\n   }\r\n})属性介绍：mode(string)：选择器类型；mode 的合法值：selector：普通选择器；multiSelector：多列选择器；time：时间选择器；date:日期选择器;region:省市区选择器滑动组件scroll-view介绍： scroll-view:可滚动视图区域。使用竖向滚动时，需要给scroll-view一个固定高度，通过 WXSS 设置 height。组件属性的长度单位默认为px，2.4.0起支持传入单位(rpx/px)。详细文档：请参考；效果如图：使用方法如下：<scroll-view scroll-x=\"true\"></scroll-view>注意：1.scroll-view的scroll-x失效的解决办法给scroll-view加上white-space: nowrap; 给scroll-view的子元素box加上display:inline-block即可。代码如下：.scroll-box {\r\n   white-space: nowrap;\r\n}\r\n.scroll-box .box{\r\n   display:inline-block\r\n}2.文本数据默认显示2行，超出部分用\"...\"代替：样式代码如下：line-height: 40rpx;\r\nwhite-space:pre-line;\r\ndisplay:-webkit-box;\r\n-webkit-box-orient:vertical;\r\n-webkit-line-clamp:2;\r\noverflow:hidden;视图容器cover-image和cover-view使用背景：在微信小程序经常会用到一些原生组件，比如map、video、canvas、camera，这些原生组件想让其他元素覆盖在其上，必须使用cover-view或者cover-image组件。cover-view介绍： 覆盖在原生组件之上的文本视图。可覆盖的原生组件包括 map、video、canvas、camera、live-player、live-pusher。只支持嵌套 cover-view、cover-image，可在 cover-view 中使用 button。组件属性的长度单位默认为px，2.4.0起支持传入单位(rpx/px)。注意： 只支持基本的定位、布局、文本样式。不支持设置单边的border、background-image、shadow、overflow: visible等。1、支持background-color，不支持background-image，如果你发现你的素材在真机出不来，而且你又设置了背景图片的话，那你可以把这些元素全部替换成cover-image。2、不支持overflow: visible也是有点坑，这样的话，你想超出依然显示，就需要设置一个同级元素并提升层级才能达到效果了。效果如图：示例代码如下：video.wxml:<video id=\"myVideo\" src=\"http://wxsnsdy.tc.qq.com/105/20210/snsdyvideodownload?filekey=30280201010421301f0201690402534804102ca905ce620b1241b726bc41dcff44e00204012882540400&bizid=1023&hy=SH&fileparam=302c020101042530230204136ffd93020457e3c4ff02024ef202031e8d7f02030f42400204045a320a0201000400\" controls=\"{{false}}\" event-model=\"bubble\">\r\n  <cover-view class=\"controls\">\r\n    <cover-view class=\"play\" bindtap=\"play\">\r\n      <cover-image class=\"img\" src=\"/path/to/icon_play\" />\r\n    </cover-view>\r\n    <cover-view class=\"pause\" bindtap=\"pause\">\r\n      <cover-image class=\"img\" src=\"/path/to/icon_pause\" />\r\n    </cover-view>\r\n    <cover-view class=\"time\">00:00</cover-view>\r\n  </cover-view>\r\n</video>video.wxss:.controls {\r\n  position: relative;\r\n  top: 50%;\r\n  height: 50px;\r\n  margin-top: -25px;\r\n  display: flex;\r\n}\r\n.play,.pause,.time {\r\n  flex: 1;\r\n  height: 100%;\r\n}\r\n.time {\r\n  text-align: center;\r\n  background-color: rgba(0, 0, 0, .5);\r\n  color: white;\r\n  line-height: 50px;\r\n}\r\n.img {\r\n  width: 40px;\r\n  height: 40px;\r\n  margin: 5px auto;\r\n}video.jsPage({\r\n  onReady() {\r\n    this.videoCtx = wx.createVideoContext('myVideo')\r\n  },\r\n  play() {\r\n    this.videoCtx.play()\r\n  },\r\n  pause() {\r\n    this.videoCtx.pause()\r\n  }\r\n})cover-image介绍： 覆盖在原生组件之上的图片视图，可覆盖的原生组件同cover-view，只支持嵌套在cover-view里。cover-image发现了两个问题：1、虽说和image组件基本一样，但是设置mode属性也就是图片裁剪、缩放的模式无效2、宽度固定，高度auto，时，按照正常效果应该是图片按比例伸缩展示，但是发现该组件高度一直为0，只能根据应用场景寻找其他替代方案了。视图容器swiper介绍： 滑块视图容器。其中只可放置swiper-item组件，否则会导致未定义的行为。效果如图：代码如下：swiper.wxml:<view class=\"area\">\r\n   <view class=\"fuTitle\">swiper</view>\r\n   <view class=\"intro\"> \r\n      <text class=\"one-title\">介绍：</text>\r\n      <text>滑块视图容器。其中只可放置swiper-item组件，否则会导致未定义的行为。</text>\r\n   </view>\r\n   <view class=\"item\">\r\n      <swiper \r\n        indicator-dots=\"{{indicatorDots}}\"\r\n        indicator-color=\"{{indicatorColor}}\"\r\n        indicator-active-color=\"{{indicatorActiveColor}}\"\r\n        previous-margin=\"{{previousMargin}}\"\r\n        next-margin=\"{{nextMargin}}\"\r\n        display-multiple-items=\"{{itemsNum}}\"\r\n        autoplay=\"{{autoplay}}\" \r\n        interval=\"{{interval}}\" \r\n        duration=\"{{duration}}\"\r\n        bindchange=\"bindchange\"\r\n        easing-function=\"{{easing}}\"\r\n        >\r\n        <block wx:for=\"{{imgUrls}}\" wx:key=\"{{index}}\">\r\n          <swiper-item item-id=\"{{index}}\">\r\n            <image src=\"{{item}}\" class=\"slide-image\" width=\"355\" height=\"150\"/>\r\n          </swiper-item>\r\n        </block>\r\n      </swiper>\r\n   </view>\r\n</view>swiper.jsPage({\r\n    data: {\r\n         imgUrls:[\r\n           \"../../images/bo1.jpg\",\r\n           \"../../images/bo2.jpg\",\r\n           \"../../images/bo3.jpg\",\r\n           \"../../images/bo4.jpg\"\r\n         ],\r\n         indicatorDots: true,    // 是否显示滚动圆点图标\r\n        indicatorColor: \"#07c160\", // 指示点颜色\r\n        indicatorActiveColor: \"#28d3ee\", // 当前选中的指示点颜色\r\n        previousMargin: \"10rpx\", // 前边距，可用于露出前一项的一小部分，接受 px 和 rpx 值\r\n        nextMargin: \"10rpx\",     // 后边距，可用于露出后一项的一小部分，接受 px 和 rpx 值\r\n        itemsNum:1,              // 同时显示的滑块数量\r\n        easing: \"default\",       // 指定 swiper 切换缓动动画类型\r\n        autoplay: true,         // 是否自动播放\r\n        interval: 5000,         // 自动切换时间间隔\r\n        duration: 1000          // 滑动的动画时长\r\n    }\r\n})rich-text实现富文本解析介绍： 富文本。主要用来解析服务端传递过来的富文本html格式的数据，进行展示在页面上。类似于vue的v-html指令；效果如图：代码如下：richText.wxml:<view class=\"rich-area\">\r\n      <rich-text nodes=\"{{article_content}}\" bindtap=\"tapRichText\"></rich-text>\r\n</view>richText.js:Page({\r\n   data: {\r\n     article_content: '<p>自我介绍1</p><p><img src=\"https://mirror-gold-cdn.xitu.io/168e088859e325b9d85?imageView2/1/w/100/h/100/q/85/format/webp/interlace/1\" width=\"100\" height=\"100\"/></p><p>自我介绍2</p><p><img src=\"https://mirror-gold-cdn.xitu.io/168e088859e325b9d85?imageView2/1/w/100/h/100/q/85/format/webp/interlace/1\" width=\"100\" height=\"100\"/></p><p>自我介绍3</p><p><img src=\"https://mirror-gold-cdn.xitu.io/168e088859e325b9d85?imageView2/1/w/100/h/100/q/85/format/webp/interlace/1\" width=\"100\" height=\"100\"/></p>',\r\n   }\r\n});小程序中运用高德地图绘制静态图功能背景在小程序的页面中，需要显示某个位置的具体地理坐标并做好标记；如果直接使用map组件，无法满足功能需求，同时会存在页面层级重叠的问题；所有就选择了高德地图微信小程序sdk,绘制静态图来呈现。效果如图：开发步骤1.获取高德Key点我获取Key>>点我查看申请高德Key的方法>>2.绘制静态图简介：由于微信内无法运行第三方地图，高德对广大开发者提供了静态地图功能，可快速生成一张地图图片，可以指定显示的地图区域、图片大小、以及在地图上添加覆盖物，如标签、标注、折线、多边形。 可用于快速生成一张个性化涂鸦的静态地图用于查看和分享。静态图上绘制点1、在页面的 js 文件中，实例化 AMapWX 对象，请求显示静态地图。首先，引入 amap-wx.js 文件（amap-wx.js 从相关下载页面下载的 zip 文件解压后得到）。xinxi.js:var amapFile = require('path/to/amap-wx.js');//如：..­/..­/libs/amap-wx.js然后，构造 AMapWX 对象，并调用 getStaticmap 方法。其中，注意： 把百度地图坐标转换成高德，腾讯地图坐标var zuobiaoArr = network.bMapTransQQMap(lng,lat)Page({\r\n  data: {\r\n    pointObj:{\r\n      lng:'您的坐标经度值',\r\n      lat:'您的坐标纬度值'\r\n    },\r\n    src: ''\r\n  },\r\n  onLoad: function() {\r\n    var that = this;\r\n    var myAmapFun = new amapFile.AMapWX({key:\"您的Key\"});\r\n    wx.getSystemInfo({\r\n      success: function(data){\r\n        var height = data.windowHeight;\r\n        var width = data.windowWidth;\r\n        var size = width + \"*\" + height;\r\n        myAmapFun.getStaticmap({\r\n          zoom: 8,\r\n          size: size,\r\n          scale: 2,\r\n          markers: \"mid,0xFF0000,A:\"+pointObj.lng+\",\"+pointObj.lat\",\r\n          success: function(data){\r\n            that.setData({\r\n              src: data.url\r\n            })\r\n          },\r\n          fail: function(info){\r\n            wx.showModal({title:info.errMsg})\r\n          }\r\n        })\r\n      }\r\n    })\r\n  }\r\n})注意：data.windowHeight，data.windowWidth获取的是整个窗口的高度和宽度，这里可以根据需求自己设定地图要显示的宽高。markers: \"mid,0xFF0000,A:\"+pointObj.lng+\";\"+pointObj.lat\",用于设置地图上要显示的标记坐标；如果要显示多个标记，格式为：markers: \"mid,0xFF0000,A:116.37359,39.92437;116.47359,39.92437\"; // 多个坐标点以\";\"分割;2、编写页面的 wxml 文件，搭建页面结构。xinxi.wxml:<view class=\"img_box\">\r\n  <img src=\"{{src}}\">\r\n</view>3、编写页面的 wxss 文件，设置页面样式。xinxi.wxss:.img_box{\r\n  position: absolute;\r\n  top: 0;\r\n  bottom: 0;\r\n  left: 0;\r\n  right: 0;\r\n}\r\n.img_box image{\r\n  width: 100%;\r\n  height: 100%;\r\n}\r\n……4.注意细节：如果你提供的 pointObj:{lng:'您的坐标经度值',lat:'您的坐标纬度值'}数据对象为百度地图的坐标值，我们需要将其转换为高德地图坐标值(它们的坐标计算方式不同)；转换方法如下：//百度地图坐标转为高德，腾讯地图坐标\r\nfunction bMapTransQQMap(lng, lat) {\r\n    let x_pi = 3.14159265358979324 * 3000.0 / 180.0;\r\n    let x = lng - 0.0065;\r\n    let y = lat - 0.006;\r\n    let z = Math.sqrt(x * x + y * y) - 0.00002 * Math.sin(y * x_pi);\r\n    let theta = Math.atan2(y, x) - 0.000003 * Math.cos(x * x_pi);\r\n    let lngs = z * Math.cos(theta);\r\n    let lats = z * Math.sin(theta);\r\n    return {\r\n        lng: lngs,\r\n        lat: lats\r\n    }\r\n}\r\nlet pointObj = bMapTransQQMap(lng,lat); // 转换之后的坐标值；结束："}
{"title": "小程序滚动条操作及导航组件实现 ", "author": "Rolan", "put_time": "2019-8-9 00:27", "content": "当页面比较长内容较多的时候，会使用导航栏，给用户提供方便跳转到页面某一模块的功能。由于导航栏需要监听页面的滚动事件，在小程序中，很容易出现性能问题，需要时刻注意滚动监听中 setData 的次数。本文将介绍页面滚动条操作相关的微信 API，并利用这些 API 实现一个通用的导航栏组件。导航组件效果如下图：滚动到页面目标位置的相关API实现滚动到页面目标位置的功能，需要“滚动操作”和”目标位置“。将页面滚动到目标位置（wx.pageScrollTo）将页面滚动到页面中的目标位置，可以使用 wx.pageScrollTo 这个微信提供的 API。该方法可以接收一个对象作为参数，对象中可以指定：滚动的目标位置 scrollTop，单位为 px；滚动动画的时长 duration，单位为 ms；选择器 selector，但支持的基础库版本是从2.7.3；其实，直接使用选择器可以方便地完成我们想要的效果，但遗憾的是，我们的小程序大约只有60%用户的基础库是2.7.3以上。如果只有这些用户享受到新功能，用户量稍微少了些，不过我们可以使用 scrollTop 直接指定目标位置。获取元素在页面中的位置（SelectorQuery）首先，需要创建节点查询对象 selectorQuery，创建方法如下：wx.createSelectorQuery()\t\t// 返回selectorQuery对象\r\n复制代码selectorQuery 对象可以利用选择器选择匹配的节点，使用 selectAll 方法：wx.createSelectorQuery().selectAll('.nav-target') // 返回 NodesRef复制代码NodesRef 可以使用 fields 方法获取到节点的信息，比如大小、dataset等，使用 boundingClientRect 可以获取节点的位置信息，如上边界坐标等，最后调用 exec 方法才能执行：wx.createSelectorQuery().selectAll('.nav-target').fields({\r\n    dataset: true,\t    // 指定返回节点 dataset 的信息\r\n    size: true,\t\t    // 指定返回节点大小信息\r\n}, rects => {\r\n    rects.forEach(rect => {\r\n        rect.dataset;\r\n        rect.width;\r\n        rect.height;\r\n    })\r\n}).boundingClientRect(rects => {\r\n    rects.forEach(rect => {\r\n\trect.dataset;\r\n        rect.top;\r\n  })\r\n}).exec()\t\t// 最后要加 exec 才能执行\r\n复制代码导航栏组件实现问题及解决思路导航栏组件的实现，大致需要如下准备工作：获取锚点的信息，组成导航栏按钮文案；获取锚点的位置信息，以便点击导航滚动到对应位置；此外，还需要两个特性：点击导航栏，让页面滚动到对应位置；当页面滚动时，导航栏对应锚点的按钮需要改变active状态；准备工作1：获取锚点信息我们可以约定，所有锚点都需要加上：class: nav-target；data-label：导航栏中显示的文本；data-key：作为锚点标识；所以，一个锚点元素可能会编写成如下形式：<view class=\"nav-target\" data-key=\"overview\" data-label=\"概览\">...</view>复制代码有了class，我们就可以利用前文提到的selectorQuery取到这些锚点，进而利用boundingClientRect方法取到锚点上的dataset，关键代码如下：wx.createSelectorQuery().selectAll('.nav-target').boundingClientRect(res => {\r\n\tthis.setData({\r\n  \tnavList: res.map(item => item.dataset).filter(Boolean)\r\n  })\r\n})\r\n复制代码取到了锚点信息后，存入navList，其中的label作为导航栏的按钮文案，而key则用于接下来存储锚点位置。准备工作2：获取锚点的位置信息锚点的位置信息，也可以通过boundingClientRect获取，取到位置信息后，存入一个Map中，我们命名为positionMap，结合上面获取锚点信息，_getAllAnchorInfoAndScroll方法代码如下：_getAllAnchorInfoAndScroll(selectorIdToScroll) {\r\n  wx.createSelectorQuery().selectAll('.nav-target').boundingClientRect(res => {\r\n    if (!res || res.length === 0) return\r\n\r\n    this.setData({\r\n      navList: res.map(item => item.dataset).filter(Boolean)\r\n    })\r\n    \r\n    // 为了减少setData传输数据量，我们将视图层不需要用到的position信息存在Page实例上\r\n    res.forEach(item => {\r\n      const { top, dataset: { key} } = item\r\n      if (top >= 0) {\r\n        this.positionMap[key] = Math.max(top - 55, 0)\t// 向上留55px的空间给导航栏\r\n      }\r\n    })\r\n\r\n    // 如果需要做滚动的操作，则在这里执行\r\n    if (selectorIdToScroll) {\r\n      wx.pageScrollTo({ scrollTop: this.positionMap[selectorIdToScroll] })\r\n    }\r\n  }).exec()\r\n}\r\n复制代码模块动态加载由于需要加导航的页面长度都比较长，我们通常会对非首屏的模块使用动态加载技术。而页面模块的动态加载意味着，导航组件获取锚点位置的时机不能简单地设置在组件的 ready 事件。很显然，获取锚点位置的时机应该设置在所有模块都加载完成的时候。我们可以在模块（组件）加载完成后，通知导航组件进行锚点信息的更新。关键代码大致如下：页面 page.wxml<!-- 导航组件 -->\r\n<nav id=\"nav\" />\r\n\r\n<!-- 页面模块组件 -->\r\n<page-module bindupdate=\"updateNavList\" />\r\n复制代码页面 page.jsPage({\r\n  updateNavList() {\r\n     this.getNavComponent().updateNavInfo()\r\n  },\r\n  getNavComponent() {\r\n    // 避免多次调用 selectComponent，将其结果存入变量 _navComponent\r\n    if (!this._navComponent) {\r\n      this._navComponent = this.selectComponent('#nav')\r\n    }\r\n    return this._navComponent\r\n  },\r\n})\r\n复制代码模块组件 pageModule.js// 模块组件中，加载完成时触发页面实例的 updateNavList 方法\r\nthis.triggerEvent('update')\r\n复制代码导航组件 nav.jsComponent({\r\n  methods: {\r\n    ...,\r\n    updateNavInfo() {\r\n      this._getAllAnchorInfoAndScroll()\r\n    }\r\n  }\r\n})\r\n复制代码如此一来，页面模块更新后，导航组件也会更新锚点信息和位置，保证导航组件的信息是最新的。最后需要注意如果有懒加载的图片，需要提前设定好高度，否则等图片加载完锚点信息就错乱了。当然，也可以在图片加载完成的方法中，调用更新导航信息的 updateNavList 方法，这部分与模块组件的加载触发思路一致本文就不赘述。特性1：点击导航按钮，页面滚动到对应位置有了前面两项准备工作，这个特性实现起来，就简单多了。导航栏的按钮有可能一行放不下，应该使用 scroll-view 标签支持滚动。wxml 代码如下：导航组件 nav.wxml<scroll-view scroll-x>\r\n  <view class=\"scroll-inner\" bindtap=\"bindClickNav\">\r\n    <view class=\"nav {{index === currentIndex ? 'nav--active' : ''}}\"\r\n          wx:for=\"{{navList}}\" wx:key=\"{{index}}\" data-key=\"{{item.key}}\" data-index=\"{{index}}\">{{item.label}}</view>\r\n  </view>\r\n</scroll-view>复制代码其中，currentIndex 记录当前选中的导航项；bindClickNav 则处理点击导航项的更新 currentIndex 和页面滚动逻辑。导航组件 nav.jsbindClickNav(e) {\r\n  const { index, key } = e.target.dataset\r\n  this.setData({ currentIndex: index })\r\n  if (this.data.positionMap[selectorId] === undefined) {\r\n    // 如果点击时，锚点位置还未取得，则需要先获取位置并传入key，在获取位置之后滚动\r\n    this._getAllAnchorInfoAndScroll(key)\r\n    return\r\n  }\r\n  wx.pageScrollTo({ scrollTop: this.positionMap[selectorId] })\r\n},\r\n复制代码特性2：导航栏按钮的状态支持随着页面滚动而改变页面滚动的监听函数是 onPageScroll，我们需要在其中判断页面滚动到哪个锚点。判断滚动到哪个锚点的具体逻辑是在导航组件中的 watchScroll 实现，页面实例中的 onPageScroll 则传递页面滚动位置给导航组件 watchScroll 方法。页面实例 page.jsPage({\r\n  onPageScroll({ scrollTop }) {\r\n    const navComponent = () => {\r\n      if (!this._navComponent) {\r\n        this._navComponent = this.selectComponent('#nav')\r\n      }\r\n      return this._navComponent\r\n    }\r\n    navComponent && navComponent.watchScroll(scrollTop)\r\n  }\r\n})\r\n复制代码在导航组件中，应该如何判断页面滚动的位置与锚点的关系呢？以下图为例，页面滚动超过了”模块1“与”模块2“的锚点，但未超过”模块3“的锚点，此时导航栏显示的”模块2“应该是 active 态：总结一下实现思路：按照从上到下的顺序遍历各个模块，并将各个模块的锚点位置与页面的 scrollTop 进行对比，找到最后一个小于 scrollTop 的锚点模块，该模块的状态即为 active。由于“最后一个小于”比较难找，我们可以转换成找“第一个大于”的模块，该模块的上一个模块即为 active 态的模块。关键代码如下：导航组件 nav.jsComponent({\t\r\n  ...,\r\n  methods: {\r\n\t  ...,\r\n    watchScroll(pageScrollTop) {\r\n\r\n      // 判断是否为空，即初始化尚未完成\r\n      if (isEmpty(this.positionMap)) {\r\n        return\r\n      }\r\n\r\n      // 当页面滚动时，停止更新navIndex\r\n      if (_navIndexLock) {\r\n        return\r\n      }\r\n\r\n      // 判断滚动的scrolltop，然后设置 currentIndex\r\n      const lastIndex = this.data.navList.length - 1\r\n      for (let idx = 0; idx <= lastIndex; idx++) {\r\n        const navItem = this.data.navList[idx]\r\n        const top = this.positionMap[navItem.key]\r\n        const indexToSet = idx === 0 ? idx : idx - 1\r\n\r\n        // 寻找“第一个大于scrollTop”的模块，其上一个模块即为 active 态的模块\r\n        if (top > pageScrollTop) {\r\n          this.data.currentIndex !== indexToSet && this.setData({ currentIndex: indexToSet })\r\n          break\r\n        }\r\n\r\n        // 到最后一个tab还没有break，说明已经滚动到了最后tab\r\n        if (idx === lastIndex) {\r\n          this.data.currentIndex !== lastIndex && this.setData({ currentIndex: lastIndex })\r\n        }\r\n      }\r\n    }\r\n\t}\r\n})\r\n复制代码总结本文介绍了微信小程序对页面滚动和元素操作的支持情况，利用这些特性实现了一个导航组件。这个导航组件支持动态加载的模块，并能够根据页面滚动的位置更新导航组件的 active 状态。组件中，主要是模块动态加载完成这个时机比较难捕捉到，这里利用加载完的事件触发导航更新，这种方式的优化方案还待思考讨论。如果大家有好的建议也欢迎留言讨论~参考资料官方文档：developers.weixin.qq.com/miniprogram…"}
{"title": "微信小程序动画：高度渐变，left渐变 ", "author": "Rolan", "put_time": "2019-8-9 00:32", "content": "今天在测试微信小程序动画的时候遇到了坑，需求是这样的点击时子元素从外部滑动回来，父元素的高度跟随子元素的高度改变。 　　实现子元素left为0并不复杂，但是改变父元素box的高度的时候却遇到了坑，因为是需要跟随子元素right的高度来改变父元素box的高度的，并且子元素right的高度不确定，我们需要先获取子元素的高度。　　在改变高度的时候出错了，高度未改变。在测试时发现12345678910var box = wx.createAnimation(option); // 创建动画var obj = wx.createSelectorQuery();obj.select('.anr').boundingClientRect(function (rect) {//获取子元素高度  box.height(rect.height).step();//改变父元素高度  console.log(1);}).exec();console.log(2);that.setData({  box: box.export()});　　先打印的竟然是2，原来是一个异步操作，这就可以理解为什么执行无效了。改成这样1234567obj.select('.anr').boundingClientRect(function (rect) {//获取子元素高度  var box = wx.createAnimation(option); // 创建动画  box.height(rect.height).step();//改变父元素高度  that.setData({    box: box.export()  });}).exec();　　想着应该没问题了，但是遇到了另外一个坑，父元素的高度一下子变成了预设的效果，并没有Animation的渐变效果。本身父元素的高度是由left这个子元素撑起来的，给父元素预设一个高度这个问题就解决了。渐变效果就实现了。 　　源码解析wxml123456<view class=\"box\" animation=\"{{box}}\">  <view class=\"anl\">left</view>  <view class=\"anr\" animation=\"{{anr}}\">right</view></view><button bindtap=\"add\" wx:if=\"{{down}}\">goDown</button><button bindtap=\"goback\" wx:else>goBack</button>　wxss12345678910111213141516171819202122232425/* pages/userinfo/index.wxss */.box{  position: relative;  height: 200rpx;  overflow: hidden;  text-align: center;  color: white;  font-size: 120rpx;}.anl{  height: 200rpx;  background-color: red;}.anr{  background-color: green;  height: 400rpx;  width: 100%;  position: absolute;  left: 100%;  top: 0;}.add{  background-color: yellow;  height: 100rpx;}　　js1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// pages/userinfo/index.jsPage({   /**   * 页面的初始数据   */  data: {    box: {},    anr: {},    down:true  },  add: function () {    this.setData({      down: false    });    var that = this;    let option = {      duration: 1000, // 动画执行时间      timingFunction: 'ease-in' // 动画执行效果    };    var anr = wx.createAnimation(option);// 创建动画    this.anr=anr;    anr.left(0).step();    that.setData({      anr: anr.export()    });    var obj = wx.createSelectorQuery();    obj.select('.anr').boundingClientRect(function (rect) {//获取子元素高度      var box = wx.createAnimation(option); // 创建动画      that.box=box;      box.height(rect.height).step();//改变父元素高度      that.setData({        box: box.export()      });    }).exec();  },  goback:function(){    this.setData({      down:true    });    this.box.height('200rpx').step();    this.setData({      box:this.box.export()    });    this.anr.left('750rpx').step();    this.setData({      anr:this.anr.export()    })  }})"}
{"title": "微信小程序客服消息功能 php ", "author": "Rolan", "put_time": "2019-8-12 00:21", "content": "项目说明：本项目是一个简单微信小程序客服消息类，实现客服消息相关功能。官方给的php示例有误，这里就不再吐槽了。本示例是采用开发者服务器，没有采用云调用的形式。官方文档：客服消息指南客服消息服务端适用场景客户消息流程图使用步骤1、开启客服消息https://mp.weixin.qq.com/wxam...登录-开发-开发设置-消息推送[]( https://raw.githubusercontent...点击“启动”[]( https://raw.githubusercontent...URL(服务器地址)：填开发者服务器对应的url，如 https://xxxxxx/demo.phpToken(令牌)：这个随便填，要求3-32位。EncodingAESKey(消息加密密钥)：这个点击“随机生成”即可。消息加密方式：可以根据自己需要选择，本例选择”兼容模式“。数据格式：json相对于xml来说，从压缩效率及传输效率更具优势，这里我们选json。注意：以上操作完后先不要提交，等配置好开发者服务端后再提交。2、配置开发者服务端检验signature的PHP示例代码：$signature = $_GET[\"signature\"];\r\n    $timestamp = $_GET[\"timestamp\"];\r\n    $nonce = $_GET[\"nonce\"];\r\n    $echostr=$_GET[\"echostr\"];\r\n\r\n    $token = TOKEN;//这里改成你第一步操作时填写的token\r\n    $tmpArr = array($token, $timestamp, $nonce);\r\n    sort($tmpArr, SORT_STRING);\r\n    $tmpStr = implode( $tmpArr );\r\n    $tmpStr = sha1( $tmpStr );\r\n\r\n    if ($tmpStr == $signature ) {\r\n        return $echostr;\r\n    } else {\r\n        return false;\r\n    }官方示例没有返回 $echostr ，这个检验开发者服务端是否成功的关键，必须返回。3、提交消息推送配置如果没有报错，证明配置成功。4、开发者服务端demo<?php\r\n\r\n\r\n\r\n//验证signature\r\n//$signature = $_GET[\"signature\"];\r\n//$timestamp = $_GET[\"timestamp\"];\r\n//$nonce = $_GET[\"nonce\"];\r\n//$echostr=$_GET[\"echostr\"];\r\n//\r\n//$token = TOKEN;//这里改成你第一步操作时填写的token\r\n//$tmpArr = array($token, $timestamp, $nonce);\r\n//sort($tmpArr, SORT_STRING);\r\n//$tmpStr = implode( $tmpArr );\r\n//$tmpStr = sha1( $tmpStr );\r\n//\r\n//if ($tmpStr == $signature ) {\r\n//    return $echostr;\r\n//} else {\r\n//    return false;\r\n//}\r\n\r\n\r\ninclude_once './Xcxmsg.php';\r\n$xcxmsg = new Xcxmsg();\r\n\r\n$postStr = file_get_contents('php://input');\r\nif (!$postStr)\r\n    return false;\r\n$postArr = json_decode($postStr, true);\r\nif (!isset($postArr['MsgType']) || !isset($postArr['FromUserName']))\r\n    return false;\r\n$data = [\"touser\" => $postArr['FromUserName']];\r\n\r\n$accessToken = $xcxmsg->getAccessToken();\r\n$url = \"https://api.weixin.qq.com/cgi-bin/message/custom/send?access_token=\" . $accessToken;\r\n\r\nswitch ($postArr['MsgType']) {\r\n    case \"text\":\r\n        //如用户发送的是文字信息，这里处理\r\n        //回复图文链接，也可以回复别的类型，根据需要\r\n        $data['msgtype'] = \"link\";\r\n        $data['link'] = [\r\n            \"title\" => \"hello\",\r\n            \"description\" => \"Is Really A Happy Day\",\r\n            \"url\" => \"LINK_URL\",//连接url\r\n            \"thumb_url\" =>\"THUMB_URL\" //图片url\r\n        ];\r\n        $json = json_encode($data, JSON_UNESCAPED_UNICODE);\r\n        $xcxmsg->curl($json, $url);\r\n        break;\r\n    case \"image\": //如用户发送图片消息，进入这里\r\n\r\n        //服务端回复 图片，也可以回复别的类型，根据需要\r\n        $data['msgtype'] = \"image\";\r\n        $data['image'] = ['media_id' => 'media_id值']; // 执行 $xcxmsg->upload($accessToken)返回的 media_id\r\n        $json = json_encode($data, JSON_UNESCAPED_UNICODE);\r\n        $xcxmsg->curl($json, $url);\r\n    case \"miniprogrampage\":\r\n        //如用户发送小程序卡片，进入这里\r\n        //这里服务端回复小卡片，也可以回复别的类型，根据需要\r\n        $data['msgtype'] = \"miniprogrampage\";\r\n        $data['miniprogrampage'] = [\r\n            \"title\" => \"title\",\r\n            \"pagepath\" => \"pages/index/index\",\r\n            \"thumb_media_id\" => \"media_id值\"];// 执行 $xcxmsg->upload($accessToken)返回的 media_id\r\n        $json = json_encode($data, JSON_UNESCAPED_UNICODE);\r\n        $xcxmsg->curl($json, $url);\r\n        break;\r\n    case \"event\":\r\n        //如用户进入会话事件\r\n        //这里可以回复文本\r\n        $data['msgtype'] = \"text\";\r\n        $data['text'] = [\r\n            \"content\" => \"Hello World\",\r\n            ];\r\n        $json = json_encode($data, JSON_UNESCAPED_UNICODE);\r\n        $xcxmsg->curl($json, $url);\r\n        break;\r\n    default:\r\n}5、小程序前端在需要的地方添加以下代码：<button open-type=\"contact\" >客服消息</button>用微信开发工具的预览，生成二维码，扫描测试是否成功。项目地址： https://github.com/guyan0319/...在使用中如有任何问题，请回复指正，谢谢！"}
{"title": "撸一个微信小程序记事本备忘录-随微记 ", "author": "Rolan", "put_time": "2019-8-12 00:37", "content": "废话不多说了，目的直接点微信上记录一些资料(比如公司信息以及开发票等)，方便查看可以随时分享出来，可以生成图片海报做一些工具（后续开放）最后总结就是弄它， 随微记 是自己想的，页面也是自己布局，海报的配置可能也有自己的喜好存在目前版本为 V1.0.0 ，在此篇文章不会有代码的东西认知(需要改善)：没有各种的app好用没有手机自带备忘录的好用微信小程序技术微信小程序原生apiTaroColorUi组件库功能列表还有未完成的功能后续更新界面介绍遇到问题editor\r\n云开发云开发数据主要的存储是用户的列表以及用户笔记本和笔记的数据本来想用存图片，第一版本的时候遇到了图片size限制的问题，因此近期改版为上传至阿里OssNode + koa + mysql 服务 koa-swagger-decorator自动生成api文档 文字笔记海报配置 图文笔记海报配置 分享海报配置 用户同步数据 模板使用情况记录 分享日志记录 https域名部署 node项目部署pm2进程监控 图片删除任务更新 后台session登录 mysql使用 后台未完成功能有点多，在此不列了\"dependencies\": {\r\n    \"@babel/polyfill\": \"^7.4.4\",\r\n    \"axios\": \"^0.19.0\",\r\n    \"debug\": \"^4.1.1\",\r\n    \"koa\": \"^2.7.0\",\r\n    \"koa-bodyparser\": \"^4.2.1\",\r\n    \"koa-convert\": \"^1.2.0\",\r\n    \"koa-generic-session\": \"^2.0.1\",\r\n    \"koa-json\": \"^2.0.2\",\r\n    \"koa-logger\": \"^3.2.0\",\r\n    \"koa-onerror\": \"^4.1.0\",\r\n    \"koa-redis\": \"^4.0.0\",\r\n    \"koa-router\": \"^7.4.0\",\r\n    \"koa-static\": \"^5.0.0\",\r\n    \"koa-swagger-decorator\": \"^1.5.16\",\r\n    \"koa-views\": \"^6.2.0\",\r\n    \"moment\": \"^2.24.0\",\r\n    \"mysql\": \"^2.17.1\",\r\n    \"pug\": \"^2.0.3\"\r\n  },\r\n  \"devDependencies\": {\r\n    \"@babel/cli\": \"^7.5.5\",\r\n    \"@babel/core\": \"^7.5.5\",\r\n    \"@babel/parser\": \"^7.5.5\",\r\n    \"@babel/plugin-proposal-class-properties\": \"^7.5.5\",\r\n    \"@babel/plugin-proposal-decorators\": \"^7.4.4\",\r\n    \"@babel/plugin-proposal-optional-chaining\": \"^7.2.0\",\r\n    \"@babel/plugin-transform-object-assign\": \"^7.2.0\",\r\n    \"@babel/plugin-transform-runtime\": \"^7.5.5\",\r\n    \"@babel/preset-env\": \"^7.5.5\",\r\n    \"@babel/register\": \"^7.5.5\",\r\n    \"cross-env\": \"^5.2.0\",\r\n    \"install\": \"^0.13.0\",\r\n    \"nodemon\": \"^1.19.1\",\r\n    \"npm\": \"^6.10.2\"\r\n  }\r\n复制代码路由配置const tag = tags(['WeChat']);\r\n@prefix('/api/user')\r\nexport default class WechatRouter {\r\n\t@request('post', '/authorize')\r\n  @summary('微信授权登录')\r\n  @description('登录之后返回sesscion和openid')\r\n  @tag\r\n\t@body({\r\n\t\tcode: { type: 'string', required: true, default: '', description: '小程序code' },\r\n\t})\r\n\tstatic async authorize(ctx) {\r\n\t\tlet { code } = ctx.request.body;\r\n    let str = ctx.request.body?.code;\r\n    // console.log('开始访问请求参数2', APPID, APPSECRET, str)\r\n    let res = await getOpenId(code);\r\n    ctx.body = new SuccessModal(res);\r\n\t}\r\n}\r\n复制代码资源链接koa-generatorkoakoa-swagger-decorator后续开发后续后开发围绕微信和备忘录的一系列的工具或者功能，欢迎指出不足和功能改善，或者你想要的功能"}
{"title": "小程序中图片/等款高圆变形问题解决(安卓端) ", "author": "Rolan", "put_time": "2019-8-12 00:39", "content": "在项目中遇到 zfb小程序 在安卓端变形问题， 等款高圆、icon会有此问题\r\n\r\n问题\r\n话不多说贴代码\r\n<view class=\"circle\"></view>\r\n复制代码原样式\r\n.circle {\r\n  width: 24rpx;\r\n  height: 24rpx;\r\n  border-radius: 12rpx;\r\n  background-size: 24rpx 24rpx;\r\n  background-color: green;\r\n}\r\n复制代码\r\n解决\r\n\r\n将background-color换成background-image 然后外部盒子变大, 可解决\r\n\r\n.circle {\r\n  width: 26rpx;\r\n  height: 26rpx;\r\n  border-radius: 12rpx;\r\n  background-size: 24rpx 24rpx;\r\n  background-repeat: no-repeat;\r\n  background-image: url('/imgs/icon/up.png');\r\n  background-position:  center;\r\n}\r\n复制代码\r\n官方回复\r\n\r\n\r\n最后\r\n原创文章，文笔有限，有更好的方式方法欢迎大家评论区留言讨论"}
{"title": "也许你并不需要第三方小程序框架 ", "author": "Rolan", "put_time": "2019-8-13 00:10", "content": "这里说的去除小程序框架其实并不严谨，因为小程序本身也算是一个框架，而且是一个功能更加完善的框架系统。在前端的概念中，我们一般说一个框架是指一个用来帮助开发者构建用户界面的框架，而小程序框架本身不仅仅包含了 UI 层的功能，还提供了 API 能力、服务端的能力，所以说小程序框架本身是一个比常规的前端框架更完善的东西，或者说是一个完善的构建应用系统。在小程序的世界里，原生小程序框架已经足够好，它就是那把给你雕刻小而美应用的雕刻刀，而不必要去寻找一把屠龙刀。框架的取舍最近 Vue 作者尤大关于\t框架设计平衡 的分享中也提到了框架的取舍问题。当我们去构建一个复杂的前端应用的时候，如果没有工具，而是使用原生 JavaScript 去开发的话，那只会花费更多的时间。然而 web 应用的开发环境是否也适用于小程序开发呢？小程序框架在小程序生态发展的初期的确起到了很大的促进作用，然而随着小程序原生框架的不断完善，这些小程序框架的作用已经不再具备优势。框架的确给前端带来了生产力的提高，也带动了前端界生态的发展。所以在小程序出现之后，一股框架之风也很快的出现，微信小程序刚推出之后，就出现了两个比较出名的小程序开发框架，wepy、mpvue。这两个框架都带着一个共同的出发点，那就是将前端框架的开发体验移植到小程序开发中，从语法层做了改动，使用用户可以采用类似 Vue.js 风格的语法去开发微信小程序。这些小程序框架初期主要做的是对小程序原生开发体验的增强，随着小程序生态的发展，又增加了跨端开发能力的支持。然而我们框架的引入真的增强了开发体验吗？我们是否真的需要跨端能力？是否需要通过引入框架的形式来实现跨端支持？答案是否定的，引入框架对于小程序开发来说只会带来更多的问题。原生小程序 VS Web 框架如下是原生小程序与 Web 框架功能的对比情况，可以看到 Web 框架具备的能力，原生小程序也具备。小程序出现的时候 Web 框架已经发展的比较成熟，所以可以简单猜测小程序的框架借鉴了许多 Web 框架的特性，这也是为什么小程序开发方式与前端开发方式如此接近的原因。功能对比模块Vue.jsReact.js原生小程序数据监听支持支持支持组件式开发支持支持支持组件库开源组件库丰富开发组件库丰富原生小程序组件支持数据状态管理vuexreduxglobalData 可实现基本的数据管理路由vue-routerreact-router原生支持模块开发npmnpmnpm（有轻微的约束限制）在开发前端应用的时候，Vue 和 React 技术栈是比较流行的两种类型，而对于选择什么样的生态工具时，许多开发者并不确定选择什么样的技术栈，所以一般都会选择 Vue 全家桶和 React 全家桶。原生小程序框架从能力上就考虑了小程序场景所需的技术栈，这也是笔者推崇原生小程序开发方式的原因，如果你对你当前构建的应用场景需要什么样的技术栈特别清晰，那么就用原生的好了，因为原生小程序框架就是基于小程序场景开发的。选择什么样的技术栈，提供什么样的框架能力，这应该是小程序平台团队去思考的问题。原生小程序的优势从上面的功能层级对比我们可以发现，原生小程序与框架相比，功能是非常接近的，简单来说就是同一个物种，只不过是花猫、白猫的区别。那么除此之外，原生小程序还有哪些优势呢？稳定安全可靠原生小程序由专业的小程序团队维护更新，这是社区开源项目无法比拟的。即使是热门的开源项目也难保不会出现停滞更新维护的情况，也许有一天你就发现代码中的坑只得你自己的修复。原生小程序还处于快速发展的阶段，每过一段时间就会发布新功能，如果使用原生小程序开发的话就可以及时的享用，而如果依赖于三方框架的话，只得依赖于框架作者更新之后才能使用。作为一个开发人员，有时候选择一个什么样的框架是很难的，如果你想正确的选择框架，就得必须要了解框架所做的一些内部权衡，你必须知道这个框架朝着哪个方向发展，并且知道它与你构建的东西是否一致。而对于小程序来说，上述的问题其实不存在，小程序框架就是小程序平台团队为你量身打造的。想了解更多小程序框架可以查看如下三个框架：WePY 让小程序支持组件化开发的框架 WePY 框架在开发过程中参考了 Vue 等现有框架的一些语法风格和功能特性，对原生小程序的开发模式进行了再次封装，更贴近于 MVVM 架构模式, 并支持ES6/7的一些新特性。mpvue 是一个使用 Vue.js 开发小程序的前端框架，目前支持 微信小程序、百度智能小程序，头条小程序 和 支付宝小程序。 框架基于 Vue.js，修改了的运行时框架 runtime 和代码编译器 compiler 实现，使其可运行在小程序环境中，从而为小程序开发引入了 Vue.js 开发体验。Taro 是一套遵循 React 语法规范的 多端开发 解决方案。使用 Taro，我们可以只书写一套代码，再通过 Taro 的编译工具，将源代码分别编译出可以在不同端（微信/百度/支付宝/字节跳动/QQ小程序、快应用、H5、React-Native 等）运行的代码。小程序跨端需求继微信小程序推出后，阿里，百度，头条也推出了自己的小程序平台，这就给小程序开发者带来一个问题，是每个平台开发一套还是寻求代码复用的技术方案。其实跨端方案很多，现有的小程序框架大多都内置了跨端能力支持，对于跨端支持能力要求并不是特别高的团队，也可以搭建自己的跨端方案，因为这些小程序框架都很类似，所以说搭建一套针对特定场景的跨端方案也变得可行。Antmove - 编译型小程序跨端解决方案Antmove 是一个致力于提供通用型小程序跨端的解决方案，通过代码编译的手段和 runtime 的处理，实现小程序跨平台的目的，Antmove 与其它小程序开发框架的区别就是，它尽可能的通过代码编译的方式来解决多端差异问题（一个平台的代码转换到另一个平台），编译方式难以处理的才会进行运行时的抹平，而这部分只有简单的数据转换处理，不会引入特定的编码约束。以微信小程序转支付宝小程序为例，微信小程序和支付宝小程序底层设计不同，导致双方组件机制不一样，微信小程序组件间的通信是基于事件的，而支付宝小程序是基于\tprops 的。在将使用了微信小程序事件能力的小程序应用转换为支付宝小程序应用的过程中，Antmove 不会去构造一套事件机制，它尽可能的避免任何不必要的运行时开销，而是利用支付宝小程序的 props 机制去实现同样的功能。"}
{"title": "微信小程序——音频播放器 ", "author": "Rolan", "put_time": "2019-8-13 00:32", "content": "先来个效果图韵下味： 需求：音频的播放，暂停，中间按钮状态的变化，播放时实时更新播放进度；前进15s，后退15s；进度条拖动。 一开始想着这3个功能应该挺简单的。不就是播放，暂停，前进，后退么~呵~写的时候发现自己还是太年轻。当然，这跟自己的技术功底有关系。现在把我遇到的难点及要注意的点说一下~需要设置一个名为seekPosition的全局变量，初始值为0。我们要在播放的时候实时记录播放的位置，存到该变量里，这是方便在前进15s 或 后退15s 时计算时间点。前进15s时要判断剩余时间是否>15s，如果<15s，则返回到开始位置；后退15s时要判断播放时间是否>15s，如果<15s，则返回到开始位置；点击播放时，要先判断seekPisition是否>0，如果>0，则跳转到seekPosition的位置，并播放；拖动时，要先让音频停止播放，拖动结束后，再播放音频。并且要计算拖动位置对应的时间。 完整代码：wxml:<view class=\" audio-content\">\r\n\r\n  <image src=\"{{logo640x360}}\" class=\"bg-blur\"></image>\r\n  <view class=\"bg-gray\"></view>\r\n  <view class=\"container-cover\">\r\n    <view class=\"cover\">\r\n      <image src=\"{{logo640x360}}\" class=\"cover-image\"></image>\r\n      <view class=\"cover-tip\">词不达意.mp3</view>\r\n\r\n    </view>\r\n  </view>\r\n  <view class=\"audio-inner row item-center\">\r\n    <view class=\"audio-desc\">{{currentProcess}}</view>\r\n    <view class=\"audio-progress-wrap\">\r\n      <van-slider value=\"{{sliderValue}}\" step=\"{{sliderStep}}\" active-color=\"#09bb07\" use-button-slot bind:change=\"onSliderChange\" bind:drag=\"onSliderDrag\">\r\n        <view class=\"slider-button\" slot=\"button\"></view>\r\n      </van-slider>\r\n    </view>\r\n    <view class=\"audio-desc\">{{productDetail.duration}}</view>\r\n  </view>\r\n\r\n  <!-- 播放器控制条 -->\r\n  <section class=\"speech-player js_control_bar\">\r\n    <view class=\"player-bar row  justify-center item-center\">\r\n      <view class=\"backward js_audio_backward\" title=\"后退15s\">\r\n        <ss-icon name=\"back-15\" size=\"32px\" color=\"#fff\" block=\"{{true}}\" bind:click=\"backward\" />\r\n      </view>\r\n      <view class=\"play\" title=\"播放/暂停\">\r\n        <view class=\"circle-loading\" wx:if=\"{{loading}}\"></view>\r\n        <ss-icon name=\"play-outline\" size=\"50px\" color=\"#fff\" block=\"{{true}}\" wx:if=\"{{pause}}\" bind:click=\"audioPlay\" />\r\n        <ss-icon name=\"pause-outline\" size=\"50px\" color=\"#fff\" block=\"{{true}}\" wx:if=\"{{playing}}\" bind:click=\"audioPause\" />\r\n      </view>\r\n      <view class=\"forward js_audio_forward\" title=\"前进15s\">\r\n        <ss-icon name=\"forward-15\" size=\"32px\" color=\"#fff\" block=\"{{true}}\" bind:click=\"forward\" />\r\n      </view>\r\n    </view>\r\n  </section>\r\n</view>如果你要用的话把上面的 <ss-icon> 换成<van-icon>，并且需要自己找阿里矢量图标库查找对应的图标。 js:// components/product/audio/index.js\r\n\r\nlet audioUrl = \"\",\r\n  seekPosition = 0;\r\nconst audioContext = wx.createInnerAudioContext();\r\n\r\nComponent({\r\n  options: {\r\n    multipleSlots: true,\r\n    addGlobalClass: true\r\n  },\r\n\r\n\r\n  /**\r\n   * 组件的属性列表\r\n   */\r\n  properties: {\r\n    productId: Number,\r\n  },\r\n  /**\r\n   * 组件的初始数据\r\n   */\r\n  data: {\r\n    pause: true,\r\n    playing: false,\r\n    loading: false,\r\n    productDetail: {},\r\n    audioDuration: 0,\r\n    currentProcess: '00:00',\r\n    sliderStep:1\r\n  },\r\n\r\n  /**\r\n   * 组件的方法列表\r\n   */\r\n  methods: {\r\n    //音频播放\r\n    audioPlay(e) {\r\n      const _this = this;\r\n      let audioDuration = _this.data.audioDuration;\r\n      if (audioUrl) {\r\n        if (seekPosition) {\r\n          //如果有指定位置，则跳转到指定位置\r\n          audioContext.seek(seekPosition);\r\n        }\r\n        audioContext.play();\r\n        _this.setData({\r\n          pause: false,\r\n          playing: true,\r\n          loading: false,\r\n        })\r\n      } else {\r\n       //getJSON是我自己封装的\r\n        ss.getJSON('获取音频如果需要发送请求，这里面放请求地址', {\r\n          放你自己的参数\r\n        }, res => {\r\n          audioUrl = res.t;\r\n          audioContext.src = audioUrl;\r\n          if (seekPosition) {\r\n            audioContext.seek(seekPosition);\r\n          }\r\n          audioContext.play();\r\n          audioContext.onPlay(() => {\r\n            console.log('onPlay')\r\n          })\r\n\r\n          audioContext.onWaiting(() => {\r\n            console.log('onWaiting')\r\n            _this.setData({\r\n              pause: false,\r\n              playing: false,\r\n              loading: true,\r\n            })\r\n          })\r\n\r\n          audioContext.onCanplay(() => {\r\n            console.log('onCanplay')\r\n            _this.setData({\r\n              pause: false,\r\n              playing: true,\r\n              loading: false\r\n            })\r\n            setTimeout(() => {\r\n              audioContext.duration\r\n            }, 500)\r\n\r\n            _this.audioStatus();\r\n          })\r\n\r\n          audioContext.onError((res) => {\r\n            console.log(res.errMsg)\r\n          })\r\n        })\r\n      }\r\n\r\n    },\r\n\r\n\r\n    //播放暂停\r\n    audioPause: function() {\r\n      const _this = this;\r\n      audioContext.pause();\r\n      _this.setData({\r\n        pause: true,\r\n        playing: false,\r\n        loading: false\r\n      })\r\n    },\r\n\r\n    //记录播放状态\r\n    audioStatus: function() {\r\n      const _this = this;\r\n      //音频播放进度更新事件\r\n      audioContext.onTimeUpdate(() => {\r\n        seekPosition = audioContext.currentTime;\r\n        _this.setData({\r\n          currentProcess: ss.formatSecToMin(audioContext.currentTime),\r\n          sliderValue: audioContext.currentTime / _this.data.audioDuration * 100,\r\n        })\r\n      })\r\n      //音频播放结束\r\n      audioContext.onEnded(() => {\r\n        seekPosition = 0;\r\n        _this.setData({\r\n          sliderValue: 0,\r\n          currentProcess: '00:00',\r\n          playing: false,\r\n          pause: true\r\n        })\r\n      })\r\n    },\r\n\r\n    //开始拖动\r\n    onSliderDrag(e) {\r\n      const _this = this;\r\n      if (_this.data.playing) {\r\n        _this.audioPause()\r\n      }\r\n      let sliderValue = e.detail.value;\r\n      seekPosition = _this.data.audioDuration / 100 * sliderValue;\r\n      _this.setData({\r\n        currentProcess: ss.formatSecToMin(seekPosition)\r\n      })\r\n\r\n    },\r\n\r\n    //拖动结束\r\n    onSliderChange(e) {\r\n      const _this = this;\r\n      _this.audioPlay()\r\n    },\r\n\r\n\r\n    //前进15s\r\n    forward() {\r\n      const _this = this,\r\n        audioDuration = _this.data.audioDuration;\r\n      let currentTime;\r\n      if (_this.data.playing) {\r\n        currentTime = audioContext.currentTime;\r\n      }\r\n      if (_this.data.pause) {\r\n        currentTime = seekPosition;\r\n      }\r\n\r\n      if (audioDuration - currentTime > 15) {\r\n        seekPosition = currentTime + 15;\r\n        _this.setData({\r\n          sliderValue: seekPosition / audioDuration * 100,\r\n          currentProcess: ss.formatSecToMin(seekPosition)\r\n        });\r\n      } else {\r\n        seekPosition = audioDuration;\r\n        _this.setData({\r\n          sliderValue: 0,\r\n          currentProcess: '00:00'\r\n        });\r\n      }\r\n      if (audioUrl && _this.data.playing) {\r\n        audioContext.seek(seekPosition);\r\n      }\r\n    },\r\n\r\n    //后退15s\r\n    backward() {\r\n      const _this = this,\r\n        audioDuration = _this.data.audioDuration;\r\n      let currentTime;\r\n      if (_this.data.playing) {\r\n        currentTime = audioContext.currentTime;\r\n      }\r\n      if (_this.data.pause) {\r\n        currentTime = seekPosition;\r\n      }\r\n\r\n      if (currentTime > 15) {\r\n        seekPosition = currentTime - 15;\r\n      } else {\r\n        seekPosition = 0;\r\n      }\r\n      _this.setData({\r\n        sliderValue: seekPosition / audioDuration * 100,\r\n        currentProcess: ss.formatSecToMin(seekPosition)\r\n      });\r\n      if (audioUrl && _this.data.playing) {\r\n        audioContext.seek(seekPosition);\r\n      }\r\n    }\r\n  }\r\n}) 大概就是这些了~有更好解决方案的欢迎留言哈~~"}
{"title": "微信小程序wx:key以及wx:key=\" *this\"详解 ", "author": "Rolan", "put_time": "2019-8-13 00:37", "content": "今天写微信小程序无意中看到控制台给出了这样一行提示：求解百度才知道，给大家分享一下：1.wx:for定义官方文档：在组件上使用 wx:for 控制属性绑定一个数组，即可使用数组中各项的数据重复渲染该组件。默认数组的当前项的下标变量名默认为 index，数组当前项的变量名默认为 item人话：根据已有数据来迭代生成组件的一个方法。学前端的同学肯定不会陌生了，V-for、ng-repeat都是一样的原理，可是在这里为什么会报错呢，往下看2.wx:key定义官方文档：如果列表中项目的位置会动态改变或者有新的项目添加到列表中，并且希望列表中的项目保持自己的特征和状态（如 input 中的输入内容，switch 的选中状态），需要使用 wx:key 来指定列表中项目的唯一的标识符。wx:key 的值以两种形式提供字符串，代表在 for 循环的 array 中 item 的某个 property，该 property 的值需要是列表中唯一的字符串或数字，且不能动态改变。保留关键字 *this 代表在 for 循环中的 item 本身，这种表示需要 item 本身是一个唯一的字符串或者数字，如：当数据改变触发渲染层重新渲染的时候，会校正带有 key 的组件，框架会确保他们被重新排序，而不是重新创建，以确保使组件保持自身的状态，并且提高列表渲染时的效率。如不提供 wx:key，会报一个 warning， 如果明确知道该列表是静态，或者不必关注其顺序，可以选择忽略。人话：wx:key是用来告诉程序按照某个key去排序这个组件，例如wx:key=\"Id\",此时组件顺序就会按照你arr中Id值来进行排序了(注意此时的Id是唯一切不能动态改变的，也是你要迭代对象中唯一的一个标识符)。而如果没有这个wx:key的话，当渲染时框架会去查找这个\"key\"，造成资源的浪费。3.wx:key=\" *this\"         相信大家对这个也是一头雾水，我的理解它就是告诉wx,用我自身（this关键字不用解释了吧！）作为这个key来进行迭代，当然，此时要求你自身是唯一的数字或者字符串（就是不能为对象，不然让人家咋找）。总结：1.需要wx:key的情况列表中项目的位置会动态改变或者有新的项目添加到列表中希望列表中的项目保持自己的特征和状态（如 <input/> 中的输入内容，<switch/> 的选中状态）2.可不需要wx:key的情况如果明确知道该列表是静态，或者不必关注其顺序，可以不用加wx:key"}
{"title": "手把手从零开始小程序单元测试(附避坑指南以及源码跟踪) ", "author": "Rolan", "put_time": "2019-7-29 00:15", "content": "单元测试是一个老生常谈的话题，基于Web/NodeJs环境的测试框架、测试教程数不胜数，也趋于成熟了。但是对于微信小程序的单元测试，目前还是处于起步状态，这两天在研究微信小程序的测试，也遇到了一些坑，在这里记录一下，希望给看到本文的小伙伴带来一点帮助，少走一些弯路。本文内容有点多，但是干货满满，不明白的小伙伴可以给我留言demo地址https://github.com/xialeistudio/miniprogram-unit-test-demo关键依赖版本本文写作时相关依赖版本如下(版本不同，源码行数可能不同)：miniprogram-simulate: 1.0.7j-component: 1.1.6miniprogram-exparser: 0.0.6测试流程初始化小程序项目，编写待测试组件安装jest,miniprogram-simulate测试环境编写测试用例执行测试初始化小程序项目使用小程序开发者工具初始化新项目，APPID选择 测试号 即可，语言选择 Javascript 。使用小程序开发者工具新建 /components/user 组件components/user.js// components/user.js\r\nComponent({\r\n    data: {\r\n        nickname: ''\r\n    },\r\n    methods: {\r\n        handleUserInfo: function(e){\r\n            this.setData({ nickname: e.detail.userInfo.nickName })\r\n        }\r\n    }\r\n})\r\ncomponents/user.wxml<textclass=\"nickname\">{{nickname}}</text>\r\n<buttonclass=\"button\"open-type=\"getUserInfo\"bindgetuserinfo=\"handleUserInfo\">Oauth</button>\r\npages/index/index.jsPage({\r\n    data:{}\r\n})\r\npages/index/index.wxml<viewclass=\"container\">\r\n    <user></user>\r\n</view>\r\n打开小程序开发者工具，可以看到有一个 Oauth 按钮，点击之后会在上面显示昵称。由此可以得到测试用例 点击授权按钮时上方显示为授权用户的昵称安装jest/miniprogram-simulate测试环境由于JS项目的小程序根目录没有 package.json ，需要手动生成一下打开终端，在项目根目录执行 npm init -y 生成 package.json安装测试工具集 npm install jest miniprogram-simulate --save-dev编辑 package.json ，在 scripts 新建 test 命令{\r\n    \"name\": \"unit-test-demo\",\r\n    \"version\": \"1.0.0\",\r\n    \"description\": \"\",\r\n    \"main\": \"app.js\",\r\n    \"scripts\": {\r\n        \"test\": \"jest\"\r\n    },\r\n    \"keywords\": [],\r\n    \"author\": \"\",\r\n    \"license\": \"ISC\",\r\n    \"devDependencies\": {\r\n        \"jest\": \"^24.8.0\",\r\n        \"miniprogram-simulate\": \"^1.0.7\"\r\n    }\r\n}\r\n编写测试用例在项目根目录新建 tests/components/user.spec.js 文件(目录需要手动创建)代码如下(参考微信官方单元测试文档编写):const simulate = require('miniprogram-simulate');\r\nconst path = require('path');\r\n\r\ntest('components/user', (done) => { // 定义测试名称,传入done表示当前测试是异步测试，需要回调函数来告诉jest，我测试执行完毕\r\nconst id = simulate.load(path.join(__dirname, '../../components/user')); // 加载组件\r\nconst component = simulate.render(id); // 渲染组件\r\n\r\nconst text = component.querySelector('.nickname'); // 获取nickname节点\r\nconst button = component.querySelector('.button'); // 获取button节点\r\nbutton.dispatchEvent('getuserinfo', { // 模拟触发事件\r\n    detail: {   // 传递事件参数\r\n        userInfo: {\r\n            nickName: 'hello',\r\n        },\r\n    },\r\n});\r\nsetTimeout(()=> { // 异步断言\r\n    expect(text.dom.innerHTML).toBe('hello'); // 检测text节点的innerHTML等于模拟授权获取的昵称\r\n    done();\r\n}, 1000);\r\n});\r\n执行测试npm run test ，等待一秒后发现， 不出意外的话，测试肯定过不去部分出错日志：Expected: \"hello\"\r\nReceived: \"\"\r\n     at toBe (/Users/xialeistudio/WeChatProjects/unit-test-demo/tests/components/user.spec.js:18:32)\r\n     at Timeout.callback [as _onTimeout] (/Users/xialeistudio/WeChatProjects/unit-test-demo/node_modules/jsdom/lib/jsdom/browser/Window.js:678:19)\r\n     at listOnTimeout (internal/timers.js:535:17)\r\n     at processTimers (internal/timers.js:479:7)\r\n可以推测一下原因：dispatchEvent的事件触发有问题，导致handleUserInfo未触发[1]dispatchEvent的事件触发成功，但是触发参数有问题[2]错误分析(源码跟踪过程)针对第1点原因，可以写一下测试代码( components/user.js )Component({\r\n    data: {\r\n        nickname: ''\r\n    },\r\n    methods: {\r\n        handleUserInfo: function(e){\r\n            console.log(e);\r\n        }\r\n    }\r\n})\r\nnpm run test ，可以看到事件还是成功触发了，不过 detail 是 {} console.log components/user.js:21\r\n{ type: 'getuserinfo',\r\n  timeStamp: 948,\r\n  target: { id: '', offsetLeft: 0, offsetTop: 0, dataset: {} },\r\n  currentTarget: { id: '', offsetLeft: 0, offsetTop: 0, dataset: {} },\r\n  detail: {},\r\n  touches: {},\r\n  changedTouches: {} }\r\n原因1排除，查原因2dispatchEvent 方法是 被测试组件的子组件 ， 被测试组件 由 simulate.render 函数返回浏览 node_modules/miniprogram-simulate/src/index.js ，看到 render函数(152行) ，可以看到返回的组件由 jComponent.create 提供浏览 node_modules/j-component/src/index.js 的 create 函数，可以看到其返回了 RootComponent 实例，而 RootComponent 是由 ./render/component.js 提供浏览 node_modules/j-component/src/render/component.js 的 dispatchEvent 函数，在这里可以打下日志测试(本文就不打了，结果是这里的options就是 user.spec.js dispatchEvent函数的 第二个参数 ， detail 是有值的)继续跟踪源码，由于咱们的是 自定义事件 ，所以会走到 91行 的代码，该代码块如下：// 自定义事件\r\n  const customEvent = new CustomEvent(eventName, options);\r\n\r\n  // 模拟异步情况\r\n  setTimeout(()=> {\r\n    dom.dispatchEvent(customEvent);\r\n\r\n    exparser.Event.dispatchEvent(customEvent.target, exparser.Event.create(eventName, {}, {\r\n      originalEvent: customEvent,\r\n      bubbles: true,\r\n      capturePhase: true,\r\n      composed: true,\r\n      extraFields: {\r\n        touches: options.touches || {},\r\n        changedTouches: options.changedTouches || {},\r\n      },\r\n    }));\r\n  }, 0);\r\n可以看到调用了 exparser.Event.dispatchEvent 函数，该函数的 第二个参数 调用了 exparser.Event.create 对自定义事件进行了包装，这里还没到最底层，需要继续跟踪exparser 对象是 miniprogram-exparser模块 提供的，浏览 node_modules/miniprogram-exparser/exparser.min.js ，发现该文件被混淆了，不过没关系 混淆后的代码逻辑是不变的，只不过变量名变得无意义，可读性变差使用webstorm格式化该文件，这里我传了一份格式化好的到github wxparser.js，可在线观看需要在源码中搜索 三个参数 的 create 函数( Object.create不算 )，需要有耐心，经过排查后发现 168行 代码应该是目标代码i.create = function(e, t, r){\r\n    r = r || {};\r\n    var n = r.originalEvent, o = r.extraFields || {}, a = Date.now() - l, s = new i;\r\n    s.currentTarget = null, s.type = e, s.timeStamp = a, s.mark = null, s.detail = t, s.bubbles = !!r.bubbles, s.composed = !!r.composed, s.__originalEvent = n, s.__hasCapture = !!r.capturePhase, s.__stopped = !1, s.__dispatched = !1;\r\n    for (var u in o) s[u] = o[u];\r\n    return s;\r\n}\r\n可以看到 s.detail = t 这个赋值， t 是 create 的 第二个参数 ，由 node_modules/j-component/render/component.js 的 wxparser.Event.create 传入，但是传入的 第二个参数写死了{}，所以咱们的组件获取 detail 的时候 永远为{} ，将其修改为 options.detail||{} 即可，修改后代码如下：exparser.Event.dispatchEvent(customEvent.target, exparser.Event.create(eventName, options.detail||{}, xxxxxx\r\n重新测试   PASS  tests/components/user.spec.js\r\n✓ components/user (1099ms)\r\n\r\n  Test Suites: 1 passed, 1 total\r\n  Tests:       1 passed, 1 total\r\n  Snapshots:   0 total\r\n  Time:        3.622s\r\n  Ran all test suites.\r\n避坑指南querySelector 用法同HTML，但是需要在 组件 执行，而不是 组件.dom ，HTML中实在 DOMNode 执行的dispatchEvent 是触发事件，需要在 组件 执行，上述代码中是触发 button组件 的 自定义事件dispatchEvent 事件名规范: 去掉前导bind剩余的字符串为事件名 ，示例代码中 bindgetuserinfo ，触发时就是 getuserinfo ，如果是 bindtap ，那触发时就是 tapdispatchEvent 底层是 j-component 这个 npm模块实现 的，跟踪源码发现执行是异步的(代码文件 node_modules/j-component/src/render/component.js ，函数名 dispatchEvent )// 自定义事件\r\n  const customEvent = new CustomEvent(eventName, options);\r\n\r\n  // 模拟异步情况\r\n  setTimeout(()=> {\r\n    dom.dispatchEvent(customEvent);\r\n\r\n    exparser.Event.dispatchEvent(customEvent.target, exparser.Event.create(eventName, {}, {\r\n      originalEvent: customEvent,\r\n      bubbles: true,\r\n      capturePhase: true,\r\n      composed: true,\r\n      extraFields: {\r\n        touches: options.touches || {},\r\n        changedTouches: options.changedTouches || {},\r\n      },\r\n    }));\r\n  }, 0);\r\n由于 setTimeout 的存在，触发事件为异步，所以写断言时需要加定时器结语小程序单元测试基本是没什么经验扩借鉴，但是基于官网提供的工具，以及 开源 ，咱们遇到问题时细心排查然后修改一下，还是可以解决问题的。对单元测试有疑问的小伙伴可以扫码加我进行交流。"}
{"title": "小程序 随机读取数据并生成分享图片 上手笔记 ", "author": "Rolan", "put_time": "2019-7-29 00:25", "content": "效果图如下，用户每次点击分享图片的时候，从内容库中随机抽出一条数据，渲染在图片上，并且加上用户昵称和头像，用户可以保存到本地。功能不难，但是有一些小细节，还是列出来记录下吧。根据开发的顺序写一下吧，先要确定rpx单位，读取数据（昵称 头像、文字），再渲染圆角头像和本地的二维码图片，判断保存权限，关闭后再次点击再渲染。目录自适应rpx单位读取用户昵称和头像随机获取文字内容promisify.js的封装使用渲染网络图片和本图片圆角图片保存权限多次渲染清空1. 自适应rpx单位起初自己在 css 里用的 px 单位给 canvas 设置的样式，在模拟器里切换机型后不能自适应，又换成 rpx 单位。canvas 里渲染图片和文字也需要单位，需要把 px 转成 rpx ， 1rpx = 窗口宽度px/750 。<!--rpx2px函数-->\r\nfunction createRpx2px() {\r\n  const { windowWidth } = wx.getSystemInfoSync()\r\n  return function(rpx) {\r\n    return windowWidth / 750 * rpx\r\n  }\r\n}\r\n\r\n<!--使用rpx2px-->\r\nconst rpx2px = createRpx2px()\r\nctx.setFontSize(rpx2px(28))\r\nctx.fillText('长按左侧二维码', rpx2px(220), rpx2px(640))\r\n复制代码2. 读取用户昵称和头像根据微信的api文档，需要使用 open-type=\"getUserInfo\" 属性的按钮获取用户授权，授权成功后调用 wx.getUserInfo 方法获取用户详情。<button class=\"button\" open-type=\"getUserInfo\" bindtap=\"share\" >分享到朋友圈</button>\r\n复制代码封装获取用户详情的 Promise ，并且返回昵称和图片地址。<!--获取用户详情-->\r\ngetInfo(){\r\n    return new Promise((resolve, reject) => {\r\n      wx.getUserInfo({\r\n        success: function(res) {\r\n          let { nickName , avatarUrl } = res.userInfo\r\n          resolve({ nickName , avatarUrl })\r\n        }\r\n      })\r\n    })\r\n  }\r\n复制代码3. 随机获取文字内容云数据库可以使用类 mongo 的 sample 方法随机抽取数据，具体可见官方网文档。size 为指定数量。封装 Promise 返回数据getMsg(){\r\n    const db = wx.cloud.database()\r\n    return new Promise((resolve, reject) => {\r\n      db.collection('shareMsg').aggregate().sample({ size: 1 }).end().then(res=>{ \r\n        resolve(res.list[0])\r\n      });\r\n    })\r\n  },\r\n复制代码4. promisify.js的封装使用Nodejs 8 有一个工具函数 util.promisify()。将一个接收回调函数参数的函数转换成一个返回Promise的函数。js的编程中有很多需要异步的场景，刚才我们获取昵称和随机数据都用到了 Promise ，这样写很麻烦，微信的api都遵循一样的规范，网上有封装好的代码，拿来主义。promisify.jsconst promisify = (api) => {\r\n    return (options, ...params) => {\r\n        return new Promise((resolve, reject) => {\r\n            api(Object.assign({}, options, { success: resolve, fail: reject }), ...params);\r\n        });\r\n    }\r\n}\r\nexport default promisify\r\n复制代码使用示例import promisify from '../../lib/promisify.js'; \r\n\r\nlet userInfo = promisify(wx.getUserInfo);\r\nuserInfo().then(res => {\r\n  console.log(res)\r\n})\r\n复制代码5. 渲染网络图片和本图片读取网络图片要在公众平台设置合法域名。接口返回的头像图片域名为 https://wx.qlogo.cn，添加上就可以了。渲染网络图片需要使用 wx.getImageInfo 方法把网络图片变成本地图片再渲染，本地图片直接放入图片路径即可。this.getInfo().then(userInfo => {\r\n \r\n    Promise.all([\r\n        wxGetImageInfo({\r\n            src: userInfo.avatarUrl\r\n        })\r\n    ]).then(res => {\r\n     \r\n        ctx = wx.createCanvasContext('shareCanvas')\r\n            \r\n        <!--网络图片-->\r\n        ctx.drawImage(res[0].path, rpx2px(40), rpx2px(60), rpx2px(60), rpx2px(60)); \r\n    \r\n        <!--本地图片-->\r\n        ctx.drawImage('../../images/qrcode.jpeg', rpx2px(20), rpx2px(580), rpx2px(160),rpx2px(160));\r\n\r\n\r\n    })\r\n})\r\n复制代码6. 圆角头像ctx.save(); \r\nctx.beginPath(); \r\nctx.arc(rpx2px(70), rpx2px(90), rpx2px(30), 0, Math.PI * 2, false);\r\nctx.clip();\r\nctx.drawImage(res[0].path, rpx2px(40), rpx2px(60), rpx2px(60), rpx2px(60)); \r\nctx.restore(); \r\n复制代码7. 保存权限第一步使用 wx.canvasToTempFilePath 从 canvas 导出图片，第二步使用 wx.saveImageToPhotosAlbum 要把导出的图片的图片保存到相册。保存到相册是需要用户授权的，用户授权拒绝后七天之内是不会在出现的授权框的，所以需要增加判断，如果无权限，显示设置按钮，跳转到权限设置页面。<!--保存按钮-->\r\nsaveImg(){\r\n    const wxCanvasToTempFilePath = promisify(wx.canvasToTempFilePath)\r\n    const wxSaveImageToPhotosAlbum = promisify(wx.saveImageToPhotosAlbum)\r\n\r\n    wxCanvasToTempFilePath({\r\n        canvasId: 'shareCanvas'\r\n    }, this).then(res => {\r\n        return wxSaveImageToPhotosAlbum({\r\n            filePath: res.tempFilePath\r\n        })\r\n    }).then(res => {\r\n        wx.showToast({\r\n            title: '已保存到相册'\r\n        })\r\n    }).catch(err => {\r\n      wx.showToast({\r\n          icon: 'none',\r\n          title: '授权失败'\r\n        })\r\n      <!--显示授权按钮-->\r\n      this.setData({setPage:true})\r\n    })\r\n  }\r\n复制代码<button hidden=\"{{!setPage}}\" open-type=\"openSetting\" >设置权限</button>\r\n复制代码8. 多次渲染清空对 canvas 不是特别熟悉，从翻api说画一个图形，然后在清除图片范围内的内容。ctx.fillRect(0,0,rpx2px(500),rpx2px(760))\r\nctx.clearRect(0,0,rpx2px(500),rpx2px(760))\r\nctx.draw()\r\n复制代码ctx 对象要多次操作，需要提取为全局变量，另外创建时要保证DOM渲染完毕。let ctx = wx.createCanvasContext('shareCanvas')\r\n复制代码不过在模拟器中多次渲染会出现空白的情况，但是手机实测是正常的。好了，这个是在 【小程序 + 云开发】体重记录小程序 上手笔记 发表后继续新增的功能，下次希望云函数新增定时任务和推送的内容。"}
{"title": "微信小程序渲染性能调优 ", "author": "Rolan", "put_time": "2019-7-30 00:12", "content": "网页的性能优化是前端开发老生常谈的热门话题，其中微信小程序因其页面双线程架构设计，所以性能优化的手段跟传统的 H5 应用不太一样。今天主要介绍一下微信小程序页面双线程架构的特性给页面渲染带来的一些影响，以及应对的一些渲染性能调优策略。为了叙述方便，下文会把微信小程序简称为小程序。小程序的双线程架构与传统的浏览器Web页面最大区别在于，小程序的是基于 双线程 模型的，在这种架构中，小程序的渲染层使用 WebView 作为渲染载体，而逻辑层则由独立的 JsCore 线程运行 JS 脚本，双方并不具备数据直接共享的通道，因此渲染层和逻辑层的通信要由 Native 的 JSBrigde 做中转。小程序更新视图数据的通信流程每当小程序视图数据需要更新时，逻辑层会调用小程序宿主环境提供的 setData 方法将数据从逻辑层传递到视图层，经过一系列渲染步骤之后完成UI视图更新。完整的通信流程如下：小程序逻辑层调用宿主环境的 setData 方法。逻辑层执行 JSON.stringify 将待传输数据转换成字符串并拼接到特定的JS脚本，并通过 evaluateJavascript 执行脚本将数据传输到渲染层。渲染层接收到后， WebView JS 线程会对脚本进行编译，得到待更新数据后进入渲染队列等待 WebView 线程空闲时进行页面渲染。WebView 线程开始执行渲染时，待更新数据会合并到视图层保留的原始 data 数据，并将新数据套用在WXML片段中得到新的虚拟节点树。经过新虚拟节点树与当前节点树的 diff 对比，将差异部分更新到UI视图。同时，将新的节点树替换旧节点树，用于下一次重渲染。引发渲染性能问题的一些原因在上述通信流程中，一些不恰当的操作可能会影响到页面渲染的性能：setData传递大量的新数据数据的传输会经历跨线程传输和脚本编译的过程，当数据量过大，会增加脚本编译的执行时间，占用 WebView JS 线程。下图是我们做的一组测试统计：在相同网络环境下，各个机型分别对大小为 1KB 、 2KB 、 3KB 的数据执行 setData 操作所消耗的时间。从图中可以看出， setData 数据传输量越大，数据传输所消耗的时间越大。频繁的执行setData操作频繁的执行 setData 会让 WebView JS 线程一直忙碌于脚本的编译、节点树的对比计算和页面渲染。导致的结果是：WebView JS\r\n过多的页面节点数页面初始渲染时，渲染树的构建、计算节点几何信息以及绘制节点到屏幕的时间开销都跟页面节点数量成正相关关系，页面节点数量越多，渲染耗时越长。每次执行 setData 更新视图， WebView JS 线程都要遍历节点树计算新旧节点数差异部分。当页面节点数量越多，计算的时间开销越大，减少节点树节点数量可以有效降低重渲染的时间开销。渲染性能优化基于引发渲染性能问题的原因，我们可以制定一些优化策略来避免性能问题的发生。setData优化setData 作为逻辑层与视图层通信的媒介，是最容易造成渲染性能瓶颈的 API 。我们在使用 setData 时应该遵循一些规则来尽可能避免性能问题的发生：减少 setData 数据传输量仅传输视图层使用到的数据，其他 JS 环境用到的数据存放到 data 对象外。合理利用局部更新。 setData 是支持使用 数据路径 的方式对对象的局部字段进行更新，我们可能会遇到这样的场景： list 列表是从后台获取的数据，并展示在页面上，当 list 列表的第一项数据的 src 字段需要更新时，一般情况下我们会从后台获取新的 list 列表，执行 setData 更新整个 list 列表。// 后台获取列表数据\r\n  const list = requestSync(); \r\n\r\n  // 更新整个列表\r\n  this.setData({ list });  \r\n复制代码实际上，只有个别字段需要更新时，我们可以这么写来避免整个 list 列表更新:// 后台获取列表数据\r\n  const list = requestSync(); \r\n\r\n  // 局部更新列表\r\n  this.setData({ \r\n      'list[0].src': list[0].src\r\n  });  \r\n复制代码降低 setData 执行频率在不影响业务流程的前提下，将多个 setData 调用合并执行，减少线程间通信频次。当需要在频繁触发的用户事件（如 PageScroll 、 Resize 事件）中调用 setData ，合理的利用 函数防抖（debounce） 和 函数节流（throttle） 可以减少 setData 执行次数。函数防抖（debounce） ：函数在触发n秒后才执行一次，如果在n秒内重复触发函数，则重新计算时间。函数节流（throttle） ：单位时间内，只会触发一次函数，如果同一个单位时间内触发多次函数，只会有一次生效。除了让开发者自觉遵循规则来减少 setData 数据传输量和执行频率之外，我们还可以自己设计一个 diff 算法，重新对 setData 进行封装，使得在 setData 执行之前，让待更新的数据与原 data 数据做 diff 对比，计算出数据差异 patch 对象，判断 patch 对象是否为空，如果为空则跳过执行更新，否则再将 patch 对象执行 setData 操作，从而达到减少数据传输量和降低执行 setData 频率的目的。// setData重新封装成新的方法，使得数据更新前先对新旧数据做diff对比，再执行setData方法\r\nthis.update = (data) => {\r\n    return new Promise((resolve, reject) => {\r\n        const result = diff(data, this.data);\r\n        if (!Object.keys(result).length) {\r\n            resolve(null);\r\n            return;\r\n        } \r\n        this.setData(result, () => {\r\n            resolve(result);\r\n        });\r\n    });\r\n}\r\n复制代码当然，可以直接引用 这里 的现成 高性能小程序 setData diff算法具体流程如下图：善用自定义组件小程序自定义组件的实现是由小程序官方设计的 Exparser 框架所支持，框架实现的自定义组件的组件模型与 Web Components 标准的 Shadow DOM 相似：在页面引用自定义组件后，当初始化页面时， Exparser 会在创建页面实例的同时，也会根据自定义组件的注册信息进行组件实例化，然后根据组件自带的 data 数据和组件WXML，构造出独立的 Shadow Tree ，并追加到页面 Composed Tree 。创建出来的 Shadow Tree 拥有着自己独立的逻辑空间、数据、样式环境及setData调用：基于自定义组件的 Shadow DOM 模型设计，我们可以将页面中一些需要高频执行 setData 更新的功能模块（如倒计时、进度条等）封装成自定义组件嵌入到页面中。当这些自定义组件视图需要更新时，执行的是组件自己的 setData ，新旧节点树的对比计算和渲染树的更新都只限于组件内有限的节点数量，有效降低渲染时间开销。下图是我们在微保小程序WeDrive首页中，将倒计时模块抽取自定义组件前后的setData更新耗时对比：从图中可以看出，使用自定义组件后，倒计时模块 setData 平均渲染耗时有了非常明显的下降，实际在低端安卓机中体验会感觉明显的更流畅。当然，并不是使用自定义组件越多会越好，页面每新增一个自定义组件， Exparser 需要多管理一个组件实例，内存消耗会更大，当内存占用上升到一定程度，有可能导致 iOS 将部分 WKWebView 回收，安卓机体验会变得更加卡顿。因此要合理的使用自定义组件，同时页面设计也要注意不滥用标签。"}
{"title": "Taro+dva+Typescript 搭建微信小程序架构 ", "author": "Rolan", "put_time": "2019-7-30 00:15", "content": "原文链接个人博客-欢迎访问效果预览图：微信小程序的开发目前是很热的一个领域，有很多的开发模式，找到一种属于自己的方法才会使得开发顺心顺利。此架构是使用 Taro + dva + typescript 构建前端开发京东凹凸实验室的React框架Taro很成熟，又是大厂在维护更新迭代，不用担心没人维护的问题，他有自己的UI还有物料社区，比起原生小程序方便很多，支持多端，一处代码，多处运行，微信小程序、H5、百度小程序、支付宝小程序、字节跳动小程序、QQ轻应用、快应用、ReactNative；数据管理是Redux集成的dva框架，是一个基于 redux 和 redux-saga 的数据流方案，然后为了简化开发体验，dva 还额外内置了 react-router 和 fetch，所以也可以理解为一个轻量级的应用框架；TypeScript就是所谓的JavaScript超集。它不是JavaScript的替代品，也不会为JavaScript代码添加任何新功能。相反，TypeScript允许程序员在其代码中使用面向对象的构造，然后将其转换为JavaScript。它还包括类型安全和编译时类型检查等便利功能。资料Taro官网地址：https://taro.aotu.io/dva官网地址：https://dvajs.com/guide/开始前期工作准备cli 工具安装:# 使用 npm 安装 cli\r\n$ npm install -g @tarojs/cli\r\n\r\n# OR 使用 yarn 安装 cli\r\n$ yarn global add @tarojs/cli\r\n\r\n# OR 安装了 cnpm，使用 cnpm 安装 cli\r\n$ cnpm install -g @tarojs/cli\r\n\r\n\r\n复制代码使用命令创建模板项目:$ taro init Taro_dva_Typescript\r\n\r\n复制代码安装配置文件安装dvacnpm install --save dva-core dva-loadingdva-core\r\ndva-loading\r\n安装@tarojs/reduxcnpm install --save redux @tarojs/redux @tarojs/redux-h5 redux-thunk redux-logger配置项目文件去除不需要的文件，添加实际需要的一些文件，先删除 ./ssrc/page 下的index文件夹，后期使用命令行生成完整结构的文件夹。在``/src`目录下根据自己的实际需求进行一下配置：assets\r\nconfig\r\ncomponents\r\ntypes\r\nmodels\r\nutils\r\n项目一些具体配置操作1、在 ./src/config 下创建index.ts，添加项目配置信息/** \r\n * 这里为了方便测试使用 Easy Mock 模拟接口数据\r\n * \r\n * https://www.easy-mock.com/mock/5d38269ffb233553ab0d10ad/getlist\r\n*/\r\n\r\nexport const ONLINEHOST = 'https://www.easy-mock.com/mock/5d38269ffb233553ab0d10ad/getlist';\r\n\r\n/** \r\n * mock 接口\r\n * */ \r\nexport const MOCKHOST = 'https://www.easy-mock.com/mock/5d38269ffb233553ab0d10ad/getlist';\r\n\r\n/** \r\n * 是否mock\r\n*/\r\n\r\nexport const ISMOCK = true;\r\n\r\n\r\n/**\r\n * 这是一个全局的分享信息 不用每一个都去写\r\n */\r\nexport const SHAREINFO = {\r\n    'title': '分享标题',\r\n    'path': '路径',\r\n    'imageUrl': '图片'\r\n  }\r\n\r\n\r\n复制代码2、在 ./src/utils 下创建dva.ts，配置dvaimport { create } from \"dva-core\";\r\nimport { createLogger } from \"redux-logger\";\r\nimport  createLoading  from \"dva-loading\";\r\n\r\n\r\n\r\nlet app\r\nlet store\r\nlet dispatch\r\nlet registered\r\n\r\nfunction createApp(opt) {\r\n    // redux 的日志\r\n    opt.onAction = [createLogger()]\r\n    app = create(opt)\r\n    app.use(createLoading({}))\r\n\r\n    if (!registered) {\r\n        opt.models.forEach(model => app.model(model));\r\n    }\r\n    registered = true;\r\n    app.start()\r\n\r\n    store = app._store;\r\n    app.getStore = () => store;\r\n    app.use({\r\n        onError(err){\r\n            console.log(err);\r\n        }\r\n    })\r\n\r\n    dispatch = store.dispatch;\r\n    app.dispatch = dispatch;\r\n    return app;\r\n}\r\n\r\nexport default{\r\n    createApp,\r\n    getDispatch(){\r\n        return app.dispatch\r\n    }\r\n}\r\n\r\n复制代码3、在 ./src/utils 下创建tips.ts，整合封装微信原生弹窗import Taro from \"@tarojs/taro\";\r\nimport { node } from \"_@types_prop-types@15.7.1@@types/prop-types\";\r\n\r\n/** \r\n * 整合封装微信的原生弹窗\r\n * 提示、加载、工具类\r\n*/\r\n\r\nexport default class Tips {\r\n\tstatic isLoading = false;\r\n\r\n\t/** \r\n\t * 提示信息\r\n\t*/\r\n\tstatic toast(title: string, onHide?: () => void) {\r\n\t\tTaro.showToast({\r\n\t\t\ttitle: title,\r\n\t\t\ticon: 'node',\r\n\t\t\tmask: true,\r\n\t\t\tduration: 1500\r\n\t\t});\r\n\t\t// 去除结束回调函数\r\n\t\tif (onHide) {\r\n\t\t\tsetTimeout(() => {\r\n\t\t\t\tonHide();\r\n\t\t\t}, 500);\r\n\t\t}\r\n\t}\r\n\r\n\t/** \r\n\t * 加载提示弹窗\r\n\t*/\r\n\r\n\tstatic loding(title:'加载中',force = false){\r\n\t\tif (this.isLoading && !force) {\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tthis.isLoading = true;\r\n\t\tif (Taro.showLoading) {\r\n\t\t\tTaro.showLoading({\r\n\t\t\t\ttitle:title,\r\n\t\t\t\tmask:true\r\n\t\t\t})\r\n\t\t}else{\r\n\t\t\tTaro.showNavigationBarLoading() //导航条加载动画\r\n\t\t}\r\n\t}\r\n\r\n\t/** \r\n\t * 加载完成\r\n\t*/\r\n\tstatic loaded(){\r\n\t\tlet duration = 0;\r\n\t\tif (this.isLoading) {\r\n\t\t\tthis.isLoading = false;\r\n\t\t\tif (Taro.hideLoading) {\r\n\t\t\t\tTaro.hideLoading()\r\n\t\t\t} else {\r\n\t\t\t\tTaro.hideNavigationBarLoading(); //导航条加载动画\r\n\t\t\t}\r\n\t\t\tduration = 500;\r\n\t\t}\r\n\t\t// 设定隐藏的动画时长为500ms,防止直接toast时出现问题\r\n\t\treturn new Promise(resolve => setTimeout(resolve,duration))\r\n\t}\r\n\r\n\t/** \r\n\t * 弹出提示框\r\n\t*/\r\n\r\n\tstatic success(title,duration = 1500){\r\n\t\tTaro.showToast({\r\n\t\t\ttitle: title,\r\n\t\t\ticon: 'success',\r\n\t\t\tduration: duration,\r\n\t\t\tmask:true\r\n\t\t})\r\n\t\tif (duration > 0) {\r\n\t\t\treturn new Promise(resolve => setTimeout(resolve,duration))\r\n\t\t}\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\n复制代码4、在 ./src/config 下创建requestConfig.ts，统一配置请求接口/** \r\n * 请求公共参数\r\n*/\r\n\r\nexport const commonParame = {}\r\n\r\n/** \r\n * 请求的映射文件\r\n*/\r\n\r\nexport const requestConfig = {\r\n    loginUrl:'/api/user/wechat-auth' // 微信的登陆接口\r\n}\r\n\r\n\r\n复制代码5、在 ./src/utils 下创建common.ts，共用函数/** \r\n * 共用函数\r\n*/\r\n\r\nexport const repeat = (str = '0', times) => (new Array(times + 1)).join(str);\r\n// 时间前面 +0 \r\nexport const pad = (num, maxLength = 2) => repeat('0', maxLength - num.toString().length) + num;\r\n\r\n// 全局的公共变量\r\nexport let globalData: any = {\r\n\r\n}\r\n\r\n// 时间格式装换函数\r\n\r\nexport const formatTime = time => {\r\n    `${pad(time.getHours())}:${pad(time.getMinutes())}:${pad(time.getSeconds())}.${pad(time.getMilliseconds(), 3)}`\r\n}\r\n\r\n复制代码6、在 ./src/utils 下创建logger.ts，封装log函数/** \r\n * 封装logo函数\r\n*/\r\n\r\nimport { formatTime } from './common';\r\n\r\nconst defaults = {\r\n\tlevel: 'log',\r\n\tlogger: console,\r\n\tlogErrors: true,\r\n\tcolors: {\r\n\t\ttitle:'logger',\r\n\t\treq:'#9e9e9e',\r\n\t\tres:'#4caf50',\r\n\t\terror:'#f20404',\r\n\t}\r\n}\r\n\r\nfunction printBuffer(logEntry, options){\r\n\tconst {logger,colors} = options;\r\n\tlet {title,started,req,res} = logEntry;\r\n\t\r\n\t// Message\r\n\tconst headerCSS = ['color:gray; font-weight:lighter;']\r\n\tconst styles = s => `color ${s}; font-weight: bold`;\r\n\r\n\t// render\r\n\tlogger.group(`%c ${title} @${formatTime(started)}`, ...headerCSS);\r\n\tlogger.log('%c req', styles(colors.req), req)\r\n\tlogger.log('%c res', styles(colors.res), res)\r\n\tlogger.groupEnd()\r\n\r\n}\r\n\r\ninterface LogEntry{\r\n\tstarted ? : object  // 触发时间\r\n}\r\n\r\nfunction createLogger(options: LogEntry = {}){\r\n\tconst loggerOptions = Object.assign({}, defaults, options)\r\n\tconst logEntry = options\r\n\tlogEntry.started = new Date();\r\n\tprintBuffer(logEntry, Object.assign({}, loggerOptions))\r\n}\r\n\r\nexport {\r\n\tdefaults,\r\n\tcreateLogger,\r\n}\r\n\r\n复制代码7、在 ./src/utils 下创建request.ts，封装http请求import Taro,{ Component } from \"@tarojs/taro\";\r\nimport { ISMOCK,MAINHOST } from \"../config\";\r\nimport { commonParame,requestConfig } from \"../config/requestConfig\";\r\nimport Tips from \"./tips\";\r\n\r\n\r\n// 封装请求\r\n\r\n\r\ndeclare type Methohs = \"GET\" | \"OPTIONS\" | \"HEAD\" | \"PUT\" | \"DELETE\" | \"TRACE\" | \"CONNECT\";\r\ndeclare type Headers = { [key :string]:string};\r\ndeclare type Datas = {method : Methohs; [key: string] : any;};\r\ninterface Options{\r\n    url: string;\r\n    host?: string;\r\n    method?: Methohs;\r\n    data?: Datas;\r\n    header?: Headers;\r\n}\r\n\r\nexport class Request {\r\n    // 登陆时的promise\r\n    static loginReadyPromise: Promise<any> = Promise.resolve()\r\n\r\n    // 正在登陆\r\n    static isLoading: boolean = false\r\n\r\n    // 导出的API对象\r\n    static apiLists: { [key: string]: () => any;} = {}\r\n\r\n    // token\r\n    static token: string = ''\r\n\r\n    // 开始处理options\r\n    static conbineOptions(opts, data: Datas, method: Methohs): Options {\r\n        typeof opts ===  'string' && (opts = {url: opts})\r\n        return {\r\n            data: { ...commonParame, ...opts.data, ...data },\r\n            method: opts.method || data.method || method || 'GET',\r\n            url: `${opts.host || MAINHOST}${opts.url}`\r\n        }\r\n    }\r\n\r\n    static getToken(){\r\n        !this.token && (this.token = Taro.getStorageSync('token'))\r\n        return this.token\r\n    }\r\n\r\n\r\n    // 登陆\r\n    static login(){\r\n        if (!this.isLoading) {\r\n            this.loginReadyPromise = this.onLogining()\r\n        }\r\n        return this.loginReadyPromise\r\n    }\r\n\r\n    static onLogining(){\r\n        this.isLoading = true;\r\n        return new Promise(async (resolve, reject) => {\r\n            // 获取code\r\n            const { code } = await Taro.login();\r\n\r\n            const { data } = await Taro.request({\r\n                url: `${MAINHOST}${requestConfig.loginUrl}`,\r\n                data:{code: code}\r\n            })\r\n\r\n            if (data.code !== 0 || !data.data || !data.data.token) {\r\n                reject()\r\n                return\r\n            }\r\n        })\r\n\r\n    }\r\n\r\n    /** \r\n     * 基于 Taro.request 的 request 请求\r\n     * \r\n     * */ \r\n    static async request(opts: Options) {\r\n        \r\n        // Taro.request 请求\r\n        const res = await Taro.request(opts);\r\n\r\n        // 是否mock\r\n        if(ISMOCK) return res.data;\r\n\r\n        // 请求失败\r\n        if (res.data.code === 99999) {\r\n            await this.login();\r\n            return this.request(opts)\r\n        }\r\n\r\n        // 请求成功\r\n        if (res.data) {\r\n            return res.data\r\n        }\r\n\r\n        // 请求错误\r\n        const edata = { ...res.data, err : (res.data && res.data.msg) || '网络错误 ~'}\r\n        Tips.toast(edata.err)\r\n        throw new Error(edata.err)\r\n\r\n    }\r\n\r\n\r\n    /** \r\n     * 创建请求函数\r\n    */\r\n   static creatRequests(opts: Options | string) : () => {} {\r\n       console.log('opts==>',opts);\r\n       return async (data={}, method: Methods = \"GET\") => {\r\n           const _opts = this.conbineOptions(opts, data, method)\r\n           const res = await this.request(_opts)\r\n            return res;\r\n        }\r\n   }\r\n\r\n   /** \r\n    * 抛出API方法\r\n   */\r\n\r\n   static getApiList(requestConfig){\r\n        if (!Object.keys(requestConfig).length) {\r\n            return {}\r\n        }\r\n        Object.keys(requestConfig).forEach((key)=>{\r\n            this.apiLists[key] = this.creatRequests(requestConfig[key])\r\n        })\r\n        return this.apiLists\r\n   }\r\n\r\n\r\n}\r\n\r\nconst Api = Request.getApiList(requestConfig)\r\nComponent.prototype.$api = Api\r\nexport default Api as any\r\n\r\n\r\n复制代码注：在这里tslint会报这样的错： 类型“Component<any, any>”上不存在属性“$api” 。，因为没有添加声明，需在./src目录下创建 app-shim.d.ts/** \r\n * 添加taro等自定义类型\r\n*/\r\n\r\nimport Taro,{ Component } from '@tarojs/taro'\r\n\r\n// 在Component上定义自定义方法类型\r\ndeclare module '@tarojs/taro' {\r\n    interface Component {\r\n        $api: any\r\n    }\r\n}\r\n\r\n// 声明\r\ndeclare let require: any;\r\ndeclare let dispatch: any\r\n\r\n复制代码8、在 ./src/config 下创建taroConfig.ts，封装taro小程序的一些方法import Taro,{ Component } from '@tarojs/taro'\r\nimport { SHAREINFO } from '../config/index'\r\n\r\n\r\n\r\n/** \r\n * 封装taro小程序的一些方法\r\n *  - 方法改写\r\n *  - utils 挂载\r\n*/\r\n\r\n\r\n// navigateTo 超过8次后，强行进行redirectTo,避免页面卡顿\r\n\r\n const nav = Taro.navigateTo\r\n Taro.navigateTo = (data) => {\r\n     if (Taro.getCurrentPages().length > 8) {\r\n         return Taro.redirectTo(data)\r\n     }\r\n     return nav(data)\r\n }\r\n\r\n\r\n// 挂载分享方法 Component\r\n\r\nComponent.prototype.onShareAppMessage = function () {\r\n    return SHAREINFO\r\n}\r\n\r\n\r\n复制代码配置文件生成脚本1、在根目录下创建scripts文件夹，添加 ./scripts/template.js/** \r\n *  pages 页面快速生成脚本\r\n *  \r\n *  npm run tem '文件名‘\r\n*/\r\n\r\nconst fs = require('fs')\r\nconst dirName = process.argv[2]\r\nconst capPirName = dirName.substring(0, 1).toUpperCase() + dirName.substring(1);\r\n\r\nif (!dirName) {\r\n    console.log('文件名不能为空');\r\n    console.log('用法：npm run tem test');\r\n    process.exit(0);\r\n}\r\n\r\n// 页面模板构建\r\n\r\nconst indexTep = `\r\n    import Taro, { Component, Config } from '@tarojs/taro'\r\n    import { View } from '@tarojs/components'\r\n    // import { connect } from '@tarojs/redux'\r\n    // import Api from '../../utils/request'\r\n    // import Tips from '../../utils/tips'\r\n    import { ${capPirName}Props, ${capPirName}State } from './${dirName}.interface'\r\n    import './${dirName}.scss'\r\n    // import {  } from '../../components'\r\n\r\n    // @connect(({ ${dirName} }) => ({\r\n    //     ...${dirName},\r\n    // }))\r\n\r\n    class ${capPirName} extends Component<${capPirName}Props,${capPirName}State > {\r\n    config:Config = {\r\n        navigationBarTitleText: '页面标题'\r\n    }\r\n    constructor(props: ${capPirName}Props) {\r\n        super(props)\r\n        this.state = {}\r\n    }\r\n\r\n    componentDidMount() {\r\n        \r\n    }\r\n\r\n    render() {\r\n        return (\r\n        <View className='fx-${dirName}-wrap'>\r\n            页面内容\r\n        </View>\r\n        )\r\n    }\r\n    }\r\n    export default ${capPirName}\r\n`\r\n\r\n// scss 文件模板\r\n\r\nconst scssTep = `\r\n    @import \"../../assets/scss/variables\";\r\n    .#{$prefix} {\r\n        &-${dirName}-wrap {\r\n            width: 100%;\r\n            min-height: 100Vh;\r\n        }\r\n    }\r\n`\r\n\r\n// config 接口地址配置模板\r\n\r\nconst configTep =`\r\n    export default {\r\n        test:'/wechat/perfect-info',  //XX接口\r\n    }\r\n`\r\n\r\n// 接口请求模板\r\n\r\nconst serviceTep =`\r\n    import Api from '../../utils/request'\r\n    export const testApi = data => Api.test(\r\n        data\r\n    )\r\n`\r\n\r\n// model 模板\r\n\r\nconst modelTep = `\r\n    // import Taro from '@tarojs/taro';\r\n    // import * as ${dirName}Api from './service';\r\n    export default {\r\n        namespace: '${dirName}',\r\n        state: {\r\n        },\r\n        \r\n        effects: {},\r\n        \r\n        reducers: {}\r\n    \r\n    }\r\n\r\n`\r\n\r\nconst interfaceTep = `\r\n/**\r\n * ${dirName}.state 参数类型\r\n *\r\n * @export\r\n * @interface ${capPirName}State\r\n */\r\nexport interface ${capPirName}State {}\r\n\r\n/**\r\n * ${dirName}.props 参数类型\r\n *\r\n * @export\r\n * @interface ${capPirName}Props\r\n */\r\nexport interface ${capPirName}Props {}\r\n`\r\n\r\nfs.mkdirSync(`./src/pages/${dirName}`); // mkdir $1\r\nprocess.chdir(`./src/pages/${dirName}`); // cd $1\r\n\r\nfs.writeFileSync(`${dirName}.tsx`, indexTep); //tsx\r\nfs.writeFileSync(`${dirName}.scss`, scssTep); // scss\r\nfs.writeFileSync('config.ts', configTep); // config\r\nfs.writeFileSync('service.ts', serviceTep); // service\r\nfs.writeFileSync('model.ts', modelTep); // model\r\nfs.writeFileSync(`${dirName}.interface.ts`, interfaceTep); // interface\r\nprocess.exit(0);\r\n\r\n\r\n\r\n复制代码最后在根目录的 package.json 的scripts里加上对应的命令\"scripts\": {\r\n  ...\r\n  \"tep\": \"node scripts/template\",\r\n  \"com\": \"node scripts/component\"\r\n}\r\n\r\n复制代码2、自动生成脚本文件夹cnpm run tep indexpage文件夹下生成了一个index的文件夹，里面包含config.tsindex.interface.tsindex.scssindex.tsxmodel.tsservice.ts配置业务代码1、先在 src 目录下创建 models 文件夹，集合项目里的 model 关系。import index from '../pages/index/model';\r\n\r\n\r\nexport default[\r\n    index\r\n]\r\n\r\n复制代码项目目前只有 index 页面， export default 这里的数组就只有 index ，需要注意这里是 []数组。2、修改非常主要的文件 app.tsximport Taro, { Component, Config } from '@tarojs/taro'\r\nimport \"@tarojs/async-await\";\r\nimport { Provider } from \"@tarojs/redux\";\r\nimport dva from './utils/dva';\r\nimport './utils/request';\r\nimport { globalData } from './utils/common';\r\n\r\nimport models from './models'\r\nimport Index from './pages/index'\r\nimport './app.scss'\r\n\r\n// 如果需要在 h5 环境中开启 React Devtools\r\n// 取消以下注释：\r\n// if (process.env.NODE_ENV !== 'production' && process.env.TARO_ENV === 'h5')  {\r\n//   require('nerv-devtools')\r\n// }\r\n\r\n\r\nconst dvaApp = dva.createApp({\r\n  initialState:{},\r\n  models:  models,\r\n})\r\n\r\nconst store = dvaApp.getStore();\r\n\r\nclass App extends Component {\r\n\r\n  /**\r\n   * 指定config的类型声明为: Taro.Config\r\n   *\r\n   * 由于 typescript 对于 object 类型推导只能推出 Key 的基本类型\r\n   * 对于像 navigationBarTextStyle: 'black' 这样的推导出的类型是 string\r\n   * 提示和声明 navigationBarTextStyle: 'black' | 'white' 类型冲突, 需要显示声明类型\r\n   */\r\n  config: Config = {\r\n    pages: [\r\n      'pages/index/index'\r\n    ],\r\n    window: {\r\n      backgroundTextStyle: 'light',\r\n      navigationBarBackgroundColor: '#fff',\r\n      navigationBarTitleText: 'WeChat',\r\n      navigationBarTextStyle: 'black'\r\n    }\r\n  }\r\n\r\n  /**\r\n   *\r\n   *  1.小程序打开的参数 globalData.extraData.xx\r\n   *  2.从二维码进入的参数 globalData.extraData.xx\r\n   *  3.获取小程序的设备信息 globalData.systemInfo\r\n   */\r\n  async componentDidMount () {\r\n    // 获取参数\r\n    const referrerInfo = this.$router.params.referrerInfo\r\n    const query = this.$router.params.query\r\n    !globalData.extraData && (globalData.extraData = {})\r\n    if (referrerInfo && referrerInfo.extraData) {\r\n      globalData.extraData = referrerInfo.extraData\r\n    }\r\n    if (query) {\r\n      globalData.extraData = {\r\n        ...globalData.extraData,\r\n        ...query\r\n      }\r\n    }\r\n\r\n    // 获取设备信息\r\n    const sys = await Taro.getSystemInfo()\r\n    sys && (globalData.systemInfo = sys)\r\n  }\r\n\r\n  componentDidShow () {}\r\n\r\n  componentDidHide () {}\r\n\r\n  componentDidCatchError () {}\r\n\r\n  render () {\r\n    return (\r\n      <Provider store={store}>\r\n        <Index />\r\n      </Provider>\r\n    )\r\n  }\r\n}\r\n\r\nTaro.render(<App />, document.getElementById('app'))\r\n\r\n\r\n复制代码3、修改接口请求 ./src/pages/index/config.ts 文件一个获取列表数据接口export default {\r\n  getList: '/getlist', //getlist接口\r\n}\r\n\r\n复制代码4、修改 ./src/config/requestConfig.ts 文件的映射关系引入 index 页面的刚刚创建的 config 文件import index from \"../pages/index/config\"; // index的接口\r\n\r\n\r\n\r\n/** \r\n * 请求公共参数\r\n*/\r\nexport const commonParame = {}\r\n\r\n/** \r\n * 请求的映射文件\r\n*/\r\n\r\nexport const requestConfig = {\r\n    loginUrl:'/api/user/wechat-auth', // 微信的登陆接口\r\n    ...index\r\n}\r\n\r\n\r\n复制代码5、修改 ./src/pages/index/service.ts 里的接口请求还是依据之前的 getlist 接口import Api from '../../utils/request'\r\n\r\nexport const getList = (data) => {\r\n\r\n  return Api.getList(data)\r\n\r\n}\r\n  \r\n\r\n复制代码6、修改 ./src/pages/index/index.interface.ts 里的参数类型根据项目具体的参数，自行进行配置/**\r\n * index.state 参数类型\r\n * @interface IndexState\r\n */\r\nexport interface IndexState {\r\n\r\n}\r\n\r\n/**\r\n * index.props 参数类型\r\n *\r\n * @export\r\n * @interface IndexProps\r\n */\r\nexport interface IndexProps {\r\n    dispatch?: any,\r\n    data?: Array<DataInterface>\r\n}\r\n\r\nexport interface DataInterface {\r\n    des:string,\r\n    lunar:string,\r\n    thumbnail_pic_s:string,\r\n    title:string,\r\n    _id:string\r\n}\r\n\r\n复制代码7、修改 ./src/pages/index/model.ts 里 effects 函数在这里创建页面需要请求的接口，链接 service 里的接口发起数据请求,这里以 getList 为例。// import Taro from '@tarojs/taro';\r\nimport * as indexApi from './service';\r\n\r\nexport default {\r\n  namespace: 'index',\r\n  state: {\r\n    data:[],\r\n    v:'1.0',\r\n  },\r\n\r\n  effects: {\r\n    *getList({ payload },{select, call, put}){\r\n      const { error, result} = yield call(indexApi.getList,{\r\n        ...payload\r\n      })\r\n      console.log('数据接口返回',result);\r\n      \r\n      if (!error) {\r\n        yield put({\r\n          type: 'save',\r\n          payload: {\r\n            data:result.data\r\n          },\r\n        })\r\n      }\r\n    }\r\n  },\r\n\r\n  reducers: {\r\n    save(state, { payload }) {\r\n      return { ...state, ...payload };\r\n    },\r\n  }\r\n\r\n}\r\n\r\n复制代码8、修改 ./src/pages/index/index.tsx 里页面结构这里简单的实现列表新闻页面。import Taro, { Component, Config } from '@tarojs/taro'\r\nimport { View, Text} from '@tarojs/components'\r\nimport { connect } from '@tarojs/redux'\r\n// import Api from '../../utils/request'\r\n// import Tips from '../../utils/tips'\r\nimport { IndexProps, IndexState } from './index.interface'\r\nimport './index.scss'\r\n// import {  } from '../../components'\r\n\r\n@connect(({ index }) => ({\r\n    ...index,\r\n}))\r\n\r\nclass Index extends Component<IndexProps,IndexState > {\r\n  config:Config = {\r\n    navigationBarTitleText: 'taro_dva_typescript'\r\n  }\r\n  constructor(props: IndexProps) {\r\n    super(props)\r\n    this.state = {}\r\n  }\r\n\r\n  async getList() {\r\n    await this.props.dispatch({\r\n      type: 'index/getList',\r\n      payload: {}\r\n    })\r\n  }\r\n\r\n  componentDidMount() {\r\n    this.getList()\r\n  }\r\n\r\n  render() {\r\n    const { data } = this.props\r\n    console.log('this.props===>>',data);\r\n    \r\n    return (\r\n      <View className='fx-index-wrap'>\r\n          <View className='index-topbar'>New资讯</View>\r\n          <View className='index-data'>\r\n            {\r\n              data && data.map((item,index) => {\r\n                return (\r\n                  <View className='index-list' key={index}>\r\n                    <View className='index-title'>{item.title}</View>\r\n                    <View className='index-img' style={`background-image: url(${item.thumbnail_pic_s})`}></View>\r\n                  </View>\r\n                )\r\n              })\r\n            }\r\n          </View>\r\n      </View>\r\n    )\r\n  }\r\n}\r\n\r\nexport default Index\r\n\r\n\r\n复制代码9、修改 ./src/pages/index/index.scss 首页的样式这里的写法是 sass 的语法糖@import \"../../assets/scss/variables\";\r\n\r\n.#{$prefix} {\r\n\r\n  &-index-wrap {\r\n    width: 100%;\r\n    min-height: 100vh;\r\n    .index {\r\n      &-topbar {\r\n        padding: 10rpx 50rpx;\r\n        text-align: center;\r\n        font-weight: bold;\r\n        color: #333;\r\n        font-size: 30rpx;\r\n      }\r\n  \r\n      // &-data {\r\n      // }\r\n       \r\n      &-title {\r\n        font-size: 28rpx;\r\n        color: #666;\r\n        width: 100%;\r\n        font-weight: bold;\r\n      }\r\n      &-list{\r\n        border-bottom: 1rpx solid #eee;\r\n        padding-bottom: 20rpx;\r\n        margin: 20rpx 24rpx;\r\n        display: flex;\r\n        flex-direction: row;\r\n        justify-content: space-between;\r\n        align-items: center\r\n      }\r\n  \r\n      &-img {\r\n        width: 70%;\r\n        height: 200rpx;\r\n        background-repeat: no-repeat;\r\n        background-size: contain;\r\n        background-position: right center;\r\n      }\r\n    }\r\n  }\r\n \r\n}\r\n\r\n\r\n复制代码项目启动运行小程序编译命令cnpm run dev:weapp等待项目编译完成，会在项目根目录下生成一个 dist ,打开微信小程序开发者根据，导入本地刚刚生成的 dist 文件，就成功启动了项目。效果预览图：如有啥问题欢迎讨论，共同学习。项目示例Github地址： github.com/Duanruilong…"}
{"title": "基于 Vue 的小程序开发框架性能优化实践---去除 VNode ", "author": "Rolan", "put_time": "2019-7-30 00:41", "content": "为了提高小程序的开发效率，我们团队开发了Mars 框架，可以使用 Vue 语法开发小程序，同时支持编译到 H5。近期我们进行了 Mars 框架的性能升级（0.3.x 版本），极大简化了 Vue 的 render 过程，去掉了 VNode 构建，省略了 patch 过程，从而获得了性能提升。\r\n\r\nMars 框架原理简介，为什么要去除 VNode？\r\n为了方便大家理解，这里简单说一下 Mars 框架的原理，目前基于 Vue 的小程序开发框架原理差异不大。\r\n\r\n详细的原理大家可以看这篇文章：Mars - 又双叒叕一个多端开发框架？这次是 Vue 驱动，能完美适配 H5\r\n\r\nMars 的原理如下图所示：\r\n\r\n上图中，左半部分表示小程序的执行部分。粉红色区域代表小程序视图，蓝色部分代表小程序的逻辑执行部分，视图与逻辑之间交换的是数据和事件。右边绿色部分是我们在小程序逻辑之外，单独创建的 Vue 实例。小程序逻辑（蓝色部分）与 Vue 实例（绿色部分）是以如下方式工作的：\r\n\r\n在小程序的 Page 创建时，我们会同步 new 一个 Vue 实例。\r\n在 Vue 实例的 .$mp.scope 变量中绑定小程序实例，小程序实例中也会使用 .$vue 变量来绑定 Vue 实例，用于后续的数据传递。\r\n使用 handleProxy 方法代理小程序中的事件，当小程序事件发生时，对应执行 Vue 实例中相应的 Method。\r\n页面中的逻辑执行在 Vue 部分，每当 Vue 的视图更新时，在 Updated 阶段将数据的变化使用 setData 方法同步给小程序实例，触发小程序视图的刷新。\r\n\r\n可以看到优化前我们基本保留了 Vue 的所有渲染过程，只是删除了 Vue 中的 DOM 操作部分。由于 Vue 实例与小程序之间交换的只有数据，因此 Vue 中的视图层其实是没有用到的。\r\n我们需要的只是执行 Vue 中的逻辑，判断数据修改是否会造成视图更新，视图更新时把变化的数据同步给小程序。而 Vue 视图层相关的内容，VNode、render、patch 这些很多是没有必要的，我们的想法是通过精简不必要的操作来提升性能。\r\n优化前 render 和 patch 过程所起的作用\r\n想要精简 render 和 patch，我们就需要先搞清楚 render 和 patch 在 Vue 中起到了什么作用：\r\n\r\n在 Vue 中，当数据发生变化时，会通知视图渲染依赖这一数据的所有实例，依次执行这些实例的 render 函数，这次 render 函数执行过程中又会重新收集依赖，用于下一次数据发生变化时的依赖追踪。\r\nrender 函数执行后会返回一个该实例对应的 VNode 树，render 过程中并不会创建子组件实例，仅仅是生成了一个占位符。这个 VNode 树随后会传递给 patch 过程。\r\npatch 过程会将当前 VNode 树与旧 VNode 树进行 diff，之后根据 diff 创建、销毁子组件实例，修改 DOM 完成渲染。\r\n\r\n在小程序框架这个情境下，我们需要的是 数据依赖追踪 和 组件实例创建、销毁，其他部分的内容则可以进行删减。\r\n我们可以精简哪些内容？\r\n\r\nrender 函数部分，我们只需要进行必要的依赖追踪，不需要创建 VNode 节点。\r\npatch 部分，由于没有 VNode 了，我们也不需要进行耗时的 diff 操作了！\r\n\r\n但是等一下，没有了 VNode 树，如何创建组件实例呢？我们将子组件的 Vue 实例创建改到了小程序子组件的生命周期中，也就是说单个 Vue 实例只会创建它自己，不会在继续创建子组件实例。\r\n之前的结构为小程序实例树和 Vue 实例树，组件实例间互相绑定。现在的结构变为只有小程序实例树，每个小程序实例节点单独对应一个 Vue 实例。\r\n开始实践！\r\n下面介绍一下我们具体做了哪些内容。\r\ncreateComponent 中创建 Vue 实例\r\n由于把 patch 过程干掉了，因此我们需要手动创建子组件的 Vue 实例，同 Page 一样，我们在 Component 的生命周期函数中 new 一个 Vue 实例，并与当前小程序实例绑定：\r\nthis.$vue = new VueComponent(options);\r\nthis.$vue.$mp = {\r\n    scope: this\r\n};\r\n复制代码在组件中创建 Vue 实例时，之前 Vue 中的父子关系没有了，维护这一关系需要解决以下问题：父元素绑定、properties 传递。\r\n父元素绑定\r\n在 patch 过程中，Vue 创建子组件时会传递以下三个参数：\r\nconst options: InternalComponentOptions = {\r\n    _isComponent: true,\r\n    _parentVnode: vnode,\r\n    parent\r\n}\r\n复制代码\r\n_isComponent 用于优化 options 的合并，我们可以直接设置成 true。\r\n_parentVnode 用于在 render 过程中获取父元素信息，例如 scope-slot 等，由于我们已经把 VNode 删掉了，因此不再需要了。\r\nparent 用于获取根元素、绑定 $children 等操作，Vue 就是通过这个参数来维护实例间的父子关系的。\r\n\r\n我们需要找到当前 Vue 实例的父实例，作为 parent 参数，从而完成父元素绑定过程。\r\n小程序当前没有机制来直接获取父元素，需要我们自己想办法来查找。在之前开发 Mars 过程中，为了进行小程序组件实例和 Vue 组件实例间的匹配，对小程序实例树和 Vue 实例树中的组件节点都进行了标记，现在不需要进行实例间匹配查找了，但是我们可以通过这个标记来查找父元素。\r\n\r\n由于 Page 元素可能在同一时间不唯一（由于页面切换），因此每创建一个 Page 实例，都需要绑定一个唯一的 rootUID，我们将其存储在了getApp().__pages__中。rootUID 会逐层传给每个小程序自定义组件实例。\r\n每次有小程序自定义组件实例创建，我们都将该实例以标记的 id 为 key 存储在 getApp().__pages__[rootUID].__vms__中。\r\n根据 rootUID 找到根元素，进而找到 page 中的 __vms__。\r\n根据 compId 算出父实例的 compId。\r\n根据父实例的 compid从__vms__中找到父元素，作为 parent。\r\n\r\nproperties 传递\r\n除了需要设置的初始化属性外，我们还需要传递子组件的 properties，否则父元素的数据没办法传递给子组件。\r\n\r\n\r\n数据初始化：可以在 Vue 创建时传入 propsData 来作为 props 的初始数据。\r\n由于小程序自定义组件的参数和 Vue 子组件实例的参数是相同的，因此我们可以直接将程序自定义组件的参数作为propsData在 new Vue 时传入：\r\nconst options = {\r\n    mpType: 'component',\r\n    mpInstance: this,\r\n    propsData: properties,\r\n    parent\r\n};\r\n\r\n// 初始化 vue 实例\r\nthis.$vue = new VueComponent(options);\r\n复制代码\r\n\r\n数据更新：仿照 Vue 给子组件传参数的机制，每次 render 时，将 props 重新给子组件赋值一遍。\r\n\r\n\r\n\r\n只需要更新第一层，因为 properties 如果是对象，那么它在父元素中已经做过变化追踪了。\r\n\r\n事件传递\r\n对于 template 上绑定的事件，由于我们本身已经使用了 handleProxy 来处理，因此不会受到影响。\r\n需要处理的是 .$emit、.$on 方法。\r\n\r\n对于 .$emit，我们利用小程序机制，使用 triggerEvent 在小程序层面给父元素传递事件。\r\n对于 .$on，使用 Vue 现成的机制就好，不需要做额外工作，不过这也造成 Vue 的事件机制不能删除。\r\n\r\n\r\n这里有个小坑：triggerEvent 方法传递的参数，需要从 event.detail 中获取，Mars 兼容了这个 diff。\r\n\r\nrender 函数精简\r\nrender 函数目前我们不能完全删除，因为需要以下两个功能：依赖收集、复杂表达式和filter 计算。\r\n依赖收集\r\nVue 在初始化时会对实例上的 data 进行响应式处理，设置 set 和 get 方法。组件执行 render 函数时，会读取变量触发 get 方法，从而在 get 方法中将当前实例收集为这个数据的依赖。下次数据更新时 Vue 会通知依赖进行更新。\r\n为了收集依赖，我们需要在 render 函数中读取一遍数据。这里我们将 VNode 树编译为数组树的形式，只留下数据，剩下的内容都可以删除。\r\n比如这样的一个 template:\r\n<template>\r\n    <view class=\"hello\">\r\n        <view @tap=\"tapHandler\">\r\n            <text>https://github.com/max-team/Mars</text>\r\n        </view>\r\n        <view>{{ aaa }}</view>\r\n        <view>{{ ccc }}</view>\r\n        <name :name=\"nameOutter\"></name>\r\n        <view>{{ aaaComp }}</view>\r\n    </view>\r\n</template>\r\n复制代码Vue 产出的 render 函数是这样的：\r\n// 修改前的 render 函数\r\n_c('view',{staticClass:\"hello\"},[_c('view',{on:{\"tap\":_vm.tapHandler}},[_c('text',[_vm._v(\"https://github.com/max-team/Mars\")])]),_c('view',[_vm._v(_vm._s(_vm.aaa))]),_c('view',[_vm._v(_vm._s(_vm.ccc))]),_c('name',{attrs:{\"name\":_vm.nameOutter,\"compId\":(_vm.compId ? _vm.compId : '$root') + ',0'}}),_c('view',[_vm._v(_vm._s(_vm.aaaComp))])],1)\r\n复制代码精简后我们得到的 render 函数是这样的：\r\n// 修改后的 render 函数\r\n[,[,,[(_vm.aaa)],,[(_vm.ccc)],,[[_vm.nameOutter,(_vm.compId ? _vm.compId : '$root') + ',0']],,[(_vm.aaaComp)]]]\r\n复制代码可以看到 Vue 中的大量 render helper 掉用，例如 _c、_v、_s 等都可以省略了。\r\n\r\n有些 render helper 还是不能去掉，例如 v-for 循环，我们还是保留了 _l 函数，因为 v-for 循环的对象可能为数组、字符串、数字等多种情况。\r\n\r\n复杂表达式和filter 计算。\r\n在 Vue 的 template 中，是可以像 js 一样执行很多计算的，比如可以执行定义好的 method：\r\n<div :prop=\"someMethod(data)\"></div>\r\n复制代码或者执行一个 filter\r\n<div :prop=\"someMethod | someFilter\"></div>\r\n复制代码这部分的计算之前是在 render 中随着 VNode 构建执行的，计算结果存储在了 VNode 节点中。现在我们没有 VNode 了，计算出的值怎么办呢？\r\n\r\n计算复杂表达式和 filter 的过程还在 render 过程中保留。\r\n计算出的值使用 _ff 方法包裹。每个计算值产生一个唯一的 id，_ff 方法将这些值按照 id 存储下来 setData 给小程序，小程序直接使用这些计算结果来进行渲染。\r\n\r\npatch 过程\r\npatch 过程已经完全不需要了，我们将这一过程完全删除。\r\n顺带解决的一个坑\r\n在之前的方案中，从 Page 开始创建的小程序组件实例树，与 Vue 组件实例树是相互独立的。为了让小程序组件实例与 Vue 组件实例之间能够对应上（否则无法在组件级别 setData），我们需要对每个组件实例进行标记，通过标记来寻找对应关系。这在一些特殊情景下是会有问题的，例如组件快速生成又销毁等，造成实例间不匹配。\r\n修改后的方案由于 Vue 实例是以组件级别创建的了，因此不再会出现实例无法匹配的情况。\r\n结果和总结\r\n我们使用了线上业务进行验证，渲染时间 -16%。此外，由于我们精简了 Vue 的功能，删除了这部分功能的代码，框架整体的体积也减少了 11%。"}
{"title": "电视剧看多了，就想仿个爱奇艺小程序 ", "author": "Rolan", "put_time": "2019-8-1 00:33", "content": "听说讲正文前，都喜欢先唠会嗑，咱们先聊个五毛钱的，不知道大家最近有没有看啥电视剧，比如，emmmmm，《亲爱的，热爱的》(斜眼笑)(好的假装你们看过了，咱们可以接着聊了)。哇，杨紫小猴子超甜的有没有，老夫的少女心，比吃了蜜还甜，李现大概或许可能maybe比我帅那么一丢丢，就一丢丢(是在下不要脸了，请忽略上面这句话谢谢！！！)。用爱奇艺看多了，就想仿个爱奇艺小程序来练练手(那是因为爱奇艺APP那玩意儿暂时还仿不出来)，虽说自己比较菜，写的不怎么样，但是咱们搞技术的，总得折腾一下嘛，有兴趣的东西就应该撸一个出来。好了五毛钱的聊完了，该讲正题了，还想聊天的再加五毛，一块也行，在座的各位都是大佬，多多指点一下下哈!蟹蟹蟹蟹。\r\n效果展示\r\n\r\n\r\n\r\n项目前准备\r\n\r\nVS Code\r\n微信web开发者工具以及它的云开发\r\n微信开放文档\r\neasymock\r\nVant Weapp\r\niconfont\r\n还有就是数据，有点伤感难过，数据自己在爱奇艺官网一个个找的，所以小程序里面的数据有一(da)部分是重复的，咱也不敢说，咱也不敢问(等我学会了爬虫，再去爬你几千条数据解解气)\r\n\r\n项目界面\r\n首页\r\n\r\n首页长成这个样子，一眼看过去还是挺好写的，布局什么的都比较有规律，对于小白来说还是很友善的，没有花里胡哨的排列。头部用的是小程序官方的swiper组件,炒鸡好用。不过有一点就是，轮播图的指示点一般都是在中间靠下面一点，而正好这里有文字，会重叠，没有绿色的指示点(爱奇艺偏爱环保健康的green)又不好看，脑壳疼，咋办？加几行css就行了。\r\n.wx-swiper-dots {\r\n  position: relative;\r\n  left: unset !important;\r\n  right: -40rpx;\r\n}\r\n.wx-swiper-dots.wx-swiper-dots-horizontal {\r\n  margin-bottom: -5rpx;\r\n}\r\n复制代码left不是可继承的样式，unset了之后，就相当于重置掉了，就可以开开心心的把指示点的位置换掉了。\r\n下面基本上就是一个  wx:for能解决的事情，对于这样的布局，用flex是再好不过的了，简单方便又快捷，顺便给大家推荐一篇详细讲解flex的文章，看了说不定你也会收获一些东西。\r\n\r\nwxml\r\n<!-- miniprogram/pages/homepage/homepage.wxml -->\r\n<view class=\"homePage\">\r\n  <view class=\"head\">\r\n    <swiper indicator-dots=\"{{indicatorDots}}\" autoplay=\"{{autoplay}}\" interval=\"{{interval}}\" duration=\"{{duration}}\" indicator-color=\"{{indicatorColor}}\" indicator-active-color=\"{{indicatorActiveColor}}\" circular=\"{{circular}}\">\r\n      <block wx:for=\"{{imgUrl}}\" wx:key=\"{{index}}\">\r\n        <view bindtap=\"navigate\" data-set=\"{{item}}\">\r\n          <swiper-item>\r\n            <image src=\"{{item.img}}\" mode=\"aspectFill\" class=\"slide-image\"></image>\r\n            <view class=\"desc\">{{item.desc}}</view>\r\n          </swiper-item>\r\n        </view>\r\n      </block>\r\n    </swiper>\r\n    <view class=\"header\">\r\n      <image class=\"iqiyi\" src=\"{{iqiyi}}\" mode=\"widthFix\" />\r\n      <view class=\"name\">{{headerName}}</view>\r\n      <view class=\"searchBox\" bindtap=\"toSearch\">\r\n        <icon class=\"iconSearch\" type=\"search\" size=\"15\" color=\"rgb(47,244,44)\"></icon>\r\n        <view class=\"searchName\">{{searchName}}</view>\r\n      </view>\r\n    </view>\r\n  </view>\r\n  <view class=\"content\">\r\n    <view class=\"contentVideoes\" wx:for=\"{{videoes}}\" wx:key=\"index\">\r\n      <!-- 板块标题 -->\r\n      <view class=\"title\">{{item.listTitle}}</view>\r\n      <!-- 板块内容，四个内容 -->\r\n      <view class=\"contain\">\r\n        <view class=\"video\" wx:for=\"{{item.videoList}}\" wx:key=\"index\" bindtap=\"navigate\" data-set=\"{{item}}\">\r\n          <view class=\"topPart\">\r\n            <image class=\"img\" src=\"{{item.img}}\" mode=\"widthFix\" />\r\n            <view class=\"count\">{{item.count}}</view>\r\n            <view class=\"vip\" wx:if=\"{{item.vip}}\">VIP</view>\r\n          </view>\r\n          <view class=\"downPart\">\r\n            <view class=\"videoTitle\">{{item.title}}</view>\r\n            <view class=\"videoDesc\">{{item.desc}}</view>\r\n          </view>\r\n        </view>\r\n      </view>\r\n    </view>\r\n  </view>\r\n</view>\r\n复制代码wxss\r\n/* miniprogram/pages/homepage/homepage.wxss */\r\n.homePage {\r\n  width: 100%;\r\n}\r\n.homePage .head {\r\n  position: relative;\r\n  width: 100%;\r\n}\r\n.homePage .head .slide-image {\r\n  width: 100%;\r\n}\r\n.homePage .head .desc {\r\n  position: absolute;\r\n  left: 20rpx;\r\n  bottom: 30rpx;\r\n  font-weight: bold;\r\n  font-size: 35rpx;\r\n  color: #ffffff\r\n}\r\n.homePage .head .header {\r\n  width: 100%;\r\n  position: absolute;\r\n  top: 10rpx;\r\n  left: 10rpx;\r\n  display: flex\r\n}\r\n.homePage .head .header .iqiyi {\r\n  width: 75rpx;\r\n  display: inline-block;\r\n  top: 20rpx;\r\n  left: 10rpx;\r\n  margin: auto\r\n}\r\n.homePage .head .header .name {\r\n  font-size: 30rpx;\r\n  color: #2BFA39;\r\n  font-weight: bold;\r\n  display: inline-block;\r\n  margin: auto\r\n}\r\n.homePage .head .header .searchBox {\r\n  flex: 1;\r\n  background-color: rgba(255,255,255,0.5);\r\n  border-radius: 42rpx;\r\n  margin: auto 30rpx;\r\n  height: 60rpx;\r\n  position: relative;\r\n}\r\n.homePage .head .header .searchBox .iconSearch {\r\n  margin: auto 20rpx;\r\n  position: absolute;\r\n  top: 50%;\r\n  left: 20%;\r\n  transform: translate(-50%,-50%)\r\n}\r\n.homePage .head .header .searchBox .searchName {\r\n  display: inline-block;\r\n  font-size: 30rpx;\r\n  color: #ffffff;\r\n  margin-left: 50%;\r\n  transform: translate(-50%,0)\r\n}\r\n\r\n\r\n.homePage .content {\r\n  width: 100%;\r\n}\r\n.homePage .content .contentVideoes {\r\n  padding-right: 15rpx;\r\n}\r\n.homePage .content .contentVideoes .title {\r\n  font-size: 35rpx;\r\n  font-weight: bold;\r\n  margin: 25rpx 0 25rpx 25rpx;\r\n}\r\n.homePage .content .contentVideoes .contain {\r\n  width: 100%;\r\n}\r\n.homePage .content .contentVideoes .contain .video {\r\n  display: inline-block;\r\n  width: 50%;\r\n  margin-bottom: 10px;\r\n  padding-left: 15rpx;\r\n  box-sizing: border-box\r\n}\r\n.homePage .content .contentVideoes .contain .video .topPart {\r\n  position: relative;\r\n}\r\n.homePage .content .contentVideoes .contain .video .topPart .img {\r\n  display: block;\r\n  width: 100%; \r\n}\r\n.homePage .content .contentVideoes .contain .video .topPart .count {\r\n  position: absolute;\r\n  right: 15rpx;\r\n  bottom: 15rpx;\r\n  font-size: 25rpx;\r\n  color: #fff;\r\n}\r\n.homePage .content .contentVideoes .contain .video .topPart .vip {\r\n  position: absolute;\r\n  top: 0rpx;\r\n  right: 20rpx;\r\n  font-size: 25rpx;\r\n  background-color: #E1B876;\r\n  color: #FFF;\r\n  padding: 0rpx 10rpx 5rpx;\r\n  border-radius: 0 0 10rpx 10rpx;\r\n}\r\n.homePage .content .contentVideoes .contain .video .downPart {\r\n  padding-right: 10rpx;\r\n}\r\n.homePage .content .contentVideoes .contain .video .downPart .videoTitle {\r\n  font-size: 30rpx;\r\n  font-weight: bold;\r\n  margin-bottom: 15rpx;\r\n  overflow:hidden;\r\n  text-overflow:ellipsis;\r\n  white-space: nowrap;\r\n}\r\n.homePage .content .contentVideoes .contain .video .downPart .videoDesc {\r\n  font-size: 25rpx;\r\n  margin-bottom: 20rpx;\r\n  color: #999;\r\n  overflow: hidden;\r\n  text-overflow:ellipsis;\r\n  white-space: nowrap;\r\n}\r\n.wx-swiper-dots {\r\n  position: relative;\r\n  left: unset !important;\r\n  right: -40rpx;\r\n}\r\n\r\n.wx-swiper-dots.wx-swiper-dots-horizontal {\r\n  margin-bottom: -5rpx;\r\n}\r\n复制代码热点页\r\n\r\n小程序家的video组件，瞄一分钟文档，就能上手了。暖暖的，很贴心。\r\n<video src=\"{{ item.video}}\" duration=\"{{item.duration }}\" object-fit=\"cover\" id=\"{{ item.id}}\"  bindtap=\"handleVideoPlay\" data-vid=\"{{item.id}}\" ></video>\r\n复制代码小红心的切换则是根据从云数据库中取得的数据,动态切换。\r\n<image src='{{item.isLike ? likeStar : star}}' class='littleStar' mode='aspectFit'></image>\r\n复制代码视频下面的布局就让万能的flex来解决叭。所以我决定送flex一朵花花。\r\n\r\nwxml\r\n<!-- miniprogram/pages/hot/hot.wxml -->\r\n<view class='hotVideo'>\r\n  <view class='video' wx:for=\"{{entities}}\" wx:key=\"id\" data-index=\"{{index}}\">\r\n    <video src=\"{{ item.video}}\" duration=\"{{item.duration }}\" object-fit=\"cover\" id=\"{{ item.id}}\"  bindtap=\"handleVideoPlay\" data-vid=\"{{item.id}}\" ></video>\r\n    <view class='title'>{{item.description}}</view>\r\n    <!-- 视频下面的用户信息以及视频热度和分享按钮,用一个盒子来包裹这些信息 -->\r\n    <view class='infor'>\r\n      <view class=\"infor-left\">\r\n        <image src='{{item.userAvatar}}' class='userAvatar' mode=\"aspectFit\"></image>\r\n        <view class='userNickName'>{{item.userNickName}}</view>\r\n      </view>\r\n      <view class=\"infor-right\">\r\n        <view class='star' bindtap=\"wxLike\" data-index=\"{{index}}\" >\r\n          <image src='{{item.isLike ? likeStar : star}}' class='littleStar' mode='aspectFit'></image>\r\n          <view class='hotStar'>{{item.star}}</view>\r\n        </view>\r\n        <view class='share' bindtap=\"wxShare\">\r\n          <image src='{{weixin}}' class='wxLogo' mode='aspectFit'></image>\r\n          <view class='wxshare'>分享</view>\r\n        </view>\r\n      </view>\r\n    </view>\r\n  </view>\r\n  <van-notify id=\"van-notify\" />\r\n  <van-toast id=\"van-toast\" />\r\n</view>\r\n复制代码wxss\r\n/* miniprogram/pages/hot/hot.wxss */\r\n.hotVideo {\r\n  width: 100%;\r\n}\r\n.hotVideo .video {\r\n  position: relative;\r\n}\r\n.hotVideo .video video{\r\n  width: 100%;\r\n  z-index: 5;\r\n}\r\n.hotVideo .video .title {\r\n  position: absolute;\r\n  top: 20rpx;\r\n  left: 20rpx;\r\n  z-index: 10;\r\n  color: #fff;\r\n  font-size: 36rpx;\r\n  font-weight: bold;\r\n}\r\n.hotVideo .video .infor{\r\n  height: 125rpx;\r\n  position: relative;\r\n  display: flex;\r\n}\r\n.hotVideo .video .infor .infor-left {\r\n  height: 100%;\r\n  display: flex;\r\n}\r\n.hotVideo .video .infor .infor-left .userAvatar {\r\n  width: 75rpx;\r\n  height: 75rpx;\r\n  margin: 20rpx 15px 30rpx 30rpx;\r\n  border-radius: 50%;\r\n  display: inline-block;\r\n}\r\n.hotVideo .video .infor .infor-left .userNickName {\r\n  display: inline-block;\r\n  line-height: 125rpx;\r\n  font-size: 30rpx;\r\n  font-weight: bold;\r\n}\r\n.hotVideo .video .infor .infor-right {\r\n  flex: 1;\r\n  height: 100%;\r\n}\r\n.hotVideo .video .infor .infor-right .star {\r\n  width: 150rpx;\r\n  height: 60rpx;\r\n  border: 1px solid #DDD;\r\n  border-radius: 42rpx;\r\n  position: absolute;\r\n  top: 0;\r\n  bottom: 0;\r\n  margin: auto;\r\n  right: 30%;\r\n  display: flex;\r\n}\r\n.hotVideo .video .infor .infor-right .star .littleStar {\r\n  width: 40rpx;\r\n  height: 60rpx;\r\n  margin: auto 15rpx 20rpx;\r\n  float: left;\r\n  align-items: center\r\n}\r\n.hotVideo .video .infor .infor-right .star .hotStar {\r\n  line-height: 60rpx;\r\n  font-size: 30rpx;\r\n}\r\n.hotVideo .video .infor .infor-right .share {\r\n  width: 150rpx;\r\n  height: 60rpx;\r\n  border: 1px solid #DDD;\r\n  border-radius: 42rpx;\r\n  position: absolute;\r\n  top: 0;\r\n  bottom: 0;\r\n  margin: auto;\r\n  right: 5%;\r\n  display: flex;\r\n}\r\n.hotVideo .video .infor .infor-right .share .wxLogo {\r\n  width: 40rpx;\r\n  height: 60rpx;\r\n  margin: auto 15rpx 20rpx;\r\n  float: left;\r\n  align-items: center\r\n}\r\n.hotVideo .video .infor .infor-right .share .wxshare {\r\n  line-height: 60rpx;\r\n  font-size: 30rpx;\r\n}\r\n/* .hotVideo .video .infor{\r\n  height: 125rpx;\r\n  position: relative\r\n}\r\n.hotVideo .video .userAvatar {\r\n  width: 75rpx;\r\n  height: 75rpx;\r\n  float: left;\r\n  margin: 20rpx 15px 40rpx 30rpx;\r\n  border-radius: 50%;\r\n}\r\n.hotVideo .video .userNickName {\r\n  line-height: 125rpx;\r\n  font-size: 27rpx;\r\n  display: inline-block;\r\n}\r\n.hotVideo .video .infor .star {\r\n  width: 150rpx;\r\n  height: 60rpx;\r\n  border: 1px solid #DDD;\r\n  border-radius: 42rpx;\r\n  position: absolute;\r\n  top: 0;\r\n  bottom: 0;\r\n  margin: auto;\r\n  margin-left: 50%;\r\n  display: flex;\r\n}\r\n.hotVideo .video .infor .star .littleStar {\r\n  width: 40rpx;\r\n  height: 60rpx;\r\n  margin: auto 15rpx 20rpx;\r\n  float: left;\r\n  align-items: center\r\n}\r\n.hotVideo .video .infor .star .hotStar {\r\n  line-height: 60rpx;\r\n  font-size: 30rpx;\r\n}\r\n.hotVideo .video .infor .share {\r\n  width: 150rpx;\r\n  height: 60rpx;\r\n  border: 1px solid #DDD;\r\n  border-radius: 42rpx;\r\n  position: absolute;\r\n  top: 0;\r\n  bottom: 0;\r\n  margin: auto;\r\n  margin-left: 75%;\r\n  display: flex;\r\n}\r\n.hotVideo .video .infor .share .weixin {\r\n  width: 40rpx;\r\n  height: 60rpx;\r\n  margin: auto 15rpx 20rpx;\r\n  float: left;\r\n  align-items: center\r\n}\r\n.hotVideo .video .infor .share .wxshare {\r\n   line-height: 60rpx;\r\n   font-size: 30rpx;\r\n} */\r\n复制代码风云榜\r\n\r\n头部的横向滚动，在scroll-view标签上设置scroll-x为true，并且加上white-space:nowrap;就能实现横向滚动了。标签页用的是vant的tab标签页，就省下自己写原生标签页的功夫可以去写别的了，不过小白白可以有空手动写一个，不算很难的。\r\n\r\nwxml\r\n<!-- miniprogram/pages/ranking/ranking.wxml -->\r\n<view class=\"ranking\">\r\n  <!-- 风云榜头部的分类 -->\r\n  <view class=\"ranking-header\">\r\n    <!-- 滑动的部分 -->\r\n    <scroll-view class=\"header\" scroll-x=\"{{true}}\" scroll-left=\"{{scrollLeft}}\">\r\n      <view wx:for=\"{{headerList}}\" wx:key=\"index\" class=\"headerList {{currentIndex === index?'selected': ''}}\" data-index=\"{{index}}\" bindtap=\"selected\">\r\n        {{item}}\r\n      </view>\r\n    </scroll-view>\r\n    <!-- 箭头部分 -->\r\n    <view class=\"header-arrow\" bindtap='showAllSort'>\r\n      <view class=\" {{isShow ? 'down-arrow up-arrow': 'down-arrow'}} \"></view>\r\n    </view>\r\n    <!-- 导航栏部分 -->\r\n    <view wx:if=\"{{isShow}}\" class=\"{{isShow ? 'header-sort opacity' : ''}}\">\r\n      <van-transition name=\"fade-down\">\r\n        <view wx:for=\"{{headerList}}\" wx:key=\"index\" class='headerSort' data-index=\"{{index}}\" bindtap=\"selected\">\r\n          {{item}}\r\n        </view>\r\n      </van-transition>\r\n    </view>\r\n  </view>\r\n  <!-- 下面的排行榜部分 -->\r\n  <view class=\"ranking-container\">\r\n    <van-tabs active=\"{{ active }}\" animated>\r\n      <!-- 热度榜 -->\r\n      <van-tab title=\"热度榜\">\r\n        <!-- 包裹着一个影视信息的小盒子 -->\r\n        <view class=\"ranking-content\" wx:for=\"{{programs}}\" wx:key=\"{{index}}\">\r\n          <view class=\"ranking-list\" data-set=\"{{item}}\" bindtap=\"navigate\">\r\n            <!-- 左边的图片部分 -->\r\n            <view class=\"list-left\">\r\n              <image src=\"{{item.img}}\" mode='aspectFill' class='image' />\r\n              <view class=\"list-number\">{{index + 1}}</view>\r\n              <view class=\"list-vip\" wx:if=\"{{item.vip}}\">VIP</view>\r\n              <view class=\"list-count\">{{item.count}}</view>\r\n            </view>\r\n            <view class=\"list-right\">\r\n              <view class=\"list-title\">{{item.title}}</view>\r\n              <view class=\"list-desc\">{{item.desc}}</view>\r\n              <view class=\"list-hot\">热度 {{item.hot}}</view>\r\n            </view>\r\n          </view>\r\n        </view>\r\n      </van-tab>\r\n      <!-- 飙升榜 -->\r\n      <van-tab title=\"飙升榜\">\r\n        <!-- 包裹着一个影视信息的小盒子 -->\r\n        <view class=\"ranking-content\" wx:for=\"{{programs}}\" wx:key=\"{{index}}\">\r\n          <view class=\"ranking-list\" data-set=\"{{item}}\" bindtap=\"navigate\">\r\n            <!-- 左边的图片部分 -->\r\n            <view class=\"list-left\">\r\n              <image src=\"{{item.img}}\" mode='aspectFill' class='image' />\r\n              <view class=\"list-number\">{{index + 1}}</view>\r\n              <view class=\"list-vip\" wx:if=\"{{item.vip}}\">VIP</view>\r\n              <view class=\"list-count\">{{item.count}}</view>\r\n            </view>\r\n            <view class=\"list-right\">\r\n              <view class=\"list-title\">{{item.title}}</view>\r\n              <view class=\"list-desc\">{{item.desc}}</view>\r\n              <view class=\"list-hot\">热度 {{item.hot}}</view>\r\n            </view>\r\n          </view>\r\n        </view>\r\n      </van-tab>\r\n      <!-- 播放指数榜 -->\r\n      <van-tab title=\"播放指数榜\">\r\n        <!-- 包裹着一个影视信息的小盒子 -->\r\n        <view class=\"ranking-content\" wx:for=\"{{programs}}\" wx:key=\"{{index}}\">\r\n          <view class=\"ranking-list\" data-set=\"{{item}}\" bindtap=\"navigate\">\r\n            <!-- 左边的图片部分 -->\r\n            <view class=\"list-left\">\r\n              <image src=\"{{item.img}}\" mode='aspectFill' class='image' />\r\n              <view class=\"list-number\">{{index + 1}}</view>\r\n              <view class=\"list-vip\" wx:if=\"{{item.vip}}\">VIP</view>\r\n              <view class=\"list-count\">{{item.count}}</view>\r\n            </view>\r\n            <view class=\"list-right\">\r\n              <view class=\"list-title\">{{item.title}}</view>\r\n              <view class=\"list-desc\">{{item.desc}}</view>\r\n              <view class=\"list-hot\">热度 {{item.hot}}</view>\r\n            </view>\r\n          </view>\r\n        </view>\r\n      </van-tab>\r\n    </van-tabs>\r\n  </view>\r\n</view>\r\n复制代码wxss\r\n/* miniprogram/pages/ranking/ranking.wxss */\r\n.ranking {\r\n  position: absolute;\r\n  top: 0;\r\n  right: 0;\r\n  bottom: 0;\r\n  left: 0;\r\n}\r\n.ranking .ranking-header {\r\n  width: 100%;\r\n  height: 80rpx;\r\n  background-color: #F6F6F6;\r\n  border-bottom: 2rpx solid #E3E3E3;\r\n}\r\n.ranking .ranking-header .header {\r\n  width: 90%;\r\n  height: 100%;\r\n  white-space: nowrap;\r\n  overflow-x: auto;\r\n}\r\n/* .header::-webkit-scrollbar {\r\n  display: none;\r\n} */\r\n.ranking .ranking-header .header .headerList {\r\n  display: inline-block;\r\n  margin: 0rpx 25rpx;\r\n  text-align: center;\r\n  line-height: 80rpx;\r\n  \r\n}\r\n.ranking .ranking-header .header .headerList.selected {\r\n  color: green;\r\n}\r\n.ranking .ranking-header .header-arrow {\r\n  position: absolute;\r\n  right:0;\r\n  top:0;\r\n  overflow: hidden;\r\n  width: 80rpx;\r\n  height: 80rpx;\r\n  background-color: #F6F6F6;\r\n  border-left: 1px solid #E3E3E3\r\n}\r\n.ranking .ranking-header .header-arrow .down-arrow {\r\n  width: 25rpx;\r\n  height: 25rpx;\r\n  border-bottom: 2px solid #999;\r\n  border-right: 2px solid #999;\r\n  margin: 40rpx auto 0rpx;\r\n  transform: rotateZ(45deg) translate(-50%,-50%);\r\n  transition: transform 0.5s;\r\n}\r\n.ranking .ranking-header .header-arrow .down-arrow.up-arrow {\r\n  transform: rotateZ(-135deg) translate(25%,25%);\r\n}\r\n.ranking .ranking-header .header-sort {\r\n  width: 100%;\r\n  border-bottom: 1px solid #EFEFEF;\r\n  background-color: rgba(255, 255, 255,0.8);\r\n  position: absolute;\r\n  z-index: 5;\r\n  transition: opacity 3s;\r\n}\r\n\r\n.ranking .ranking-header .header-sort .headerSort {\r\n  width: 20%;\r\n  display: inline-block;\r\n  font-size: 25rpx;\r\n  text-align: center;\r\n  margin: 17rpx auto;\r\n  opacity: 0.8;\r\n}\r\n.ranking .ranking-container {\r\n  width: 100%;\r\n}\r\n.ranking .ranking-container .ranking-content {\r\n  width: 100%;\r\n}\r\n.ranking .ranking-container .ranking-content .ranking-list {\r\n  display: flex;\r\n}\r\n.ranking .ranking-container .ranking-content .ranking-list .list-left {\r\n  display: inline-block;\r\n  margin: 20rpx;\r\n  position: relative;\r\n}\r\n.ranking .ranking-container .ranking-content .ranking-list .list-left .image {\r\n  width: 270rpx;\r\n  height: 150rpx;\r\n}\r\n.ranking .ranking-container .ranking-content .ranking-list .list-left .list-number {\r\n  position: absolute;\r\n  left: 0rpx;\r\n  top: 0rpx;\r\n  font-size: 35rpx;\r\n  background-color: #FC2932;\r\n  width: 45rpx;\r\n  height: 45rpx;\r\n  padding-right: 10rpx;\r\n  text-align: center;\r\n  border-radius: 0 5rpx 45rpx 0;\r\n}\r\n.ranking .ranking-container .ranking-content .ranking-list .list-left .list-vip {\r\n  position: absolute;\r\n  top: 0rpx;\r\n  right: 5rpx;\r\n  font-size: 25rpx;\r\n  background-color: #E1B876;\r\n  color: #FFF;\r\n  padding: 0rpx 10rpx 5rpx;\r\n  border-radius: 0 0 10rpx 10rpx;\r\n}\r\n.ranking .ranking-container .ranking-content .ranking-list .list-left .list-count {\r\n  position: absolute;\r\n  right: 20rpx;\r\n  bottom: 20rpx;\r\n  font-size: 20rpx;\r\n  color: #fff;\r\n}\r\n.ranking .ranking-container .ranking-content .ranking-list .list-right {\r\n  display: inline-block;\r\n  position: relative;\r\n  top: 15rpx;\r\n  padding: 10rpx;\r\n  white-space: nowrap;\r\n  text-overflow: ellipsis;\r\n  overflow: hidden;\r\n  flex: 1;\r\n}\r\n.ranking .ranking-container .ranking-content .ranking-list .list-right .list-title {\r\n  font-size: 30rpx;\r\n  font-weight: bold;\r\n  margin-bottom: 15rpx;\r\n  overflow:hidden;\r\n}\r\n.ranking .ranking-container .ranking-content .ranking-list .list-right .list-desc {\r\n  font-size: 30rpx;\r\n  margin-bottom: 20rpx;\r\n  color: #999;\r\n  overflow: hidden;\r\n  text-overflow:ellipsis;\r\n}\r\n.ranking .ranking-container .ranking-content .ranking-list .list-right .list-hot {\r\n  font-size: 25rpx;\r\n  color: #999\r\n}\r\n复制代码还有几个页面比较简单，就不介绍了。\r\n\r\n功能的实现\r\n高亮模糊查询\r\n\r\n这里我只是实现了一个简单版的模糊查询，也参考了一下网上的思路(好吧是我太菜了)，毕竟有问题就找度娘嘛。实时获取到输入框中的文字value，用filter和include方法筛选出包含value的名字，放入filter_list数组中,再遍历filter_list数组，将其中的字段切分为三段，然后就是这样的\r\n\r\n当value和其中的一项相等时，就改变颜色，怎么样，是不是还挺简单的\r\nonChange(event) {\r\n    const list = this.data.allName;//这里是所有的名字\r\n    const value = event.detail; //实时获取输入框中的文字\r\n    const result = [] \r\n    if (event.detail !== '') {//当输入框中有文字的话，就筛选出含有value的名字\r\n      let filter_list = [...new Set(//用Set是因为我的数据中有重复的字段\r\n        list.filter(item => {\r\n          return item.includes(value)\r\n        })\r\n      )]\r\n      filter_list.forEach(item => {//遍历\r\n      // 将名字切割成三段放入数组中，和value一样的字段的就换个颜色\r\n        let index1 = item.indexOf(value)\r\n        let index2 = value.length\r\n        let string1 = item.slice(0, index1)\r\n        let string2 = item.slice(index1, index1 + index2)\r\n        let string3 = item.slice(index1 + index2)\r\n        console.log([string1, string2, string3])\r\n        result.push([string1,string2,string3])\r\n      })\r\n      this.setData({\r\n        value,\r\n        result\r\n      })\r\n    } else {\r\n      this.setData({\r\n        result: null\r\n      })\r\n    }\r\n  },\r\n复制代码<!-- 这里是搜索到的结果 -->\r\n  <view class=\"results\">\r\n    <view class=\"result\" wx:for=\"{{result}}\" wx:key=\"index\" bindtap=\"navigate\" data-name='{{item}}'>\r\n      <text  wx:for=\"{{item}}\" class=\"{{item == value ? 'highlight' : 'normal' }}\" wx:key=\"index\">{{item}}</text>  \r\n    </view>\r\n  </view>\r\n复制代码页面的带参跳转\r\n我给每个需要跳转的元素都绑定了设置了自定义属性data-*和用bind-tap绑定了navigate点击事件，方便在js中获取当前需要的信息,在跳转的时候用路由传参的形式将信息携带过去，JSON.stringify()方法可以将对象或者数组转换为一个 JSON字符串\r\n navigate(e) {\r\n    const dataSet = e.currentTarget.dataset.set;\r\n    const item = JSON.stringify(dataSet);\r\n    wx.navigateTo({\r\n      url: '../show/show?item=' + item\r\n    })\r\n  },\r\n复制代码然后在接收的时候使用JSON.parse()方法用来解析JSON字符串，构造由字符串描述的JavaScript值或对象。提供可选的reviver函数用以在返回之前对所得到的对象执行变换(操作).就可以在该显示的界面获取到信息了\r\nonLoad: function (options) {\r\n    const item = JSON.parse(options.item);\r\n    this.setData({\r\n      entities : item\r\n    })\r\n  },\r\n复制代码\r\n云数据库的增删改查\r\n这里大概是最让我崩溃的一个环节了，其中的辛酸苦辣(抹眼泪)，就是有句mmp不知当讲不当讲，同样的操作，上午不能执行成功，然后检查代码查bug翻文档，下午就能执行成功了，回头一看，我又没改代码，怎么就成功了呢，咋的，觉着我好欺负？\r\n\r\n添加数据和删除数据\r\nexports.main = async (event, context) => {\r\n  if(event.isAdd) {//idAdd是传过来的参数，为true时，往wxlike集合中添加字段\r\n    return db.collection('wxlike').add({\r\n      data: {\r\n        id: event.index,\r\n        Videoes:event.entity\r\n      }\r\n    })\r\n      .then(res => {\r\n        console.log(res)\r\n      })\r\n  } else {//isAdd为false时，根据id查到这个字段，然后删除\r\n    return db.collection('wxlike').where({\r\n      id: event.index\r\n    }).remove();\r\n  }\r\n}\r\n复制代码在iqiyi这个集合中根据name属性找到相应的字段并且获取id，再根据id去更新字段。\r\nexports.main = async (event, context) => {\r\n  let entities = await db.collection('iqiyi').where({\r\n    name: event.name\r\n  })\r\n  .get();\r\n  let id = entities._id;\r\n  return await db.collection('iqiyi').doc(id).update({\r\n    data: {\r\n      hotspot: {\r\n        videoes:event.entities\r\n      }\r\n    }\r\n  }).then(res => {\r\n  })\r\n}\r\n复制代码根据传过来的name属性从集合中查找数据\r\nexports.main = async (event, context) => {\r\n  \r\n  let entities = await db.collection('iqiyi').where({\r\n    name: event.name\r\n  })\r\n  .get()\r\n  return entities\r\n}\r\n复制代码看，数据库增删查改就这么几行代码就能搞定，真是幸福感爆棚。\r\n只能同时播放一个的视频\r\n在热点页，视频都是以单个video的形式存在,\r\n<video src=\"{{ item.video}}\" duration=\"{{item.duration }}\" object-fit=\"cover\" id=\"{{ item.id}}\"  bindtap=\"handleVideoPlay\" data-vid=\"{{item.id}}\" ></video>\r\n复制代码emmmmmm,这一段好像上面看过了，没事那就在看一遍吧。\r\n我们需要控制它不能同时播放两个视频，点击下一个视频时，上一个视频需要暂停掉，不然同时两个视频的声音播放，我觉得脑壳可能会炸掉。我们给每个video标签都绑定handleVideoPlay方法，并且设置自定义属性data-vid=\"{{item.id}}\"方便来获取他们的id来分别控制和播放\r\nhandleVideoPlay(e) {\r\n    if (this.data.currentVideo) {//currentVideo是当前播放的视频，初始值为null\r\n      this.data.currentVideo.pause();//如果存在currentVideo则停掉\r\n    }\r\n    const Vid = e.target.id;//获取点击的视频的id\r\n    if (Vid) {\r\n      // 创建 video 上下文 VideoContext 对象。\r\n      const currentVideo = wx.createVideoContext(`${Vid}`);\r\n      this.setData({\r\n        currentVideo\r\n      })\r\n      currentVideo.play();\r\n    }\r\n  },\r\n复制代码结语\r\n总体来看吧，这个demo主要是就是切页面，云数据库的操作和数据渲染了，呐呐呐，这是github地址,虽然页面和功能不多，在写的时候还是磕磕绊绊的遇到了各种各样的问题，不过最终还算是完成了。以后再接再厉鸭！！！最后祝看文章的小姐姐都能有杨紫小猴子辣么漂酿，，小哥哥都比李现现还帅，单身的程序猿都能找到像佟年和韩商言一般的好对象，蟹蟹蟹蟹啦，，留下个赞再走叭！！！"}
{"title": "小程序跨平台开发解决方案探索 ", "author": "Rolan", "put_time": "2019-8-2 00:15", "content": "原文地址： ant-move.github.io/website/blo…继微信正式推出微信小程序后，各个大厂陆续发布了各自的小程序平台 —— 支付宝小程序、百度小程序、头条小程序，跨小程序平台开发也成为了众多小程序开发者要面临的问题。Antmove - 小程序跨平台解决方案小程序开发血泪史小程序发展初期框架不稳定更新频繁bug 众多随着微信小程序的发展，微信小程序以基本不存在上述的问题，而其它新兴的小程序厂商则还在此阶段，对于小程序开发者来说，如果要接入微信小程序之外的平台，以上的问题是技术方案评估环境必须要衡量的问题。小程序发展中期开发体验提升组件式开发需求与 web 开发技术生态的融合在这个阶段，小程序开发者追求的是开发体验，在 web 框架蓬勃发展，开发工具生态飞速完善的环境下，槽糕的小程序开发体验是用户不能忍受的，这个阶段也出现了许多的小程序框架极力的解决这个问题，如 wepy、mpvue、taro 等。小程序发展成熟期多平台支持需求包体积性能到今年以来，除微信小程序平台外，其它厂商小程序平台也得到了极大的推动发展，这时小程序跨平台能力就显得尤为重要，同时与之相对的包体积控制小程序性能也成为关注点，这也是目前众多企业和开发者面临的问题。小程序跨平台开发解决方案探索小程序跨平台开发，简单来说就是通过一套解决方案实现开发一次，上线到多个小程序平台。解决方案为满足多小程序平台的需求，简单来说可以有以下的解决方案：各平台单独开发人力成本高开发某一个平台小程序，通过技术实现到其它平台的转换技术实现成本高，小团队难以支撑使用支持跨平台的小程序框架开发，依赖于框架的跨平台能力，实现跨平台引入框架成本对于第三种方案来说，目前社区中比较热门的小程序跨平台开发解决方案有 mpvue、taro、uni-app 等。这些框架不同程度的解决了小程序跨平台开发的问题，但他们都存在一个饱受诟病的问题，那就是框架之痛。在前端开发的发展过程中，从前端框架出现到百花争鸣，到现在的三足鼎立（Angular、React、Vue）时代，开发者依然会因如下的 问题而头疼：是否应该在项目中引入框架？应该选择什么样的框架，更好？更适合？在性能面前，应该选择框架还是采用原生开发？团队开发技术栈统一之争？老项目维护问题，技术升级之痛？该框架的未来发展是怎样的？作为小程序的开发者，依然会面临这样的问题，而且会更加严重， 小程序本身就是一个框架（而且小程序框架发展很快，功能也在不断完善，开发体验也越来越好） ，在小程序之上又包一层框架，整个开发流程多了一环，无疑会增加项目的风险。而且小程序框架本身还在不断的发展，以微信小程序为例，新特性、能力、规范不断的更新，框架如何短时间的更新适配就成为一个难题。而依赖框架之后，开发者与原生小程序隔离开来，不得不依赖框架方提供解决方案。除了框架能力的支持适配，引入框架还会使得项目本身变得臃肿、缓慢、约束。解决方案之 Antmove在高德小程序开发团队（阿里系小程序的一员【支付宝小程序、淘宝应用、钉钉应用、天猫精灵等】）的工作中，我们遇到了许多想将微信小程序应用上线到阿里系小程序平台的客户，而重新开发一个新平台的小程序对他们来说又比较耗成本，为了解决这个问题，蚂蚁搬家工具应运而生，我们的出发点很简单，希望能够通过技术手段将一个微信小程序应用上线到阿里系小程序平台上。随着这个过程的进行，我们发现用户除了有对阿里系平台的需求外，还有对其它小程序平台支持的需求，所以又有了其它厂商小程序平台的支持。多小程序平台支持目前百度智能小程序、头条小程序的支持还在内测，即将可以体验。从最初的客户服务案例到现在的 antmove 开源项目，我们整个团队考虑过很多，作为一个非 KPI 项目，我们会持续的将它做好，希望能帮助更多的小程序开发者解决他们遇到的问题。Antmove 不是一个框架，而是一个转换工具，比如将微信小程序项目转换为支付宝小程序项目，它更多的还是希望开发者能使用原生的小程序语法去开发小程序，更小、更快、更简洁。到目前为止，Antmove 工具已经帮助了众多的内部用户和外部小程序开发者实现小程序的转换迁徙，现在也希望它能够帮助你解决跨平台开发的难题。"}
{"title": "小程序Request的另类用法 ", "author": "Rolan", "put_time": "2019-8-2 00:18", "content": "小程序中唯一能发送网络请求接口数据的是wx.request接口，当然这个接口存在诸多的限制，例如：10个并发请求限制，https限制（当然在开发阶段是可以关闭此限制），除了wx.request还有其他方法可以实现类型的功能吗？当然是有的,这个思路也源于我之前看到的一篇文章，随便笔记下来\r\n思路\r\n使用云开发来发送网络请求并把数据返回给小程序端。还不了解的云开发的同学请速度移步到官方【云开发】\r\n新建一个http的云函数\r\n// 云函数入口文件\r\nconst cloud = require('wx-server-sdk')\r\nconst axios = require('axios')\r\ncloud.init()\r\n\r\n// 云函数入口函数\r\nexports.main = async (event, context) => {\r\n  const wxContext = cloud.getWXContext()\r\n  const { method, url, data } = event;\r\n  const res = await axios.request({\r\n    method: method,\r\n    url: url,\r\n    data: data\r\n  });\r\n\r\n  return { code: 1, data: res.data } || {code: -1, msg: 'error', data: null}\r\n}\r\n复制代码小程序端二次封装云函数调用\r\nasync http(options = {}) {\r\n\treturn wx.cloud.callFunction({\r\n\t\tname: 'http',\r\n\t\tdata: {\r\n\t\t\tmethod: options.method || 'GET',\r\n\t\t\turl: options.url || '',\r\n\t\t\tdata: options.data || {}\r\n\t\t}\r\n\t}).then(res => {\r\n\t\treturn res.result\r\n\t})\r\n},\r\n复制代码小程序端使用\r\nasync onLoad() {\r\n    this.http({\r\n      method: 'GET',\r\n      url: 'https://www.baidu.com'\r\n    }).then(res => {\r\n      console.log(res)\r\n    })\r\n  },\r\n复制代码总结\r\n这种方法可以很好绕过https的限制，当然这只是提供一个简单的思路，我们可以进一步细一点封装，包括配置header proxy 等等功能，其实原理就是借助云函数做了二次转发，性能上肯定比不上原生的request\r\n注意\r\nasync 和 await 语法糖在最新的开发工具中已经实现了，开启增强编译即可使用，具体更新内容请移步官方社区 微信小程序社区"}
{"title": "微信emoji昵称展示乱码问题 ", "author": "Rolan", "put_time": "2019-8-2 00:32", "content": "对于没有把表情等特殊字符考虑在内的系统，当向数据库写入emoji时，数据库就会报错，如下所示：数据库写入emoji时报错原因emoji表情为4个字符，而一般Mysql的utf8编码最多3个字节，所以插入时就会报错。解决方案前端解决方案作为一个前端，自己能解决的，绝不麻烦后端同学。在前端，将emoji字符先使用encodeURIComponent进行转义，写入数据库，然后读取显示时，再使用decodeURIComponent进行解码。更改数据库编码格式将Mysql的编码从utf8转换成utf8mb4。从 MySQL 5.5.3 开始，MySQL 支持一种 utf8mb4 的字符集，这个字符集能够支持 4 字节的 UTF8 编码的字符。 utf8mb4 字符集能够完美地向下兼容 utf8 字符串。在数据存储方面，当一个普通中文字符存入数据库时仍然占用 3 个字节，在存入一个 Unified Emoji 表情的时候，它会自动占用 4 个字节。所以在输入输出时都不会存在乱码的问题了。要使用 MySQL 的这个特性，首先需要把 MySQL 升级到 5.5.3 以上的版本。其次，需要修改数据结构中的字符集为 utf8mb4 ，如 utf8mb4_general_ci 。由于 utf8mb4 是 utf8 的超集，从 utf8 升级到 utf8mb4 不会有任何问题，直接升级即可；如果从别的字符集如 gb2312 或者 gbk 转化而来，一定要先备份数据库。然后，修改 MySQL 的配置文件 /etc/my.cnf，修改连接默认字符集为 utf8mb4 ，如果是自己写的 PHP 脚本，也可以在连接数据库以后首先执行一句 SQL: SET NAMES utf8mb4;。这时候，PHP 应该就可以正常保存 Emoji 到数据库了。对于数据库配置不是很懂，以上摘抄自博文emoji写入数据库报错处理的方法参考1、encodeURIComponent2、emoji写入数据库报错处理的方法可以通过扫码识别小程序体验下亲测可以正常展示emoji，如果有没有解决的，可以在评论区域留言。"}
{"title": "小程序Request的另类用法 ", "author": "Rolan", "put_time": "2019-8-5 00:36", "content": "小程序中唯一能发送网络请求接口数据的是wx.request接口，当然这个接口存在诸多的限制，例如：10个并发请求限制，https限制（当然在开发阶段是可以关闭此限制），除了wx.request还有其他方法可以实现类型的功能吗？当然是有的,这个思路也源于我之前看到的一篇文章，随便笔记下来思路使用云开发来发送网络请求并把数据返回给小程序端。还不了解的云开发的同学请速度移步到官方【云开发】新建一个http的云函数// 云函数入口文件\r\nconst cloud = require('wx-server-sdk')\r\nconst axios = require('axios')\r\ncloud.init()\r\n\r\n// 云函数入口函数\r\nexports.main = async (event, context) => {\r\n  const wxContext = cloud.getWXContext()\r\n  const { method, url, data } = event;\r\n  const res = await axios.request({\r\n    method: method,\r\n    url: url,\r\n    data: data\r\n  });\r\n\r\n  return { code: 1, data: res.data } || {code: -1, msg: 'error', data: null}\r\n}\r\n复制代码小程序端二次封装云函数调用async http(options = {}) {\r\n\treturn wx.cloud.callFunction({\r\n\t\tname: 'http',\r\n\t\tdata: {\r\n\t\t\tmethod: options.method || 'GET',\r\n\t\t\turl: options.url || '',\r\n\t\t\tdata: options.data || {}\r\n\t\t}\r\n\t}).then(res => {\r\n\t\treturn res.result\r\n\t})\r\n},\r\n复制代码小程序端使用async onLoad() {\r\n    this.http({\r\n      method: 'GET',\r\n      url: 'https://www.baidu.com'\r\n    }).then(res => {\r\n      console.log(res)\r\n    })\r\n  },\r\n复制代码总结这种方法可以很好绕过https的限制，当然这只是提供一个简单的思路，我们可以进一步细一点封装，包括配置header proxy 等等功能，其实原理就是借助云函数做了二次转发，性能上肯定比不上原生的request注意async 和 await 语法糖在最新的开发工具中已经实现了，开启增强编译即可使用，具体更新内容请移步官方社区微信小程序社区"}
{"title": "破解网易易盾在小程序上成功购票的过程 ", "author": "Rolan", "put_time": "2019-8-5 00:42", "content": "盘点背景经朋友介绍接触到这个项目，目的就是要抢到门票:ticket:，最大的问题在于什么呢，有微信小程序版本和IOS版本，都加入了网易易盾的滑块验证。“黑人问号”乘以2都不止，起码是平方吧:joy:。微信本身就有比较高的壁垒了，what？还有网易易盾小程序滑动验证，一开始都是拒绝的，最后抵不过商务游说，只是答应研究研究，并没有说要接这单。怎奈一切入了怎么好轻易言弃呢？坚持就是胜利:v:，成功出票。结果直接上图，当然有录屏鉴于有微信小程序的名字和个人资料信息 录屏自留，截屏马赛克处理。PS：界面素颜有点儿丑但是很实在 至少不会认为是“乔碧萝殿下 老阿姨”所用技术和工具Airtest 是一款跨平台的UI自动化测试框架，基于图像识别原理，适用于游戏和App。 python、 Flask 、 webdriver 、 mitmProxy 、 openCV 、 mongoDB 、 Postman 、 Charles过程首先之前有了解过web页面可以通过webdriver来做自动化的操作，但是这是微信小程序移动端呀？这条路走不通了那么我想想有没有移动端做自动化测试的与webdriver类似的，按照这个思路找到了 Airtest ，「what？用网易的自动化测试工具来破网易易盾 以子之矛攻子之盾」 后来经过实操不好用！不好用！不好用！无论是苹果和安卓都是两种模式 一、通过截图自动对比后做出响应速度很慢 内容相识识别效果不理想（如：列表中按钮或者相同图标）；二、类似于文档选择器（DOM）选择器层级很深完全每个节点每个节点定位的 不准确经常定位不到元素报错 MD好像还真没辙了，NO 不是这样的画风呀又想能不能绕过易盾小程序呢，怎么样直接发起保存订单的请求呢，我们只能出卖自己的个人信息 手动下单抓包现在的问题就在于解决validate和Uuid两个参数了首先去易盾官方文档找易盾小程序接入教程以及研究易盾小程序调起、验证、退出机制，得出结论validate就是易盾验证通过后回调传递给宿主小程序的参数 Uuid暂时不得而知；破解宿主小程序拿到源码通过以上源码我们很容易找出两个参数的又来模拟请求尝试跑通流程。诸参数就位，ok那么我们就完整的来跑一下流程，用postMan模拟发起请求，试验抢票的可行性。当然最终的结果是完美的证明。但是中间的过程 出现的问题，只有做过系统对抗的伙伴知道的。系统设计首先通过代理拿到微信的认证信息上传游客照片（系统有人脸识别）、保存游客信息(有个参数必须看源码才知道如何生成)获取网易易盾验证信息（核心之处，破解方式不能完全公开，需要了解的可以文末加微信咨询）抢票开发完成实战检验 首先拿不用抢购的门票，通过！每日定时限量票，通过！事先开启了录屏 （小视频只有自己看，不公开目标小程序）项目总结和思考关键技术点 采用中间人攻击方式获取微信认证信息；易盾的破解；小程序源码抓取和参数分析；问题点：平台对微信账号的限制购买规则；易盾校验信息通过率偏低；人脸识别；抢票逻辑和业务流程先录入一批游客信息获取易盾验证信息抢票时先取未购票前5人作为一组一并下单，成功后，标记为已购票游客，可以自动进行下一组抢票优化点和方向【节省时间、避免系统限制】先录入游客信息；先得到易盾验证信息，到点直接发起提交请求；多线程、自动组单、自动抢购IP代理池自动切换设备信息池，特别是易盾有基于大数据机器学习微信账号池、微信养号flask、微信小程序破解、移动端中间人攻击代理、AriTest、PC上自动操作滑块验证每一个都可以作为单独一篇文章来细讲，犹豫安全和篇幅的原因本文只公布部分截图和分享技术点逻辑思维，有能力的伙伴可能看后也能复刻出，以上仅作为研究学习使用，并无恶意，请大家合理学习使用，犹豫滥用引发的任何问题和纠纷，作者不承担任何法律责任个人微信 欢迎来撩，请添加如下微信二维码，烦请备注 most_wanted抢票"}
{"title": "基于python 微信小程序之获取已存在模板消息列表 ", "author": "Rolan", "put_time": "2019-8-5 00:50", "content": "前言：为了获取一定高级操作，如：微信模板消息(xiao,xin)推送，把消息推送给用户，或者是获取用户授权信息都需要用到access token，有效期为两个小时？过了两个小时怎么办？重新获取，来，代码撸起走，啥女朋友没有？获取小程序对应的access tokendef get_wx_token():\r\n    url = \"https://api.weixin.qq.com/cgi-bin/token?\"\r\n    try:\r\n        respone = requests.get(url, params=payload, timeout=50)\r\n        access_token = respone.json().get(\"access_token\")\r\n        res = respone.json()\r\n        res[\"time\"] = stamp\r\n        print(u'token过期，重新写入文件的内容>>>', res)\r\n        with open(token_file, \"w+\") as f:\r\n            f.write(json.dumps(res))\r\n        return access_token\r\n    except Exception as e:\r\n        msg = traceback.format_exc()\r\n        print('get token error', msg)\r\n        return并判断是否过期def get_access_token():try:\r\n    with open(token_file, \"r\") as f:\r\n        content = f.read()\r\n        data_dict = content\r\n        # 如果缓存内容为空，直接重新获取token\r\n        if (content == ''):\r\n            print(\"token文件为空，重新获取并写入文件\")\r\n            result = get_wx_token()\r\n            return result\r\n        else:\r\n            data_dict = re.sub('\\'', '\\\"', data_dict)\r\n            token_time = int(json.loads(data_dict)['time'])\r\n            if (stamp - token_time) > 7100:\r\n                # print(\"token过期，重新获取并写入文件\")\r\n                get_wx_token()\r\n            else:\r\n                return  json.loads(data_dict)['access_token']\r\nexcept Exception as e:\r\n    msg = traceback.format_exc()\r\n    print(\"access token express time\", msg)根据access token 获取模板列表def get_templates_list(access_token):\r\n    url = \"https://api.weixin.qq.com/cgi-bin/wxopen/template/list?access_token={}\".format(access_token)\r\n    data = {\r\n      \"offset\": 0,\r\n      \"count\": 20\r\n    }\r\n    r = requests.post(url,data=json.dumps(data)).json()\r\n    tpl_list = r.get('list')\r\n    for tpl in tpl_list:\r\n        print(tpl)\r\n    # print(r.get('list'))返回数据示例{\r\n  \"errcode\": 0,\r\n  \"errmsg\": \"ok\",\r\n  \"list\": [\r\n    {\r\n      \"template_id\": \"wDYzYZVxobJivW9oMpSCpuvACOfJXQIoKUm0PY397Tc\",\r\n      \"title\": \"购买成功通知\",\r\n      \"content\": \"购买地点{{keyword1.DATA}}\\n购买时间{{keyword2.DATA}}\\n物品名称{{keyword3.DATA}}\\n\",\r\n      \"example\": \"购买地点：TIT造舰厂\\n购买时间：2016年6月6日\\n物品名称：咖啡\\n\"\r\n    }\r\n  ]\r\n}有任何问题，留言联系我。"}
{"title": "微信小程序中悬浮窗功能的实现（主要探讨和解决在原生组件上的拖动） ... ", "author": "Rolan", "put_time": "2019-8-5 00:54", "content": "所谓悬浮窗就是图中微信图标的按钮，采用fixed定位，可拖动和点击。这算是一个比较常见的实现场景了。为什么要用cover-view做悬浮窗？原生组件出来背锅了~最初我做悬浮窗用的不是cover-view，而是view。这是简化的代码结构：index.wxml:<view class=\"move-view\" style=\" top:{{top}}px;left:{{left}}px;\" bindtap=\"goToHome\" catchtouchmove=\"setTouchMove\">\r\n    <image class=\"img\" src=\"https://ss2.baidu.com/6ONYsjip0QIZ8tyhnq/it/u=4294841024,3545417298&fm=179&app=42&f=PNG?w=56&h=56\">\r\n    </image>\r\n</view>\r\n<textarea placeholder='我是textarea组件，用来输入一些信息'></textarea>\r\n<view>\r\n  一大段test，占个位，表示下存在感\r\n</view>index.js:Page({\r\n\r\n  /**\r\n  * 页面的初始数据\r\n  */\r\n  data: {\r\n    left: 20,\r\n    top: 250,\r\n    isIos: true\r\n  },\r\n  /**\r\n  * 拖拽移动\r\n  */\r\n  setTouchMove: function (e) {\r\n    if (e.touches[0].clientX > 0 && e.touches[0].clientY > 0) {\r\n      this.setData({\r\n        left: e.touches[0].clientX - 30,\r\n        top: e.touches[0].clientY - 30\r\n      })\r\n    } else {\r\n      this.setData({\r\n        left: 20, //默认显示位置 left距离\r\n        top: 250  //默认显示位置 top距离\r\n      })\r\n    }\r\n  },\r\n  /**\r\n  * 返回首页\r\n  */\r\n  goToHome: () => {\r\n    wx.reLaunch({\r\n      url: '/pages/index/index',\r\n    })\r\n  }\r\n})为什么要用cover-view呢？因为页面上有个textarea组件，这个组件是原生组件，当悬浮窗移动到这个textarea组件上时，将无法继续拖动和点击。如果悬浮窗一开始就定位在textarea上，那么就更惨了，一开始就不能点击和拖动了。这个原因是因为微信小程序的原生组件层级高于非原生组件，不是你修改几下样式就能解决的问题。这里就不讲什么原生组件了，如果想进一步了解，可以参考我之前写的一篇博客：微信小程序在ios下Echarts图表不能滑动的解决方案。如果你的页面上面没有原生组件，那么像上面的代码一样用view做悬浮窗即可。如果有，那么就可以跟着我继续踩坑，使用cover-view这个原生组件层级的组件来做悬浮窗。安卓下的cover-view拖动起来，抖得不像帕金森，像是魔鬼的步伐以下是我们修改为cover-view之后的代码：<cover-view class=\"move-view\" style=\" top:{{top}}px;left:{{left}}px;\" bindtap=\"goToHome\" catchtouchmove=\"setTouchMove\">\r\n    <cover-image class=\"img\" src=\"https://ss2.baidu.com/6ONYsjip0QIZ8tyhnq/it/u=4294841024,3545417298&fm=179&app=42&f=PNG?w=56&h=56\">\r\n    </cover-image>\r\n</cover-view>\r\n<textarea placeholder='我是textarea组件，用来输入一些信息'></textarea>\r\n<view>\r\n  一大段test，占个位，表示下存在感\r\n</view>注意这里，我们的image也改为了cover-image，因为cover-view只支持嵌套 cover-view、cover-image，不过可在 cover-view 中使用 button。这样虽然解决了可在原生组件上自由拖动点击的问题，但是在安卓上出现了一个很奇怪的现象，以至于我认为已经无法用抖动可以来形容了：上图是就是我滑动这个悬浮窗之后的效果，我只是很缓慢地在移动手指，但是这个悬浮窗的表现简直就像一个受惊的兔子。当我第一眼看见这个效果的时候一脸懵逼，我都不知道说什么好。虽然在ios上cover-view移动起来表现良好，但是在安卓上拖动起来的表现简直没法看。勉强能看的补丁方案安卓上这么挫，还不如原来的呢。所以来个补丁方案好了，在ios下用cover-view完美拖动，在安卓上用view先跑着。<cover-view wx-if=\"{{isIos}}\" class=\"move-view\" style=\" top:{{top}}px;left:{{left}}px;\" bindtap=\"goToHome\" catchtouchmove=\"setTouchMove\">\r\n    <cover-image class=\"img\" src=\"https://ss2.baidu.com/6ONYsjip0QIZ8tyhnq/it/u=4294841024,3545417298&fm=179&app=42&f=PNG?w=56&h=56\">\r\n    </cover-image>\r\n</cover-view>\r\n<view wx-if=\"{{!isIos}}\" class=\"move-view\" style=\" top:{{top}}px;left:{{left}}px;\" bindtap=\"goToHome\" catchtouchmove=\"setTouchMove\">\r\n    <image class=\"img\" src=\"https://ss2.baidu.com/6ONYsjip0QIZ8tyhnq/it/u=4294841024,3545417298&fm=179&app=42&f=PNG?w=56&h=56\">\r\n    </image>\r\n</view>\r\n<textarea placeholder='我是textarea组件，用来输入一些信息'></textarea>\r\n<view>\r\n  一大段test，占个位，表示下存在感\r\n</view>当然少不了要在js里面加上这句代码：onLoad: function (options) {\r\n  wx.getSystemInfo({\r\n    success: (res) => {\r\n      if (res.platform == \"android\") {\r\n        this.setData({\r\n          isIos: false\r\n        })\r\n      }\r\n    }\r\n  })\r\n}不要忘记isIos默认为true哦。反正ios环境下可以完美使用了，至于安卓下拖到textarea组件上没法再拖的问题，调整下悬浮框的初始位置就好了。而且只要不是刻意移动到textarea组件上，拖动着悬浮框经过textarea组件也是没有问题的嘛。像我这么聪明的用户还懂得滑动下面的页面来使悬浮窗移动到非原生组件的地方，这样就又可以拖动了嘛。你又以为你的测试一定能发现这个问题？发现了又怎样，我已经尽力了，还给你整出这么多理论依据，足够你把锅牢牢地按在微信小程序官方的头上。使用movable-view：仿佛发现了新大陆，结果发现这个还是个弟弟甩锅是一定要甩锅的，但是段位要高。所以要遍查官方文档，探讨一切可能性，以免甩锅的时候被打脸。我们仔细观察小程序官方文档，发现还是有个专门用来拖动的组件叫movable-view。这个组件和cover-view摆放在一起仿佛很厉害的样子，紧接着我们在原生组件使用限制文档中发现了它并不是原生组件。也就是说这个东西的层级一定还是低于咱们的textarea组件的。虽然已经很确定这个东西没什么用了，但是最后还是试探一把，结果发现是个真弟弟，这里就不给出代码了。我写这个弟弟方案放在这里的目的主要是为了不要浪费你的验证时间。理论上行得通的方案：将拖动事件的捕获放在父级现在我们确认的最优甩锅方案里，已经实现了功能和甩锅两不误。那么作为一名有追求的技术人员，还是需要去探讨以下这个问题到底有没有完美的解决方案。因为我最开始是把这个悬浮窗做成了一个组件，那么作为组件来讲，这个东西就只能做到这个地步了。不过如果你是像我现在的例子一样直接做在了页面里，那么实现起来也不是说没有办法的。我们将拖动的事件放在父级上就可以了，请看接下来的代码：index.wxml:<view bindtouchmove=\"setTouchMove\">\r\n    <view class=\"move-view\" style=\" top:{{top}}px;left:{{left}}px;\" bindtap=\"goToHome\">\r\n        <image class=\"img\" src=\"https://ss2.baidu.com/6ONYsjip0QIZ8tyhnq/it/u=4294841024,3545417298&fm=179&app=42&f=PNG?w=56&h=56\">\r\n        </image>\r\n    </view>\r\n    <textarea placeholder='我是textarea组件，用来输入一些信息'></textarea>\r\n    <view>\r\n      一大段test，占个位，表示下存在感\r\n    </view>\r\n</view>index.js:Page({\r\n\r\n  /**\r\n  * 页面的初始数据\r\n  */\r\n  data: {\r\n    left: 20,\r\n    top: 250\r\n  },\r\n\r\n  /**\r\n  * 拖拽移动\r\n  */\r\n  setTouchMove: function (e) {\r\n    const MOVE_VIEW_RADIUS = 30 // 悬浮窗半径\r\n\r\n    const touchPosX = e.touches[0].clientX\r\n    const touchPosY = e.touches[0].clientY\r\n\r\n    const moveViewCenterPosX = this.data.left + MOVE_VIEW_RADIUS\r\n    const moveViewCenterPosY = this.data.top + MOVE_VIEW_RADIUS\r\n\r\n    // 确保手指在悬浮窗上才可以移动\r\n    if (Math.abs(moveViewCenterPosX - touchPosX) < MOVE_VIEW_RADIUS + 60 && Math.abs(moveViewCenterPosY - touchPosY) < MOVE_VIEW_RADIUS + 60) {\r\n      if (touchPosX > 0 && touchPosY > 0) {\r\n        this.setData({\r\n          left: touchPosX - MOVE_VIEW_RADIUS,\r\n          top: touchPosY - MOVE_VIEW_RADIUS\r\n        })\r\n      } else {\r\n        this.setData({\r\n          left: 20, // 默认显示位置 left距离\r\n          top: 250  // 默认显示位置 top距离\r\n        })\r\n      }\r\n    }\r\n  },\r\n  /**\r\n  * 返回首页\r\n  */\r\n  goToHome: () => {\r\n    wx.reLaunch({\r\n      url: '/pages/index/index',\r\n    })\r\n  }\r\n})关键代码就是这块了：// 确保手指在悬浮窗上才可以移动\r\nif (Math.abs(moveViewCenterPosX - touchPosX) < MOVE_VIEW_RADIUS + 60 && Math.abs(moveViewCenterPosY - touchPosY) < MOVE_VIEW_RADIUS + 60) {\r\n\r\n}只要确保手指在悬浮窗的范围内就可以触发移动了，这里的60是为了确保你的手指太大，或者移动得比较快时超出了悬浮窗区域依然可以触发拖动，这个可以自己设定数值。这个方案在理论上很合理，并且还加上了60这个缓冲区域，但是实际在拖动的时候你仍然会面临下面三个问题：1.如果悬浮窗下方有滚动区域，那么拖动的时候就会滚动页面，效果会显得比较奇怪。2.实际移动没法移动太顺畅，只能拖着悬浮窗亦步亦趋,要不然很容易超过60这个缓冲区域，导致拖动不继续触发。2.如果将缓冲区域设置过大，那么又会出现一种比较奇怪的场景：明明不准备拖动悬浮窗，只是准备滑动页面，悬浮窗却跳到自己手指这里了。进阶解决方案：禁止冒泡的拖动 + 理论方案这个解决方案基于我们的最初方案，并且使用我们的理论方案作为补充。先上代码：index.wxml：<view bindtouchmove=\"handleSetMoveViewPos\">\r\n    <view class=\"move-view\" style=\" top:{{top}}px;left:{{left}}px;\" bindtap=\"goToHome\" catchtouchmove=\"handleTouchMove\">\r\n        <image class=\"img\" src=\"https://ss2.baidu.com/6ONYsjip0QIZ8tyhnq/it/u=4294841024,3545417298&fm=179&app=42&f=PNG?w=56&h=56\">\r\n        </image>\r\n    </view>\r\n    <textarea placeholder='我是textarea组件，用来输入一些信息'></textarea>\r\n    <view>\r\n      一大段test，占个位，表示下存在感\r\n    </view>\r\n</view>index.js：Page({\r\n  /**\r\n  * 页面的初始数据\r\n  */\r\n  data: {\r\n    left: 20,\r\n    top: 250\r\n  },\r\n  /**\r\n  * 拖拽移动(补丁)\r\n  */\r\n  handleSetMoveViewPos: function (e) {\r\n    const MOVE_VIEW_RADIUS = 30 // 悬浮窗半径\r\n\r\n    const touchPosX = e.touches[0].clientX\r\n    const touchPosY = e.touches[0].clientY\r\n\r\n    const moveViewCenterPosX = this.data.left + MOVE_VIEW_RADIUS\r\n    const moveViewCenterPosY = this.data.top + MOVE_VIEW_RADIUS\r\n\r\n    // 确保手指在悬浮窗上才可以移动\r\n    if (Math.abs(moveViewCenterPosX - touchPosX) < MOVE_VIEW_RADIUS+30 && Math.abs(moveViewCenterPosY - touchPosY) < MOVE_VIEW_RADIUS+30 ) {\r\n      if (touchPosX > 0 && touchPosY > 0) {\r\n        this.setData({\r\n          left: touchPosX - MOVE_VIEW_RADIUS,\r\n          top: touchPosY - MOVE_VIEW_RADIUS\r\n        })\r\n      } else {\r\n        this.setData({\r\n          left: 20, // 默认显示位置 left距离\r\n          top: 250  // 默认显示位置 top距离\r\n        })\r\n      }\r\n    }\r\n  },\r\n  /**\r\n  * 拖拽移动\r\n  */\r\n  handleTouchMove: function (e) {\r\n    const MOVE_VIEW_RADIUS = 30 // 悬浮窗半径\r\n\r\n    const touchPosX = e.touches[0].clientX\r\n    const touchPosY = e.touches[0].clientY\r\n\r\n    if (touchPosX > 0 && touchPosY > 0) {\r\n      this.setData({\r\n        left: touchPosX - MOVE_VIEW_RADIUS,\r\n        top: touchPosY - MOVE_VIEW_RADIUS\r\n      })\r\n    } else {\r\n      this.setData({\r\n        left: 20, //默认显示位置 left距离\r\n        top: 250  //默认显示位置 top距离\r\n      })\r\n    }\r\n  },\r\n  /**\r\n  * 返回首页\r\n  */\r\n  goToHome: () => {\r\n    wx.reLaunch({\r\n      url: '/pages/index/index',\r\n    })\r\n  }\r\n})这个方案的核心点在于：catchtouchmove=\"handleTouchMove\" 。当我们正常拖动悬浮窗时，通过catchtouchmove，我们可以捕获在悬浮窗上的滑动事件，并且不冒泡到父元素，那么我们绑在父层级的滑动事件就不会触发。而当我们拖动在原生组件之上的悬浮窗时，因为点不到这个悬浮窗，就不会触发handleTouchMove函数，只会触发绑定在父元素上的handleSetMoveViewPos函数。另外如果你细心的话，就会发现在handleSetMoveViewPos函数这里我缩小了那个60的缓冲区域为30，这样做的目的是因为触发这个函数只会在原生组件上，所以多番权衡距离之后，尽量避免近距离滑动操作就触发拖动悬浮框。通过我们的方案，我们可以在非原生组件上自由拖动，在原生组件上比较顺畅地拖动。本来我是准备将这个方案作为最终方案的，但是ios下，悬浮窗在原生组件上时，在父元素上的滑动事件竟然不触发。棋差一招，棋差一招啊！最终解决方案：更多的补丁，更多的快乐这个最终解决方案，当然是把我们之前所有的补丁方案全部结合起来。代码如下：index.wxml:<view bindtouchmove=\"handleSetMoveViewPos\">\r\n    <view wx-if=\"{{!isIos}}\" class=\"move-view\" style=\" top:{{top}}px;left:{{left}}px;\" bindtap=\"goToHome\" catchtouchmove=\"handleTouchMove\">\r\n        <image class=\"img\" src=\"https://ss2.baidu.com/6ONYsjip0QIZ8tyhnq/it/u=4294841024,3545417298&fm=179&app=42&f=PNG?w=56&h=56\">\r\n        </image>\r\n    </view>\r\n    <cover-view wx-if=\"{{isIos}}\" class=\"move-view\" style=\" top:{{top}}px;left:{{left}}px;\" bindtap=\"goToHome\" catchtouchmove=\"handleTouchMove\">\r\n        <cover-image class=\"img\" src=\"https://ss2.baidu.com/6ONYsjip0QIZ8tyhnq/it/u=4294841024,3545417298&fm=179&app=42&f=PNG?w=56&h=56\">\r\n        </cover-image>\r\n    </cover-view>\r\n    <textarea placeholder='我是textarea组件，用来输入一些信息'></textarea>\r\n    <view>\r\n      一大段test，占个位，表示下存在感\r\n    </view>\r\n</view>index.js:Page({\r\n\r\n  /**\r\n  * 页面的初始数据\r\n  */\r\n  data: {\r\n    left: 20,\r\n    top: 250,\r\n    isIos: true\r\n  },\r\n\r\n  /**\r\n  * 生命周期函数--监听页面加载\r\n  */\r\n  onLoad: function (options) {\r\n    wx.getSystemInfo({\r\n      success: (res) => {\r\n        if (res.platform == \"android\") {\r\n          this.setData({\r\n            isIos: false\r\n          })\r\n        }\r\n      }\r\n    })\r\n  },\r\n\r\n  /**\r\n  * 拖拽移动(补丁)\r\n  */\r\n  handleSetMoveViewPos: function (e) {\r\n    // 在ios下永远都不会走这个方案，以免引起无用的计算\r\n    if (!ios) {\r\n      const MOVE_VIEW_RADIUS = 30 // 悬浮窗半径\r\n\r\n      const touchPosX = e.touches[0].clientX\r\n      const touchPosY = e.touches[0].clientY\r\n\r\n      const moveViewCenterPosX = this.data.left + MOVE_VIEW_RADIUS\r\n      const moveViewCenterPosY = this.data.top + MOVE_VIEW_RADIUS\r\n\r\n      // 确保手指在悬浮窗上才可以移动\r\n      if (Math.abs(moveViewCenterPosX - touchPosX) < MOVE_VIEW_RADIUS && Math.abs(moveViewCenterPosY - touchPosY) < MOVE_VIEW_RADIUS) {\r\n        if (touchPosX > 0 && touchPosY > 0) {\r\n          this.setData({\r\n            left: touchPosX - MOVE_VIEW_RADIUS,\r\n            top: touchPosY - MOVE_VIEW_RADIUS\r\n          })\r\n        } else {\r\n          this.setData({\r\n            left: 20, // 默认显示位置 left距离\r\n            top: 250  // 默认显示位置 top距离\r\n          })\r\n        }\r\n      }\r\n    }\r\n  },\r\n  /**\r\n  * 拖拽移动\r\n  */\r\n  handleTouchMove: function (e) {\r\n    const MOVE_VIEW_RADIUS = 30 // 悬浮窗半径\r\n\r\n    const touchPosX = e.touches[0].clientX\r\n    const touchPosY = e.touches[0].clientY\r\n\r\n    if (touchPosX > 0 && touchPosY > 0) {\r\n      this.setData({\r\n        left: touchPosX - MOVE_VIEW_RADIUS,\r\n        top: touchPosY - MOVE_VIEW_RADIUS\r\n      })\r\n    } else {\r\n      this.setData({\r\n        left: 20, //默认显示位置 left距离\r\n        top: 250  //默认显示位置 top距离\r\n      })\r\n    }\r\n  },\r\n  /**\r\n  * 返回首页\r\n  */\r\n  goToHome: () => {\r\n    wx.reLaunch({\r\n      url: '/pages/index/index',\r\n    })\r\n  }\r\n})这个最终解决方案在ios下直接使用cover-view来做悬浮窗，而在android的非原生组件上移动时，使用view来做悬浮窗，不冒泡滑动事件，在原生组件上移动时捕获冒泡的滑动事件来继续移动操作。总结虽然问题解决了，但是这仍然只是一个补丁方案。最好的方式依然是微信小程序官方能修复cover-view在安卓移动时的BUG，但是我发现最早有人反馈这个问题是在2018年11月，到了现在2019年8月都没有结果。如果不是微信小程序的官方态度有问题，那么只能说明这个问题的解决确实有难度或者优先级并不高，无论是哪一种，暂时都还是得用补丁方案。这个方案并没有那么完美，他在一些边界的衔接上面可能还是会存在一些小问题，但它至少可用，并且应该是大多数用户可以接受的。"}
{"title": "小程序页面栈详解 ", "author": "Rolan", "put_time": "2019-8-6 00:08", "content": "原文链接小程序页面栈详解在做小程序项目的时候不难发现，使用navigateTo进行页面跳转后，点击左上角或使用navigateBack返回，总是会按照之前的页面进入倒序来展示页面，那么问题来了，它们的跳转规则是什么样的呢？结合到实际业务中如何灵活运用呢？什么是页面栈？首先先来了解一下微信小程序的运行环境： 小程序的运行环境分成渲染层和逻辑层，其中 WXML 模板和 WXSS 样式工作在渲染层，JS 脚本工作在逻辑层。 小程序的渲染层和逻辑层分别由2个线程管理：渲染层的界面使用了WebView 进行渲染；逻辑层采用JsCore线程运行JS脚本。一个小程序存在多个界面，所以渲染层存在多个WebView线程，这两个线程的通信会经由微信客户端做中转，逻辑层发送网络请求也经由Native转发，小程序的通信模型下图所示。我们可以看到，一个页面使用一个 WebView 线程进行渲染。如果打开10个页面，则会开启 10 个 WebView 线程，此时内存中的十个webView线程我们称之为页面栈。当然小程序也会对这块内存做限制，目前页面栈的限制是不能超过十条。在小程序中页面的路由是小程序框架本身控制的我们不要去手动管理， 小程序框架通过一个页面栈的设计来管理所有的界面，当发生路由跳转时，页面栈就会做出相应的变化，在小程序页面中通过 getCurrentPages() 就可以获取到当前的页面栈。举个栗子： 在父页面中先获取页面栈：const page = getCurrentPages(); // 父页面\r\nconsole.log('父页面', page); //父页面\r\n复制代码通过wx.navigateTo跳转子页面，在子页面中再获取页面栈：const page = getCurrentPages(); // 子页面\r\nconsole.log('子页面', page); //子页面\r\n复制代码输出：通过上面的例子可以看到，我们可以在页面中通过 getCurrentPages() 方法来获取当前页面栈，并且获取到的是一个数组，其中每个item都是每个页面的Page对象（也就是在页面中的this对象），由此我们引发一些思考……路由跳转时页面栈表现？当发生路由切换的时候，页面栈的表现如下： 当发生路由切换的时候，页面栈的表现如下：情景页面栈表现对应路由跳转API小程序初始化新页面入栈打开新页面新页面入栈wx.navigateTo 或使用组件页面重定向当前页面出栈，新页面入栈wx.redirectTo 或使用组件页面返回页面不断出栈，直到目标页wx.navigateBack 或使用组件或用户按左上角返回按钮Tab 切换页面全部出栈，只留下新的 Tab 页面wx.switchTab 或使用组件 或用户切换 Tab重加载页面全部出栈，只留下新的页面wx.reLaunch 或使用组件我们在做项目的时候，巧妙运用路由跳转和页面栈会节省很多代码，用户体验也会得到相应的提升，所以，在开始项目之前，定好页面跳转规则相当重要。页面栈的实际运用分析下面我们分析一下页面栈的变化过程，从分析中，我们需要明白的一个重要问题就是，当客户按返回按钮的时候究竟会跳转到那个界面，这是我们分析页面栈变化的的意义。 首先我们在页面中调用两次navigateTo，页面栈情况如下这时显示的界面是pageC ，如果客户在此时返回则会一切正常，回退的第一个界面是pageB，然后是pageA。但是如果在pageC 界面调用 wx.redirectTo({url:'pageD'}) 则情况就会不一样，我们先看一下跳转到pageD后页面栈的情况如何。根据栈的情况，我们可以分析出。如果使用 wx.redirectTo跳转到pageD页面，然后在回退的时候是不能再次回退到pageC的，而会直接回退到pageB。 通过上面对页面栈的分析，我们可以看到栈的变化是会影响客户回退页面的顺序的，所以根据自己的需求合理的使用不同的跳转方法是非常重要的。如果使用不当就会导致跳转混乱让人摸不清头脑 下面分析一种调转重复页面的情况：如图所示栈中出现了两个相同的pageB界面，这个时候如果用户按退出键就会出现一个页面出现2次的情况，而且有一个界面的数据也是旧的数据。因此为了避免这个问题，我们应该在 PageC 页面避免将 PageB重复压入栈中，所以在pageC页面使用wx.navigateBack({delta:1}); 进行页面回退。而数据刷新的问题则在页面的onShow函数中进行即可。情景：确认订单页用户点击左上角返回假设场景：用户在商品详情页直接点击“立即购买”下单购买，进入确认订单页，付款成功后跳转到付款成功页面，此时用户点击左上角箭头进行了返回…… 处理：此时理应进入商品详情页，所以在确认订单页付款成功跳转时应当将确认订单页出栈，新页面入栈，那么就不可以使用wx.navigateTo来进行页面跳转，应当使用wx.redirectTo情景：确认订单页用户选择已有收货人假设场景：在确认订单页，用户需要选择已有的收货人，而已有收货人列表在另一个页面，那么用户点击“选择收货人”之后，使用wx.navigateTo跳转到收货人列表，点击某个收货人，带参数返回确认订单页…… 处理：在确认订单页使用wx.navigateTo跳转到收货人列表，然后在收货人列表里click事件中获取页面栈，直接往上一个页面setData，然后退回上一个页面，show code：const page = getCurrentPages()\r\nif (page.length > 1) {\r\n  page[page.length - 2].setData({\r\n    收货人: 选中的某个收货人详情   //[object]\r\n  })\r\n  wx.navigateBack({\r\n    delta: 1\r\n  })\r\n}\r\n复制代码上面例子中提到过，在页面中通过 getCurrentPages() 方法来获取当前页面栈，并且获取到的是一个数组，其中每个item都是每个页面的Page对象，那么我们就可以使用 setData 方法直接改变上一个页面展示的数据，并且直接退回上一个页面。此时官方提醒：虽然这种方法简便，但是官方也给出提醒，页面栈数据可以自行修改，但是！一定要慎重，否则会导致页面状态错误。总结： 总觉得漏了点啥，又想不起来…… 官方文档应有尽有，多研究官方文档，多引发思考并手写demo尝试，总会有一些新的发现，另外，方法千万条，随便选一条，根据自己业务逻辑选用合适的方法。"}
{"title": "一步一步踩坑实现微信小程序自动预览 ", "author": "Rolan", "put_time": "2019-8-6 00:14", "content": "在最近的工作中，主要做的是C端的小程序，在开发过程中倒是还好，一到改BUG的时候，可能就会进入保存，编译，自动预览的循环了，虽然微信已经提供了快简介自动预览，但是总归是一个手动的过程，要是能监听文件变化自动预览不是更好吗？查看文档于是我就去看了下文档，发现微信已经提供了这个API，可以用命令行调用，也可以用HTTP调用。一开始本着配置少一点的原则，我选择了HTTP调用，因为命令行调用需要配置微信开发者工具的安装目录，而HTTP调用可以通过微信指定的路径获取端口号（实践证明，too young, too simple， 认真你就输了，\tHTTP调用的问题太多，所以我后来又改成了命令行调用 ）。然后就去官方所指示的ide文件夹找端口号了，结果并没有发现那个文件。怎么回事呢？一顿搜索之后，才知道目前的版本需要如下才能开启http服务：\t微信开发者工具 -> 查看所有项目 -> 设置 -> 安全 ，里面有个服务端口，选择开启以后就能找到ide文件，进而得到端口号进行后续操作了。前置工作commander ，主要是从命令行读取参数，实现动态配置，方便调用。chalk 控制台输出格式多样化。axios 用于发起http请求。package.json中的bin 字段，用于实现自定义命令。路径区分，\tprocess.cwd()执行命令时所在的目录，__dirname执行文件所在的目录。 导入配置文件主要是用前者。使用\tfs.watch 进行目录和文件的监听，在文件变动后调用自动预览读取端口号文档中提到 端口号文件位置：macOS : ~/Library/Application Support/微信开发者工具/Default/.ide Windows : ~/AppData/Local/微信开发者工具/User Data/Default/.ide既然路径有了，那么就好说了，只要\t获取到用户目录，然后再拼接上不同平台的后续路径，那么通过读取.ide文件就可以得到端口号了 。代码如下:const fs = require(\"fs\");\r\nconst os = require(\"os\");\r\nconst isWin = os.platform() === `win32`;\r\n\r\nfunction getHttpPort() {\r\n  const home = os.homedir();\r\n  const suffix = isWin\r\n    ? `/AppData/Local/微信开发者工具/User Data/Default/.ide`\r\n    : `/Library/Application Support/微信开发者工具/Default/.ide`;\r\n  const idePath = home + suffix;\r\n\r\n  const port = fs.readFileSync(idePath, { encoding: \"utf8\" });\r\n\r\n  return port;\r\n}\r\n复制代码打开工具或指定项目HTTP调用实例：# 打开工具\r\nhttp://127.0.0.1:端口号/open\r\n# 打开/刷新项目\r\nhttp://127.0.0.1:端口号/open?projectpath=项目全路径\r\n复制代码先在浏览器中直接进行访问，很好，你会发现\t微信开发者工具并没有打开 ，再仔细看了下文档，用法肯定没错的，总共就端口号和项目路径两个变量，怎么可能会出错呢？被某厂坑久了，就知道有问题是必然的。算了，打不开就打不开吧，影响并不是很大，反正平时开发的时候，开发者工具都是打开的。这个问题呢，我猜测是因为\t工具每次打开端口号都会变化 ，而读取的端口号是之前的，所以就没用了。命令行调用-o, --open [projectpath]: 打开工具，如果不带 projectpath，只是打开工具。如果带 project path，则打开路径中的项目，每次执行都会自动编译刷新，并且自动打开模拟器和调试器。projectpath 不能是相对路径。项目路径中必须含正确格式的 project.config.json 且其中有 appid 和 projectname 字段。调用：cli -o /Users/username/demo\r\n复制代码这次的调用完全没有问题的。自动预览HTTP调用接口定义：URL：/autopreviewHTTP 方法：GETURL 参数必填说明projectpath是指定路径中的项目。如项目已打开，自动刷新项目。如项目未创建，自动创建并自动预览项目infooutput否指定后，会将本次自动预览的额外信息以 json 格式输出至指定路径，如代码包大小、分包大小信息。compilecondition否指定自定义编译条件，值为 json 字符串，条件可指定两个字段，pathName 表示打开的页面，不填表示首页，query 表示页面参数这个接口请求以后，倒是可以用，但是坑也不小。infooutput 这个参数我写了，却并没有生成相应的文件。compilecondition 这个参数其实是我从预览那个接口凑过来的，官方文档只有2个参数 。本来我也没想到这个参数的，但是没办法，我们的项目首页是pages/home/index，自动预览以后可能是没找到pages/index/index这种默认的首页，然后就随便跳了一个？文档总是缺三少四的，这里一块那里一块，稍微看漏一点这个功能可能就出不来了，说到底看文档就是得仔细。命令行调用自动预览必须处于登录状态，如果没有登录，会提示需先登录。--auto-preview <project_root> : 自动预览代码，project_root 指定项目根路径。--auto-preview-info-output <path> : 指定后，会将本次预览的额外信息以 json 格式输出至指定路径，如代码包大小、分包大小信息。官方文档只介绍了这两个参数，还是像之前一样，从预览那个的调用凑一下吧。--compile-condition '<json>' : 指定自定义编译条件，json 条件可指定两个字段，pathName 表示打开的页面，不填表示首页，query 表示页面参数用命令行测试：cli --auto-preview /Users/username/demo --compile-condition {\\\"pathName\\\": \\\"pages/home/index\\\",\\\"query\\\":\\\"a=1\\\"}\r\n复制代码大坑命令行调用的时候编译条件应该是调用\tJSON.stringify(obj).replace(/\\\"/g, `\\\\\"`) 所获得的字符串，\t注意要把\"换成\\\"，且前后不需要单引号 ，文档里面那种调用方式会报错，不信的小伙伴可以自己尝试。查询参数query只能有一个参数 ，如果用&链接多个参数的话，提示信息是成功，但是手机并没有自动预览，害得我还纳闷了好久。这个问题必须得给官方反应一下，太影响使用了。node脚本编写思路辅助函数// 将D:\\\\www\\\\soft转换成D:/www/soft这种形式\r\n// msg为路径不存在时的报错信息\r\nfunction getPath(projectpath, msg) {\r\n  if (!projectpath) {\r\n    throw new Error(msg);\r\n  }\r\n  return projectpath.split(path.sep).join(`/`);\r\n}\r\n\r\n// 获取打包路径\r\nfunction getDist(config = {}) {\r\n  const { projectpath } = config;\r\n  return (\r\n    config.dist ||\r\n    (/dist\\/?$/.test(projectpath) ? projectpath : (projectpath || \"\") + `/dist`)\r\n  );\r\n}\r\n\r\n// 将exec转为promise类型的函数，方便使用async await\r\nconst promisify = require(\"util\").promisify;\r\nlet { exec } = require(\"child_process\");\r\nexec = promisify(exec);\r\n复制代码这里介绍一下execchild_process.exec(command[, options][, callback])\r\n复制代码参数类型说明commandstringThe command to run, with space-separated arguments. (需要运行的命令，参数用空格分开)optionsobject{ cwd: \"子进程工作目录，默认为null\", }\t其他参数我没怎么用过callback否回调函数: (error: Error, stdout: string | Buffer, stderr: string | Buffer）spawn和exec的却别在于，spawn的输出是实时的，而exec是执行完之后统一返回。前者还得监听事件略显麻烦，所以我选择了exec。open.jsasync function open({ projectpath, cli, }) {\r\n  return new Promise(async (resolve, reject) => {\r\n    log();\r\n    log(chalk.green(`打开开发者工具中...`));\r\n    const result = await exec(\r\n      `cli -o ${projectpath}`,\r\n      {\r\n        cwd: cli\r\n      }\r\n    );\r\n\r\n    const isSuccess = result.stdout;\r\n    log(isSuccess ? chalk.green(`打开成功`) : chalk.red(`打开失败`));\r\n    isSuccess ? resolve() : reject();\r\n  })\r\n}\r\n复制代码preview.jsasync function preview(config) {\r\n  await open(config);\r\n\r\n  const port = getHttpPort();\r\n  const { dist, projectpath, time, compile, cli } = config;\r\n\r\n  log();\r\n  log(chalk.blue(`开始监听文件变动`));\r\n  log(`路径参数: `, compile);\r\n\r\n  fs.watch(\r\n    dist,\r\n    debounce(async (evt, filename) => {\r\n      log();\r\n      console.log(`${filename} ${evt}`);\r\n\r\n      log(chalk.green(`自动预览重启中...`));\r\n      log(\r\n        `执行命令： cli --auto-preview ${projectpath} --compile-condition ${compile}`\r\n      );\r\n      const result = await exec(\r\n        `cli --auto-preview ${projectpath} --compile-condition ${compile}`,\r\n        {\r\n          cwd: cli\r\n        }\r\n      );\r\n\r\n      const isSuccess = result.stdout;\r\n      log(isSuccess ? chalk.green(`自动预览成功`) : chalk.red(`自动预览失败`));\r\n    }, time || 1000)\r\n  );\r\n}\r\n复制代码lib/index.jsconst fn = {\r\n  preview,\r\n  upload,\r\n};\r\n\r\nfunction run(config, type) {\r\n  if (!fn[type]) {\r\n    throw new Error(`type参数不合法，请确保为preview, upload的一种`);\r\n  }\r\n\r\n  log(chalk.green(`本次启动类型为: ${type}`));\r\n  fn[type](config);\r\n}\r\n复制代码config参数从命令行参数中读取文件获得，type参数为命令行参数。bin/index.js#! /usr/bin/env node\r\nconst run = require(\"../lib/index\");\r\nconst program = require(\"commander\");\r\nconst fs = require(\"fs\");\r\nconst path = require(\"path\");\r\nconst { getPath, getHttpPort, getDist } = require(\"../util/index\");\r\n\r\nprogram\r\n  .option(\"-c, --config <type>\", \"config file\", \"auto.js\")\r\n  .option(\"-t, --type <type>\", \"auto type, etc: preview, upload\", \"preview\")\r\n  .parse(process.argv);\r\n\r\n// 获取执行命令时所在的目录，拼接上配置文件目录，使用require(ConfigFile)即可获得相关配置\r\nconst CD = process.cwd();\r\nconst Config = program.config;\r\nconst ConfigFile = path.join(CD, Config);\r\n\r\nconst defaultCompile = {\r\n  pathName: `pages/home/index`\r\n};\r\n\r\n// 判断配置文件不存在，则直接报错\r\nif (!fs.existsSync(ConfigFile)) {\r\n  throw new Error(`[ERROR]: ${Config} not found in ${CD}`);\r\n} else {\r\n  start();\r\n}\r\n\r\nfunction start() {\r\n  let config = require(ConfigFile);\r\n  config = { ...config };\r\n  config.projectpath = getPath(\r\n    config.projectpath,\r\n    `配置文件中projectPath字段必须有值`\r\n  );\r\n  const projectpath = config.projectpath;\r\n  config.dist = getDist(config);\r\n  config.compile = JSON.stringify(config.compile || defaultCompile).replace(\r\n    /\\\"/g,\r\n    `\\\\\"`\r\n  );\r\n  // 这里可写可不写，打开工具后会进行再次获取\r\n  config.port = getHttpPort();\r\n\r\n  run(config, program.type);\r\n}\r\n复制代码至此，该功能已经大致完成了，我已经上传到了npm，可以直接进行使用。wx-auto微信开发者工具，HTTP调用，自动预览，提高工作效率局部安装npm i wx-auto -D 或者 yarn add wx-auto -D\r\n复制代码全局安装npm i wx-auto -g \r\n复制代码使用方法wxauto\r\n或者\r\nwxauto -t preview -c auto.js\r\n复制代码参数(均有默认值)-t, --type 类型，目前支持preview和upload\r\n-c, --config 配置文件名，默认值为auto.js\r\n复制代码文件路径为相对路径，相对于执行命令时所在的路径配置文件{\r\n  cli: \"D:/soft/微信web开发者工具\", // cli文件所在的目录\r\n  projectpath: `D:/www/react/heywoof-app-frontend`, // 项目地址\r\n  compile: {\r\n    pathName: `pages/scene/index`, // 自动预览的页面路径\r\n    query: `activityId=5d45050569515b000c5b740a` // 查询参数，微信目前有BUG，只能识别一个参数\r\n  },\r\n  build: `yarn build-test:weapp`, // 上传之前需要执行的命令\r\n  upload: {\r\n    version: \"1.0.1\",\r\n    desc: \"测试自动上传，不要乱动\"\r\n  }\r\n};\r\n复制代码此外还包含了自动打包上传的功能，配置之后执行\twxauto -t upload -c auto.js ，上传完毕后就会自动打开微信公众平台登录的网站，个人感觉还是挺实用的。自动化测试在查看文档的时候，我发现微信官方推出了一个\t多端统一开发工具——kbone ，这个是基于vue的，就是配置略显麻烦。除此之外，微信小程序现在已经支持自动化测试了，感兴趣的小伙伴可以自行尝试。注意：\t该功能需要最新版本支持 ，一定要符合文档所说的版本，我简单尝试了一下，自动化是可以实现的，更具体的测试就得看工作需要了。"}
{"title": "随手开源一个微信小程序仪表盘组件 ", "author": "Rolan", "put_time": "2019-7-23 00:23", "content": "最近在一个小程序项目中做了个动态仪表盘效果，感觉有点复用价值，就顺便给组件化了，丰富了几个常用配置，绘制元素根据尺寸自适应，差不多具备了一个自定义组件的基本素质。开发非常简单没有值得说的点，开发之外却是一步一个坑。先来预览下效果：感兴趣的直接看源码：https://github.com/tower1229/weapp-plugin-dashboard下面是踩坑过程。如何开发微信小程序自定义组件官方提供了一个CLI工具专门用于开发小程序自定义组件，首先全局安装这个工具：npm install -g @wechat-miniprogram/miniprogram-cli\r\n然后用它初始化一个自定义组件项目：miniprogram init --type custom-component\r\n这一步会下载一个前端工程模板到本地，这个模板是一个基于gulp的前端自动化工程，使用前需要先安装依赖：npm i\r\n有可能你会像我一样发现这个项目的默认依赖版本有点老，然后习惯性的在VSCode里用 Npm Dependency 自动升级了一下，重新安装，然后就傻逼了，新版babel插件会让项目跑不起来。还原到默认版本重新安装，启动开发服务：npm run watch\r\n这时自动化工程会将 src/ 里的代码构建到 miniprogram_dev/ 文件夹，这里面是一个标准的小程序目录结构，是可以用微信开发者工具导入并运行的，导入的时候注意使用测试appId。然后这边我们编辑src里的源码文件，另一边就会同步构建到miniprogram_dev，微信开发者工具检测到文件变动也会自动重新编译项目，目前为止很美好。但就我的亲身体验来看，这个自动化工程有点小毛病，偶尔会把个别文件给编译“丢”，比如突然样式没了，或者js编译不通过，那么js文件也就没了，微信开发者工具这边就会报错。最坑的是，这个工程的编译过程集成了eslint代码检查，检查不通过js文件就不编译，任由开发者工具报错。默认的eslint配置是有多变态？起码对我来说这是个很难忘的经历，一下午都在咬牙切齿的查各种eslint报错是什么意思，怎么关掉。不过eslint也有一些有意义的要求，比如 parseInt() 方法的第二个参数通常我都不传，严格来说这样确实不算好的实践。canvas在小程序组件中的使用开发过程中遇到最坑的问题，是我自己看文档不仔细导致的，但我觉得更大的责任在于小程序官方文档太乱了。初始化canvas实例的 wx.createCanvasContext() 方法，其实有两个参数，第二个参数通常也是都不传，仅在组件内使用时这个参数才需要传 this ，之前一直没在组件里用过canvas，导致忘了还有这么个参数，也不报错，就是canvas死活画不出东西，查了好半天才发现是这个原因。这种情况完全可以在开发工具中给个报错，为什么不？查文档的过程中，真心觉得小程序的文档组织太TM乱了，知识点是全的，但同一个东西的知识点散落的到处都是，比如说单独看【框架】这个栏目的内容，你根本不可能掌握小程序框架是怎么一回事，再看看“指南”才能知道个大概，然后再看组件和API，才能写出个hello world项目。就说自定义组件的开发吧，自定义组件的接口、开发、发布、安装每个环节的内容，被分别散落在【框架】、【指南】、【工具】的不同篇幅里，也就是第一次开发自定义组件的时候，需要把整个文档都翻腾一遍，才能找到所有我需要知道的东西，你说扯不扯。发布与安装npm包自定义组件开发完了就要发布到npm，发布过程是全程最愉快的部分了，一点坑没有，开发环境测试没问题，运行构建命令：npm run build\r\n这时会产出一个 miniprogram_dist/ 文件夹，整个项目的 .gitignore 和 .npmignore 都预置好了，如果你把代码提交到GitHub，将只提交源码和必要的工程文件；如果要发布到npm，在已经登录npm的前提下只要执行：npm publish\r\n就会按小程序支持的格式（包含 miniprogram_dist/ ）将代码发布到npm，然后就可以在其他小程序项目里安装并使用了。小程序项目安装npm包有点麻烦。首先在小程序代码根目录（project.config.json中miniprogramRoot配置的目录）中依次执行：npm init\r\nnpm i weapp-plugin-dashboard -S --production    // 此处以安装weapp-plugin-dashboard模块为例\r\n只有这样安装的模块才算数，一开始我随手创建了个 package.json 文件写上依赖包名称，然后执行 npm i ，虽然模块也下载了，但会在下一步的开发者工具中报错，提示找不到npm包，可能是因为 package.json 文件不规范，但是文档没有告知怎样的 package.json 才算规范。安装完毕后，在开发者工具中看不到 node_modules/ 这个目录，因为此时这些模块小程序还并不支持，需要再构建一下才能用。首先，在开发者工具的项目配置里开启 使用npm模块 ，然后执行“工具-构建npm”操作，成功后会产出一个 miniprogram_npm/ 文件夹，这个文件夹是可以在开发者工具中看到的，到这一步npm包才算真的安装成功，可以在小程序项目中正常调用了。结语再放一遍项目地址吧，注意项目里的代码是开发工程的代码，需要运行构建命令（ npm run build ）才能得到小程序组件代码。想在项目里使用组件也可以直接npm安装 weapp-plugin-dashboard ，具体步骤前面说过了。Github： https://github.com/tower1229/weapp-plugin-dashboard再说点小程序开发的话题。截至目前，小程序开发相关的讨论，热门话题基本都是围绕那些“一次开发，处处运行”的轮子，什么taro啊uni-app啊，这些东西在我看来跟“生态”不沾边，起码在目前这个大局未定的阶段，可以说除了炫技毫无意义，任何对团队负责的架构师都不应该选择这种技术栈。我理解的生态，比如三方组件库，在小程序这几乎是市场空白；只面向企业开放的小程序插件，也没见到个正经推广的；杀手级应用也很少，大部分都是昙花一现，或者游戏类的；总体感觉就是，小程序开发没有热度，新手都在学，主力都在观望。这可能是因为小程序还没有找到合理的变现模式，如果任何一个企业如果能率先通过小程序打通一个商业模式，那么至少能带动同行业的所有企业复制这种模式，这样开发者的开发场景就会高度集中，大家面临的问题都很相似，才有可能产生流行的三方组件，进而促成生态繁荣。问题是，曾经的那些“变现模式”都迅速被微信封杀了，那么微信自己到底怎么定义小程序呢？小程序显然不是一个像HTML5那样的“通用媒介”，很多事情在小程序上不能做，而且这个不能做的范围，与其说是技术限制，倒不如说是人为的“政策限制”，而且这个政策非常之模糊和不确定。涉及到流量的不行，涉及到腾讯竞品行业的不行，涉及到钱的，我觉得就算让我做我也不敢做，因为今天可以的，明天可能就不可以了，生杀大权全在微信一句话，或者连句话都没有。就是说微信不准备让小程序成为一个公益性质的第三方平台，而是希望小程序只为微信服务，让符合微信利益的服务商以微信喜欢的方式接入，然后以小程序的形式替代对应的原生APP，从而完成对一整个“生态位”的吞噬，到那时恐怕连操作系统都要面向“微信”开发了。照这个思路，个人开发者对微信来说，可能只是免费的外部测试团队吧。"}
{"title": "【小程序 + 云开发】体重记录小程序 上手笔记 ", "author": "Rolan", "put_time": "2019-7-23 00:25", "content": "刚刚提交的小程序审核通过了，把笔记发出来。\r\n前一段看到朋友圈里总是有人用txt记录体重，就特别想写一个记录体重的小程序，\r\n现在小程序的云开发有云函数、数据库，真的挺好用，很适合个人开发者，服务器域名什么都不用管，云开发让你完全不用操心这些东西。\r\n先看看页面效果图吧：\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n记录的几个点：\r\n\r\n全局变量 globalData\r\nnpm 的使用\r\n云函数\r\n数据库操作\r\nasync 的使用\r\n分享的配置\r\nantV使用\r\ntabBar地址跳转\r\n切换页面刷新\r\n\r\n1.全局变量 globalData\r\n首次进入后，要存储openId给其他页面使用，使用globalData共享。\r\n<!--app.js 设置 globalData.openid --> \r\nApp({\r\n  onLaunch: function () {\r\n\r\n    this.globalData = {}\r\n\r\n    wx.cloud.init({})\r\n\r\n    wx.cloud.callFunction({\r\n      name: 'login',\r\n      data: {},\r\n      success: res => {\r\n        this.globalData.openid = res.result.openid\r\n        wx.switchTab({\r\n          url: '/pages/add/add',\r\n          fail: function(e) {}\r\n        })\r\n      }, \r\n      fail: err => { \r\n     \r\n      }\r\n    })\r\n\r\n  }\r\n})\r\n\r\n<!--其他页面引用-->\r\nconst app = getApp()  // 获得实例\r\napp.globalData.openid // 直接引用即可\r\n复制代码2.npm 的使用\r\n\r\n进入小程序源码miniprogram目录，创建package.json文件（使用npm init一路回车）\r\nnpm i --save 我们要安装的npm包\r\n设置微信开发者工具 构建npm\r\npackage.json增加\"miniprogram\": \"dist\"打包目录字段，如果不设置的话上传和预览不成功，提示文件包过大。\r\n\r\ncd miniprogram\r\nnpm init \r\nnpm i @antv/f2-canvas --save   // 我用到了f2，可以换成其他包\r\n复制代码设置微信开发者工具\r\n\r\n构建npm\r\n\r\n最后，务必添加miniprogram字段\r\n{\r\n  \"name\": \"21Day\",\r\n  \"version\": \"1.1.0\",\r\n  \"miniprogram\": \"dist\",\r\n  \"description\": \"一个21天体重记录的app\",\r\n  \"license\": \"MIT\",\r\n  \"dependencies\": {\r\n    \"@antv/f2-canvas\": \"~1.0.5\",\r\n    \"@antv/wx-f2\": \"~1.1.4\"\r\n  },\r\n  \"devDependencies\": {}\r\n}\r\n复制代码3.云函数\r\n官方解释云函数即在云端（服务器端）运行的函数，服务端是node.js，都是JavaScript。官方有数据库的操作，但是更新的操作强制要求使用云函数,\r\n另外，如果云函数中使用了npm包，记得在所在云函数文件夹右键上传并部署，不然运行失败。\r\n\r\n上一个例子，更新体重的云函数\r\n// 云函数\r\nconst cloud = require('wx-server-sdk')\r\nconst moment = require('moment')\r\n\r\ncloud.init(\r\n  { traceUser: true }\r\n)\r\n\r\nconst db = cloud.database()\r\nconst wxContext = cloud.getWXContext()\r\n\r\nexports.main = async (event, context) => {\r\n  // event 入参参数\r\n  delete event.userInfo\r\n  try {\r\n    return await db.collection('list').where({\r\n      _openid:wxContext.OPENID,\r\n      date:moment().format('YYYY-MM-DD')\r\n    })\r\n    .update({\r\n      data: {\r\n      \t...event\r\n      },\r\n    })\r\n  } catch(e) {\r\n    console.error(e)\r\n  }\r\n}\r\n复制代码小程序端调用\r\nwx.cloud.callFunction({\r\n     name: 'add',\r\n     data: {\r\n      ...Param\r\n     },\r\n     success: res => {\r\n        wx.showToast({\r\n          title: '新增记录成功',\r\n        })\r\n     },\r\n     fail: err => { \r\n        wx.showToast({\r\n          icon: 'none',\r\n          title: '新增记录失败'\r\n        })\r\n     }\r\n   })\r\n复制代码4.数据库操作\r\n其实是接入的MongoDB，封装了一部分api出来，详细的就看官方文档把，有区分服务端和小程序段。\r\nconst db = wx.cloud.database()\r\n\r\n// 查询数据\r\ndb.collection('list').where({\r\n    _openid: app.globalData.openid,\r\n    date: moment().subtract(1, 'days').format('YYYY-MM-DD'),\r\n}).get({\r\n    success: function (res) {\r\n        // do someThing\r\n    }\r\n})\r\n复制代码5.async 的使用\r\n\r\n官方文档提示不支持async，需要引入regeneratorRuntime这个包，先npm i regenerator。\r\n然后把node_modules文件夹下的regenerator-runtime的runtime-module.js和runtime.js两个文件拷贝到lib目录下，在页面上引入即可。\r\n<!--事例-->\r\nconst regeneratorRuntime = require('../../lib/runtime.js')\r\nonLoad: async function (options) {\r\n\r\n    // 获取当天数据\r\n    await this.step1()\r\n\r\n    // 时间类型设置\r\n    let nowHour = moment().hour(),timeType\r\n    nowHour > 12 ? timeType = 'evening' : timeType = 'morning'\r\n    this.setData({timeType})\r\n  }\r\n复制代码6.分享的配置\r\n分享很简单，有区分右上角的直接分享和点击按钮分享\r\nonShareAppMessage: function (res) {\r\n        \r\n      // 右上角分享\r\n      let ShareOption = {\r\n        title: '21天体重减肥记录',\r\n        path: '/pages/index/index',\r\n      } \r\n      \r\n      // 按钮分享\r\n      if(res.from == \"button\"){\r\n        ShareOption = {\r\n            title: '来呀 看看我的减肥记录呀',\r\n            path: '/pages/detail/detail?item=' + app.globalData.openid,\r\n          } \r\n      }\r\n      \r\n      return ShareOption\r\n  }\r\n复制代码分享后，他人点击页面，跳转到对应pages地址，从onLoad的options中拿入参请求数即可\r\nonLoad: function (options) {\r\n    const db = wx.cloud.database()\r\n    let This = this\r\n    let resault = {}\r\n    db.collection('list').where({\r\n      _openid: options.item\r\n    }).get({\r\n      success: function (res) {\r\n        resault = res.data\r\n        This.setData({\r\n          resault:resault\r\n        })\r\n\r\n      }\r\n    })\r\n  },\r\n复制代码7.antV使用\r\n上边第二小节有提到antV的安装，就不再赘述，直接说一下再页面中引用。\r\n说下使用，需要设置一个全局变量储存图表的实例，然后在钩子函数内容使用changeData方法修改数据。\r\nindex.json中引入包名\r\n{\r\n  \"usingComponents\": {\r\n  \t\"ff-canvas\": \"@antv/f2-canvas\"\r\n  }\r\n}\r\n复制代码// 引入F2\r\nimport F2 from '@antv/wx-f2';\r\n\r\n// 设置实例全局变量（务必）\r\nlet chart = null;\r\nfunction initChart(canvas, width, height, F2) { // 使用 F2 绘制图表\r\n  let data = [\r\n    // { timestamp: '1951 年', step: 38 },\r\n  ];\r\n\r\n  chart = new F2.Chart({\r\n    el: canvas,\r\n    width,\r\n    height\r\n  });\r\n\r\n  chart.source(data, {\r\n    step: {\r\n      tickCount: 5\r\n    },\r\n    timestamp: {\r\n      tickCount: 8\r\n    },\r\n\r\n  });\r\n\r\n\r\n  chart.axis('timestamp', {\r\n    label(text, index, total) {\r\n      const textCfg = {};\r\n      if (index === 0) {\r\n        textCfg.textAlign = 'left';\r\n      }\r\n      if (index === total - 1) {\r\n        textCfg.textAlign = 'right';\r\n      }\r\n      return textCfg;\r\n    }\r\n  });\r\n\r\n  chart.axis('step', {\r\n    label(text) {\r\n      return {\r\n        text: text / 1000 + 'k步'\r\n      };\r\n    }\r\n  });\r\n\r\n  chart.tooltip({\r\n    showItemMarker: false,\r\n    onShow(ev) {\r\n      const { items } = ev;\r\n      items[0].name = null;\r\n      items[0].name = items[0].title;\r\n      items[0].value = items[0].value + '步';\r\n    }\r\n  });\r\n  chart.area().position('timestamp*step').shape('smooth').color('l(0) 0:#F2C587 0.5:#ED7973 1:#8659AF');\r\n  chart.line().position('timestamp*step').shape('smooth').color('l(0) 0:#F2C587 0.5:#ED7973 1:#8659AF');\r\n  chart.render();\r\n  return chart;\r\n}\r\n\r\n// 生命周期函数\r\nonLoad(){\r\n    // 使用changeData赋值\r\n    chart.changeData(stepInfoList)\r\n}\r\n复制代码8.tabBar地址跳转\r\n如果要跳转的地址不在app.json的tabBar内可以使用wx.navigateTo，如果在死活跳不过去，要使用wx.switchTab方法跳转。\r\nwx.switchTab({\r\n  url: '/pages/add/add',\r\n  fail: function(e) {}\r\n})\r\n\r\nwx.navigateTo({\r\n  url: '../deployFunctions/deployFunctions',\r\n})\r\n复制代码9.切换页面刷新\r\n切换几个tabBar的时候，需要刷新数据。\r\n在onShow方法中再调用一下onLoad方法就可以了。\r\nonShow: function () {\r\n    this.onLoad()\r\n}\r\n复制代码感受\r\n\r\n很适合个人开发者，想开发一个小程序，除了时间，完全没有其他费用\r\n报错提示不友好，有时候不执行不报错，只能一行一行debug。\r\n审核超快，几个小时就审核通过了。\r\nlodash不支持，据说要修改点东西，就没鼓捣。\r\ngit也配置上了，真的是方便，再感叹一下，不过语法真的是。。。。不想用。\r\n\r\n后记\r\n不知道自己能更几个版本，不过跟着练习呗，空了就更新。\r\n立个flag，写下list 哈哈。\r\n\r\nv1.0\r\n\r\n挑战邀请页\r\n\r\n\r\nv2.0\r\n\r\n每日一句减肥知识\r\n社交奖励\r\n签到后鼓励语句\r\n朋友圈图片分享\r\n\r\n\r\nv3.0\r\n\r\n排行榜\r\n好习惯发表\r\n等级区分\r\n\r\n\r\n\r\n码字码到手酸，为自己加油。"}
{"title": "小程序 — 小程序生命周期及页面生命周期 ", "author": "Rolan", "put_time": "2019-7-23 00:30", "content": "前言：很多同学容易将小程序生命周期和页面的生命周期混淆为一起，这两个其实应该是不同却又相互关联的生命周期，所以，用实际代码操作并结合官方理论讲讲这个，好好捋捋。\r\n1、小程序生命周期\r\n（1）首先小程序的生命周期函数是在app.js里面调用的，App(Object)函数用来注册一个小程序。接受一个 Object 参数，指定其小程序的生命周期回调；一般有onLaunch监听小程序初始化、onShow监听小程序显示、onHide监听小程序隐藏等生命周期回调函数。\r\n（2）看文字对概念有点模糊对不对？理解概念的最好方法就是上手实际操作一遍。那么，我们来看看当打开一个小程序的时候，到底是onLaunch、onShow、onHide哪个先调用以及什么时候开始调用的。\r\nonLaunch() {  console.log('onLaunch监听小程序初始化');\r\n}\r\nonShow() {  console.log('onShow监听小程序显示');\r\n}\r\nonHide() {  console.log('onLaunch监听小程序隐藏');\r\n}\r\n打开小程序\r\n点击右上角按钮隐藏小程序有再次进入\r\n（3）从中我们可以知道小程序的生命周期函数的调用顺序为：onLaunch>onShow>onHide\r\n2、页面的生命周期\r\n（1）页面生命周期函数就是当你每进入/切换到一个新的页面的时候，就会调用的生命周期函数。Page(Object) 函数用来注册一个页面。接受一个Object类型参数，其指定页面的初始数据、生命周期回调、事件处理函数等。\r\n页面生命周期-截图来自小程序官网\r\n（2）老规矩，我们用代码来演示下各个页面生命周期函数的先后顺序。\r\n\r\n  onLoad(options) {    console.log('onLoad监听页面加载');\r\n  }\r\n\r\n  onReady() {    console.log('onReady监听页面初次渲染完成');\r\n  }\r\n\r\n  onShow() {    console.log('onShow监听页面显示');\r\n  }\r\n\r\n  onHide() {    console.log('onHide监听页面隐藏');\r\n  }\r\n\r\n  onUnload() {    console.log('onUnload监听页面卸载');\r\n  }\r\n\r\n复制代码页面生命周期函数\r\n从中我们可以知道小程序的生命周期函数的调用顺序为：onLoad>onReady>onShow；至于onHide函数就是当隐藏页面的时候触发。\r\n3、小结\r\n由此我们知道了“小程序程序生命周期函数”和“页面生命周期函数”的调用顺序；这两者之间的事件顺序一般如上图所示小程序周期函数在前，页面周期函数触发在后；\r\n但是，这 并不是绝对的，比如，有时候就会存在页面onLoad函数比小程序app的onLaunch生命周期函数先调用的情况，那么这时候就可以提出一个问题，那就是如何保证小程序的onLaunch事件的触发一定优先页面的onLoad事件？\r\n这是我们下一章《小程序的因难技巧》要解决的问题。"}
{"title": "如何在一个项目中兼容Wepy和Taro？ ", "author": "Rolan", "put_time": "2019-7-23 00:42", "content": "背景交待\r\nNJ 项目启动初期，团队技术栈主要是基于 Vue，技术选择上就选择了类 Vue 的 wepy。迭代几个版本后 mpvue 出来了，简单调研了下，准备基于 mpvue-simple 开发部分页面，如果可行再慢慢切换其它页面，尝试后遇到一些问题，就暂时搁置了，还是沿用的 wepy 继续开发。\r\nTaro 初现\r\n在不久之后 Taro 横空出世，按照团队的情况简单对比了一下 wepy、mpvue、taro、原生组件开发。\r\nLB 项目初期的情况是有一部分 wepy 沉淀，但是基本可以摆脱历史包袱，重新启动新业务项目，对于项目本身仅仅是一个活动小程序项目，不会做多端情况的考虑，在技术选择上因为各个技术方案基本解决的问题是多端开发以及在开发过程的舒适度上的提升。对于团队目前的情况来看，在几个小伙伴一起讨论后，还是基于 wepy 的方案来开发。\r\n如何迁移 Taro 到 Wepy\r\nNJ 项目本身还是基于 wepy，在迭代功能的时候，产品提出要做一个活动页面，这个活动可能在商城小程序中也会使用到，然后 NJ 继续迭代功能，需要考虑的是怎么复用商城项目组开发好的活动页面（商城项目基于 taro）。\r\n\r\n跳转到商城小程序参加活动 [pass]\r\n拷贝活动页面编译后的文件到 wepy 中直接使用 [cool]\r\n\r\n\r\n如图，上述文件以及不需要的页面均可以直接删除，然后配置路由到 wepy project 的 app.json 。实际可能也有一些父级逻辑放置在 app.js 中，这个看自己的业务情况来定，我们项目还引入来 dva ，在 wepy 的 app.js 中增加来一个处理 dva 的文件。这个迁移过程总体来说简单容易很多，暂时不做过多描述。\r\n如何迁移 Wepy 到 Taro\r\n为来更为简单的迁移，这中间写了一个插件来处理公共业务，对于业务逻辑可以在回调中单独处理，具体可以参考 wepy-plugin-migratetotaro\r\nNJ 项目经过长期迭代在线上稳定运行。同时另外一条业务线是基于 Taro 开发，也在疯狂开发迭代中。起因一次活动，XX 项目开发活动内容，NJ 项目正常需求开发，但是开发上线时需要复用 XX 项目开发好的活动页面。\r\n由于 Wepy2 目前仍处于 alpha ，1.7.x 在开发中也遇见了不少的问题。问题虽然最终都能解决，而且作者很好沟通，咨询过几次问题也都能耐心指导解答，笔芯感谢。\r\n再说项目实际情况，在迁移后要保证脱离 Taro 相关项目 Wepy 独立编译能够正常运行。\r\n目录结构约定\r\n- Taro\r\n    - src\r\n    - Wepy\r\n        - src\r\n复制代码代码管理在 taro project 以子模块的形式管理 wepy project\r\ngit submodules\r\n# 添加子模块项目\r\n> git submodule add <taro project url>\r\n\r\n# 初始化本地 .gitmodules 文件\r\n> git submodule init\r\n\r\n# 同步远端 submodule 源码\r\n> git submodule update\r\n复制代码.gitmodules 示例\r\n[submodule <submodule_name>]\r\n    path = <local_directory>\r\n    url = <remote_url>\r\n    branch = <remote_update_branch_name>\r\n复制代码迁移过程\r\n默认配置 wepy 编译后的目录（这里建议配置到 taro 编译目录同级目录下的子目录。下文均以 Taro 编译目录 dist 为例，wepy 编译到 dist/wepy 目录下）\r\n\r\n编译目标路径配置 wepy.config.js target\r\n安装插件 wepy-plugin-migratetotaro （待开发整理发布）\r\n\r\n加载机制 require('app.js') $instance （BASE）\r\n页面自动配置所有，可以手动配置需要引入的 pages，但是编译还是会编译所有的，编译过程不可控。暂时部分页面引入控制略有问题，这里建议开发过程中以页面为维度来管理页面资源，编译后不需要的页面可以手动删除。\r\n路由处理 页面路径配置按照编译路径最后一级文件夹自动更新引入路径中的 pages 的跳转路径 （BASE）\r\n所有路径添加到子模块路由中或者主模块中 路由配置两种模式，pages 模式 和 subPackages/pages 模式。对应的配置位置不一致，这一点由插件编译处理。\r\ntaro 组件在 wepy 中使用，在配置中新增 needComponents 配置需要使用组件的组件和页面。\r\n\r\n\r\n\r\n迁移过程中问题分析\r\n① annot read property '$pages' of undefined\r\n// 页面初始化的时候 $createPage 中 this.$instance 不存在\r\nif (typeof pagePath === \"string\") {\r\n  this.$instance.$pages[\"/\" + pagePath] = page;\r\n}\r\n\r\n// this.$instance 来源于 $createApp\r\nlet app = new appClass();\r\n\r\nif (!this.$instance) {\r\n  app.$init(this, appConfig);\r\n  this.$instance = app;\r\n  this.$appConfig = appConfig;\r\n}\r\n\r\n// appClass 来源于参数 对应 app.wpy\r\n// 如果页面要单独执行必须加载一下 app.wpy 但是插件处理的是编译后的文件，这里只能在每个页面 page 中单独加入 require(wepy/app.js)\r\n复制代码② 资源引用，建议图片视频等资源使用相对路径引用，如果项目已有绝对资源路径可以通过插件回调手动替换处理\r\n③ Taro 组件共享，见后续 taro 组件共享使用方法\r\n如何在 wepy 中使用 taro 写的组件\r\n这种略待代码侵入的感觉，可以使用环境变量来处理，只是使用迁移编译时才生效插件的引入。我们使用插件引入这种是在自定义底部 tabbar 后有一个页面需要。\r\n\r\n\r\nwepy page 中引入 taro 项目中的 demo 组件\r\nconfig = {\r\n    ...\r\n\r\n    usingComponents: {\r\n        'demo': '/components/demo/index'\r\n    }\r\n\r\n    ...\r\n}\r\n复制代码\r\n\r\ntemplate 中使用组件\r\n...\r\n\r\n<demo compid=\"demo\"></demo>\r\n\r\n...\r\n复制代码\r\n\r\n父页面向子组件传递参数（配合插件配置 needComponents 使用，如果原生小程序或者其它框架需要使用 taro 组件可以使用类似方案）\r\n// 按照实际情况修改 props 和 compId\r\ntaro.propsManager.set(\r\n  {\r\n    ...props\r\n  },\r\n  compId\r\n);\r\n复制代码\r\n\r\n思索\r\nwepy taro 解决的问题是什么？对于我而言。\r\n一部分是追求与团队当前技术栈相契合的类似方案。\r\n一部分是多端需求（最新的这个小程序是多个产品的数据整合，其中之前一个产品是 H5 对外可能微信小程序不是合适的选择，一个是小程序，如果统一到一起，后续小程序部分页面可能也会直接转 H5，后续还可能数据要整合到已有 APP，如此转 RN 等也是未来的需求），这一块是为以后做的考虑，如若不然还是原生的来的自然。\r\n这中间更多的应该是思考，我们其实只是针对当前的产品选择一个适合自己的技术方案，不抱着某一种方案自始自终，也不抵触技术的更新，更多的还是需要在这业务堆积过程中不断沉淀出一些东西，然后不断更新自己的知识仓库，这个才是接下来自己要坚持完善的部分。\r\n参考资料\r\nwepy-plugin-migratetotaro\r\n这是一个不相关的参考资料，可以微信扫码浏览一下就走"}
{"title": "页面进入后台如何关闭背景音乐 ", "author": "Rolan", "put_time": "2019-7-24 00:15", "content": "之前在做小程序的时候遇到一个问题：小程序中有一个webview页面，这个页面中用iframe嵌套了一个H5页面，这个H5页面中有背景音乐，背景音乐播放的情况下，点击小程序右上角退出的小圆圈背景音乐仍然播放。预期效果：点击小程序退出后背景音乐停止播放，再次打开小程序后背景音乐继续播放，如果用户停止了音乐，退出再次打开时背景音乐仍然是停止状态思路过程：因为H5页面是嵌套的，音乐在H5页面中，无法通过小程序的生命周期去控制音乐的播放状态，所以如何能在H5页面中监听页面的显隐藏状态去控制音乐visibilitychange ：浏览器标签页被隐藏或显示的时候会触发适用场景：浏览器标签页切换时触发微信环境下切成浮窗状态触发小程序嵌套页面，小程序切换页面或进入后台触发其他页面显隐切换时触发解决方案：let statusBeforeHide = true; // 记录页面切换到后台时音乐的播放状态，如果用户进行了音乐关闭操作，则将该状态置为false\r\n// document.hidden boolean 页面当前是否不可见\r\nlet hiddenProperty = ('hidden' in document) ? 'hidden'\r\n        : ('webkitHidden' in document) ? 'webkitHidden'\r\n            : ('mozHidden' in document) ? 'mozHidden' : null;\r\nif (hiddenProperty) {\r\n    let visibilityChangeEvent = hiddenProperty.replace(/hidden/i, 'visibilitychange');\r\n    let onVisibilityChange = () => {\r\n        console.log('visibilityChange');\r\n        changePlay();\r\n    };\r\n    document.addEventListener(visibilityChangeEvent, onVisibilityChange);\r\n} else {\r\n    console.log(\"This demo requires a browser, such as Google Chrome or Firefox, that supports the Page Visibility API.\");\r\n}\r\n\r\n// 更改音乐播放状态\r\nfunction changePlay() {\r\n    if (document[hiddenProperty]) {\r\n        // 页面隐藏\r\n        if (statusBeforeHide) {\r\n            music.pause(); // 伪代码，音乐暂停，但不改变statusBeforeHide\r\n        }\r\n    } else {\r\n        // 页面显示\r\n        if (statusBeforeHide) {\r\n            music.play() // 伪代码，如果statusBeforeHide是true,音乐继续播放\r\n        }\r\n    }\r\n}拓展：1.可在页面后台运行时清掉一些定时器，页面显示时再重新设置定时器，节省性能"}
{"title": "微信小程序全局状态管理 wxscv ", "author": "Rolan", "put_time": "2019-7-24 00:34", "content": "微信小程序中，数据状态不同页面中不能跨页面同步更新，也就是缺失类似vuex,mobx,redux全局的数据状态管理功能。 有些人移植了这些库，但是毕竟不是微信小程序生态的东西。Tencent也发布了类似的库，叫做 westore，基于小程序开发，非常小巧好用，非常推荐。 但是由于重写了Page方法，而现在很多项目都有自己的框架（已经重写了Page方法等），重构代价较大， 所以参考实现了 wxscv，喜欢的朋友直接去github查看。设计思路想像model一样引入单独的数据模块，引入相同model的页面数据更新是同步的。 页面中的方法不重写Page,而是改为处理一下Page的option。使用示例const scv = require(\"../../libs/scv/scv.js\");\r\nPage(scv.observer({                          //初始化参数\r\n data:{\r\n   userinfo: scv.require(\"userinfo.js\")    //引入model\r\n },\r\n test:function(){\r\n   this.data.userinfo.nickName = \"awen\";   //设置数据\r\n   this.update();                          //更新数据\r\n },\r\n ...\r\n }))\r\n 基本所有的api就在上面了。scv.observer 初始化处理optionscv.require 引入数据model文件名this.data.xx=xx 直接修改数据this.update 更新数据修改，包括更新view和同步model修改到所有页面Model文件model以文件的方式存在，单独建立一个文件夹来存放model文件。默认的是 根目录下的models文件夹。如果要修改wxscv库文件或者models文件的存放默认位置。可以使用：**wx.__scvModelBaseDir=\"xxxx\"** 来设定models文件夹的路径，值得注意的是这是相对于scv.js文件的相对位置。let app = getApp();\r\n// 初始化数据\r\nlet defData = app.globalData.userInfo;\r\n// let defData = wx.getStorageSync(key)\r\nmodule.exports = {\r\n    // 数据\r\n    data:defData,\r\n    // 更新回调\r\n    onUpdate:function(){\r\n        console.log(\"onUpdate\", this.data);\r\n        app.globalData.userInfo = this.data;\r\n        // 也可以进行一些其他的数据操作。\r\n        // wx.setStorage({}) ...\r\n        // or wx.request({})\r\n    }\r\n}返回的对象分两部分data 返回的数据部分onUpdate model的数据修改后会调用该方法，可以在此处做一些数据或者业务操作全部就这些了。 简单就对了"}
{"title": "小程序使用canvas自适应屏幕画海报并保存图片 ", "author": "Rolan", "put_time": "2019-7-24 00:42", "content": "小程序canvas的API并没有像其他的一样支持小程序独有的 rpx 自适应尺寸单位，在绘制内容时所应用的单位仍然是 px，那么如何实现不同尺寸屏幕的自适应呢？\r\n我们的在开发中常用的参考屏幕尺寸（iPhone6）为：375*667；\r\n那么想要适应其他尺寸的屏幕时只需按照iPhone6的绘制大小按比例进行换算即可：\r\n获取系统屏幕尺寸\r\n先利用wx.getSystemInfo （获取系统信息）的API获取屏幕宽度，然后除iPhone6的屏幕宽度，即可得到相对单位\r\n// 在onLoad中调用\r\nconst that = this\r\nwx.getSystemInfo({\r\n  success: function (res) {\r\n    console.log(res)\r\n    that.setData({\r\n      model: res.model,\r\n      screen_width: res.windowWidth/375,\r\n      screen_height: res.windowHeight\r\n    })\r\n  }\r\n})\r\n复制代码在绘制方法中将参数乘以相对单位即可实现自适应\r\n这里的rpx是相对不同屏幕宽度的相对单位，测量出得实际宽度，就是实际测出的px像素值*rpx就可以了；之后无论实在iPhone5，iPhone6，iPhone7...都可以进行自适应。\r\n这里的html也要动态的设置宽和高\r\n<canvas  canvas-id=\"PosterCanvas\" style=\"width:{{screen_width*375+'px'}}; height:{{screen_height*1.21+'px'}}\"></canvas>\r\n复制代码drawPoster(){\r\n    let ctx = wx.createCanvasContext('PosterCanvas'),that=this.data;\r\n    console.log('手机型号' + that.model,'宽'+that.screen_width*375,'高'+ that.screen_height)\r\n    let rpx = that.screen_width\r\n    //这里的rpx是相对不同屏幕宽度的相对单位，实际的宽度测量，就是实际测出的px像素值*rpx就可以了；之后无论实在iPhone5，iPhone6，iPhone7...都可以进行自适应。\r\n    ctx.setFillStyle('#1A1A1A')\r\n    ctx.fillRect(0, 0, rpx * 375, that.screen_height * 1.21)\r\n    ctx.fillStyle = \"#E8CDAA\";\r\n    ctx.setFontSize(29*rpx)\r\n    ctx.font = 'normal 400  Source Han Sans CN';\r\n    ctx.fillText('Hi 朋友', 133*rpx,66*rpx)\r\n    ctx.fillText('先领礼品再买车', 84*rpx, 119*rpx)\r\n    ctx.drawImage('../../img/sell_index5.png', 26*rpx, 185*rpx, 324*rpx, 314*rpx)\r\n    ctx.drawImage('../../img/post_car2x.png', 66 * rpx, 222 * rpx, 243 * rpx, 145 * rpx)\r\n    ctx.setFontSize(16*rpx)\r\n    ctx.font = 'normal 400 Source Han Sans CN';\r\n    ctx.fillText('长按扫描获取更多优惠', 108*rpx, 545*rpx)\r\n    ctx.drawImage('../../img/code_icon2x.png', 68 * rpx, 575 * rpx, 79 * rpx, 79 * rpx)\r\n    ctx.drawImage('../../img/code2_icon2x.png', 229 * rpx, 575 * rpx, 79 * rpx, 79 * rpx)\r\n    ctx.setStrokeStyle('#666666')\r\n    ctx.setLineWidth(1*rpx)\r\n    ctx.lineTo(187*rpx,602*rpx)\r\n    ctx.lineTo(187*rpx, 630*rpx)\r\n    ctx.stroke()\r\n    ctx.fillStyle = \"#fff\"\r\n    ctx.setFontSize(13 * rpx)\r\n    ctx.fillText('xxx科技汽车销售公司', 119 * rpx, 663 * rpx)\r\n    ctx.fillStyle = \"#666666\"\r\n    ctx.fillText('朝阳区·望京xxx科技大厦', 109 * rpx, 689 * rpx)\r\n    ctx.setFillStyle('#fff')\r\n    ctx.draw()\r\n  },\r\n复制代码\r\n\r\n\r\n\r\n保存到相册\r\n很简单就是在画完图片之后的draw回调函数里调用canvasToTempFilePath()生产一个零时内存里的链接，然后在调用saveImageToPhotosAlbum()就可以了；其中牵扯到授权，如果你第一次拒绝了授权，你第二次进入的时候在iphone手机上是不会再次提醒你授权的，这时就需要你手动调用了；以下附上代码！\r\nctx.draw(true, ()=>{\r\n        // console.log('画完了')\r\n        wx.canvasToTempFilePath()({\r\n          x: 0,\r\n          y: 0,\r\n          width: rpx * 375,\r\n          height: that.screen_height * 1.21,\r\n          canvasId: 'PosterCanvas',\r\n          success: function (res) {\r\n            // console.log(res.tempFilePath);\r\n            wx.saveImageToPhotosAlbum({\r\n              filePath: res.tempFilePath,\r\n              success: (res) => {\r\n                console.log(res)\r\n              },\r\n              fail: (err) => { }\r\n            })\r\n\r\n          }\r\n        }) \r\n      })\r\n复制代码拒绝授权后再次提醒授权的代码\r\nmpvue.saveImageToPhotosAlbum({\r\n        filePath: __path,\r\n        success(res) {\r\n          mpvue.showToast({\r\n          title: '保存成功',\r\n          icon: 'success',\r\n          duration: 800,\r\n          mask:true\r\n          });\r\n         },\r\n        fail(res) {\r\n            if (res.errMsg === \"saveImageToPhotosAlbum:fail:auth denied\" || res.errMsg === \"saveImageToPhotosAlbum:fail auth deny\" || res.errMsg === \"saveImageToPhotosAlbum:fail authorize no response\") {\r\n\r\n          mpvue.showModal({\r\n                title: '提示',\r\n                content: '需要您授权保存相册',\r\n                showCancel: false,\r\n                success:modalSuccess=>{\r\n                  mpvue.openSetting({\r\n                    success(settingdata) {\r\n                      // console.log(\"settingdata\", settingdata)\r\n                      if (settingdata.authSetting['scope.writePhotosAlbum']) {\r\n                        mpvue.showModal({\r\n                          title: '提示',\r\n                          content: '获取权限成功,再次点击图片即可保存',\r\n                          showCancel: false,\r\n                        })\r\n                      } else {\r\n                        mpvue.showModal({\r\n                          title: '提示',\r\n                          content: '获取权限失败，将无法保存到相册哦~',\r\n                          showCancel: false,\r\n                        })\r\n                      }\r\n                    },\r\n                    fail(failData) {\r\n                      console.log(\"failData\",failData)\r\n                    },\r\n                    complete(finishData) {\r\n                      console.log(\"finishData\", finishData)\r\n                    }\r\n                  })\r\n                }\r\n              })\r\n          }\r\n         }\r\n      });\r\n\r\n复制代码至此就算完了，能帮到你就给点个赞吧！"}
{"title": "微信小程序下拉加载下一页 ", "author": "Rolan", "put_time": "2019-7-24 00:51", "content": "小程序做得多了，有些常用功能就有必要记录一下请看详解：微信小程序之下拉触底时加载下一页wxml参考：1234567891011<scroll-view class='dataContainer' scroll-y bindscrolltolower=\"nextDataPage\">       <block wx:for=\"{{userList}}\" wx:key=\"index\">            <text>这是一条数据：{{item.data}}</text>      </block>             <view class='bottomline' wx:if=\"{{userList.length > 0}}\" >{{isLastPage?\"没有更多数据了\":\"加载中...\"}}</view>      <view class='bottomline' wx:if=\"{{userList.length == 0}}\" >暂时没有数据</view>  </scroll-view> js参考：data: {\r\n    page:1,\r\n    rows:20,\r\n    isLastPage:false,\r\n    isLoadInterface: false,\r\n    userList:[]\r\n  },\r\n  //查询数据列表\r\n  searchDataList:function(pageNum){\r\n      let that = this;\r\n      let pageIndex = pageNum;\r\n      util.ajax({\r\n        url: '接口地址',\r\n        method: \"POST\",\r\n        data: {\r\n          \"page\": pageIndex,\r\n          \"rows\":that.data.rows\r\n        },\r\n        success: function (res) {\r\n\r\n          that.setData({\r\n            isLastPage:res.data.islast,\r\n            page: pageIndex,\r\n            isLoadInterface: false\r\n          })\r\n          \r\n          if(res.data.list != undefined){\r\n            if (pageIndex > 1){\r\n              var listBefore = that.data.userList;\r\n              var currentList = res.data.list;\r\n              that.setData({\r\n                userList:listBefore.concat(currentList)\r\n              })\r\n            }else{\r\n              that.setData({\r\n                userList: res.data.list\r\n              })\r\n            }\r\n          }\r\n\r\n        }, complete(e) {\r\n          that.setData({\r\n            isShowLoadPage: false\r\n          })\r\n        }\r\n      })  \r\n\r\n\r\n  },\r\n  // 加载下一页数据\r\n  nextDataPage: function () {\r\n    let that = this;\r\n\r\n    let islastVar = that.data.isLastPage;\r\n\r\n    if (!that.data.isLoadInterface) {\r\n      if (!islastVar) {\r\n        //防止在接口未执行完再次调用接口\r\n        that.setData({\r\n          isLoadInterface: true\r\n        })\r\n\r\n        let page = that.data.page * 1 + 1;\r\n\r\n        that.searchDataList(page);\r\n\r\n      }\r\n    }\r\n\r\n  },\r\n  /**\r\n   * 生命周期函数--监听页面加载\r\n   */\r\n  onLoad: function (options) {\r\n\r\n    var that = this;\r\n\r\n    \r\n    let page = that.data.page;\r\n    that.searchDataList(page);\r\n\r\n  }思路：以小程序标签scroll-view作为列表容器，容器方法bindscrolltolower来触发下一页加载　　   页面onload后执行第一页，非第一页的数据用concat方法拼接之前的数据　　　防止接口未执行完反复触发bindscrolltolower里的方法，用一个变量isLoadInterface来截断　　　接口的数据中应有islast这类是否最后一页的参数，用来判断是否加载全部数据"}
{"title": "微信小程序支付功能全流程实践 ", "author": "Rolan", "put_time": "2019-7-25 00:13", "content": "微信小程序为电商类小程序，提供了非常完善、优秀、安全的支付功能。在小程序内可调用微信的API完成支付功能，方便、快捷。小程序开发者在开发小程序时，支付流程是必然要接触到，今天胡哥就小程序支付的全流程为大家一一细说，让小伙伴能快速得掌握小程序支付能力，避免踩坑！知己知彼，方能百战不殆 - 小程序支付流程图举个栗子:chestnut:：某用户小明在某电商小程序上购买一块肥皂，从浏览、下单到支付经历了什么样的过程呢？打开电商小程序，搜索浏览到某雕肥皂，点击查看详情后，发现大小、丝滑程度都很合适，点击直接下单wx.login获取用户临时登录凭证code，发送到后端服务器换取openId在下单时，小程序需要将小明购买的商品Id，商品数量，以及小明这个用户的openId传送到服务器服务器在接收到商品Id、商品数量、openId后，生成服务期订单数据，同时经过一定的签名算法，向微信支付发送请求，获取预付单信息(prepay_id)，同时将获取的数据再次进行相应规则的签名，向小程序端响应必要的信息(必须字段信息将在下文进行详细说明)小程序端在获取对应的参数后，调用wx.requestPayment()发起微信支付，唤醒支付工作台，进行支付小结进行微信支付，在小程序端我们主要做三件事：注：服务端调用统一下单API、签名算法不再本次分享讨论范围内，请期待胡哥的另外一次分享。使用** wx.login **获取临时登录凭证code,发送到后端获取openIdwx.login({\r\n  success (res) {\r\n    if (res.code) {\r\n      // 发起请求，换取openId\r\n      wx.request({\r\n        url: '',\r\n        data: {\r\n          code: res.code\r\n        }\r\n      })\r\n    }\r\n  }\r\n})\r\n复制代码将** openId **以及相应需要的商品信息发送到后端，换取服务端进行的签名等信息wx.request({\r\n  url: '',\r\n  data: {\r\n    openId: '',\r\n    num: 1,\r\n    id: '111'\r\n  }\r\n})\r\n复制代码接收返回的信息（必须要包含发起微信支付** wx.requestPayment的参数 **），发起微信支付wx.requestPayment({\r\n  // 时间戳\r\n  timeStamp: '',\r\n  // 随机字符串\r\n  nonceStr: '',\r\n  // 统一下单接口返回的 prepay_id 参数值\r\n  package: '',\r\n  // 签名类型\r\n  signType: '',\r\n  // 签名\r\n  paySign: '',\r\n  // 调用成功回调\r\n  success () {},\r\n  // 失败回调\r\n  fail () {},\r\n  // 接口调用结束回调\r\n  complete () {}\r\n})\r\n复制代码注意：以上信息中 timeStamp 、 nonceStr 、 prepay_id 、 signType 、 paySign 各参数均建议必须都由服务端返回（这样会尽最大可能性保证签名数据一致性），小程序端不做任何处理基于Taro的微信支付实例import Taro, { Component } from '@tarojs/taro'\r\nimport { View, Text, Button } from '@tarojs/components'\r\nimport './index.scss'\r\n\r\nexport default class Index extends Component {\r\n\r\n  config = {\r\n    navigationBarTitleText: '首页'\r\n  }\r\n\r\n  componentWillMount () { }\r\n\r\n  async componentDidMount () { \r\n  }\r\n\r\n  componentWillUnmount () { }\r\n\r\n  componentDidShow () { }\r\n\r\n  componentDidHide () { }\r\n\r\n  /**\r\n   * sendOrderInfo()\r\n   * @description 提交订单信息，获取支付凭证，唤起支付\r\n   */\r\n  async sendOrderInfo () {\r\n    // 获取临时登录凭证code\r\n    let codeData = await Taro.login()\r\n    // 换取openId\r\n    let openId = ''\r\n    if (codeData.code) {\r\n      let res = await Taro.request({\r\n        // 定义的后端换取openId的接口\r\n        url: 'https://www.justbecoder.com/getLogin',\r\n        data: {\r\n          code: codeData.code\r\n        }\r\n      })\r\n      if (res && res.code === 0) {\r\n        openId = res.openId\r\n      }\r\n    }\r\n    // 发送openId以及对应的商品信息\r\n    let data = await Taro.requrest({\r\n      url: 'https://www.justbecoder.com/createdOrder',\r\n      data: {\r\n        openId,\r\n        // 实际情况的商品数量\r\n        num: 1,\r\n        // 实际情况的商品Id\r\n        id: 111,\r\n      }\r\n    })\r\n    // code === 0 表示提交订单成功，返回需要的签名信息等\r\n    if (data && data.code === 0) {\r\n      let {\r\n        timeStamp,\r\n        nonceStr,\r\n        prepay_id,\r\n        signType,\r\n        paySign\r\n      } = data.payInfo\r\n      // 唤起支付，按小程序要求格式发送参数\r\n      let payData = await Taro.requestPayment({\r\n        timeStamp,\r\n        nonceStr,\r\n        package: 'prepay_id=' + prepay_id,\r\n        signType,\r\n        paySign\r\n      })\r\n      if (payData && payData.errMsg === 'requestPayment:ok') {\r\n        Taro.showModal({\r\n          title: '操作提示',\r\n          content: '支付成功',\r\n          showCancel: false,\r\n          confirmText: '确定'\r\n        })\r\n      } else {\r\n        Taro.showModal({\r\n          title: '操作提示',\r\n          content: '支付失败，请重新尝试',\r\n          showCancel: false,\r\n          confirmText: '确定'\r\n        })\r\n      }\r\n    }\r\n  }\r\n\r\n  render () {\r\n    return (\r\n      <View className='index'>\r\n        <Button onClick={this.sendOrderInfo}>立即下单</Button>\r\n      </View>\r\n    )\r\n  }\r\n}\r\n复制代码效果图结语在实际项目操作中，大家把接口换成自己的可用接口即可。后记以上就是胡哥今天给大家分享的内容，喜欢的小伙伴记得** 收藏 、 转发 、点击右下角按钮 在看 **，推荐给更多小伙伴呦，欢迎多多留言交流...胡哥有话说，一个有技术，有情怀的胡哥！京东开放平台首席前端攻城狮。与你一起聊聊大前端，分享前端系统架构，框架实现原理，最新最高效的技术实践！"}
{"title": "微信小程序踩坑日记1——调用微信授权窗口 ", "author": "Rolan", "put_time": "2019-7-25 00:28", "content": "0. 引言　　微信小程序为了优化用户体验，取消了在进入小程序时立马出现授权窗口。需要用户主动点击按钮，触发授权窗口。　　那么，在我实践过程中，出现了以下问题。1. 无法弹出授权窗口\r\n2. 希望在用户已经授权的情况下，不显示按钮1. 具体实现　　app.js的onLaunch()函数中，添加获取用户个人信息的代码段。实现在用户已经授权的情况（例如第二次打开小程序时）下，自动获取用户个人信息，而不需要用户的授权。// 获取用户信息\r\nwx.getSetting({\r\n    success: res => {\r\n        if (res.authSetting['scope.userInfo']) {\r\n            console.log(\"app: \" + \"用户已经授权\")\r\n            // 已经授权，可以直接调用 getUserInfo 获取头像昵称，不会弹框\r\n            wx.getUserInfo({\r\n                success: res => {\r\n                    // 可以将 res 发送给后台解码出 unionId\r\n                    this.globalData.userInfo = res.userInfo\r\n                    console.log(this.globalData.userInfo)\r\n                    this.globalData.hasUserInfo = true\r\n                    // 由于 getUserInfo 是网络请求，可能会在 Page.onLoad 之后才返回\r\n                    // 所以此处加入 callback 以防止这种情况\r\n                    if (this.userInfoReadyCallback) {\r\n                        this.userInfoReadyCallback(res)\r\n                    }\r\n                },\r\n                fail: (res) => {\r\n                    console.log(\"app: \" + \"获取用户信息失败\")\r\n                }\r\n            })\r\n        }else {\r\n            console.log(\"app: \" + \"用户暂时未授权\")\r\n        }\r\n    }\r\n})　　me.wxml中添加授权按钮（具体的页面根据大家的实际情况）。这里的button组件必须按照如下的形式。<button open-type=\"getUserInfo\" bindgetuserinfo=\"你自己定义函数\"></button><block wx:if=\"{{!hasUserInfo}}\">\r\n    <image src='../../images/icon/wechat.png'></image>\r\n    <button open-type=\"getUserInfo\" bindgetuserinfo=\"getUserInfo\">微信授权登录</button>\r\n</block>　　效果这样，具体的样式根据大家的喜好更改 　　me.js中添加如下变量和方法，在用户之前没有授权的情况下，需要用户主动点击按钮。data: {\r\n    userInfo: null,\r\n    hasUserInfo: false\r\n},\r\ngetUserInfo: function(e) {\r\n    console.log(\"me: \" + \"用户点击授权\")\r\n    if(e.detail.userInfo){\r\n        this.setData({\r\n            userInfo: e.detail.userInfo,\r\n            hasUserInfo: true\r\n        })\r\n        app.data.userInfo = this.userInfo\r\n        app.data.hasUserInfo = true\r\n    }\r\n}2. 无法弹出授权窗口　　这里一定要注意　　授权窗口只会在用户第一次授权时出现，也就是，只会出现一次！！　　在微信小程序开发工具里，需要我们清除所有缓存3. 已经授权的情况下，不显示按钮　　由于用户已经授权的时候，app.js会获取用户个人信息（而不是在用户点击授权按钮时获取），但是这个过程是异步的。　　可以看到我们的授权按钮的出现时根据{{!hasUserInfo}}的真值来判断，这个值可以通过app.js是否获取了信息来赋值。<block wx:if=\"{{!hasUserInfo}}\">\r\n    <image class=\"userAvatar\" src='../../images/icon/wechat.png'></image>\r\n    <button open-type=\"getUserInfo\" bindgetuserinfo=\"getUserInfo\">微信授权登录</button>\r\n</block>　　但是，可能出现用户已经授权了，但是app.js获取个人信息时过慢，然而我们的授权按钮却错误的以为app.js没有获取到信息，所以将授权按钮渲染了出来。　　这时，我们希望，在app.js判断用户已经授权且获取到信息后，告诉我们的授权按钮。　　我们在me.js中添加如下代码段。onLoad: function() {\r\n    // 获取个人信息\r\n    if(app.globalData.userInfo){\r\n        this.setData({\r\n            userInfo: app.globalData.userInfo,\r\n            hasUserInfo: true\r\n        })\r\n    }else{\r\n        // 在app.js没有获取到信息时，判断app.js的异步操作是否返回信息\r\n        app.userInfoReadyCallback = res => {\r\n            this.setData({\r\n                userInfo: app.globalData.userInfo,\r\n                hasUserInfo: true\r\n            })\r\n        }\r\n    }\r\n}　　为什么这里会有个app.userInfoReadyCallback函数呢，我们注意到在app.js的wx.getSetting里有一段回调函数，这个函数就是用来解决异步的问题。"}
{"title": "小程序·云开发实战 - 迷你微博 ", "author": "Rolan", "put_time": "2019-7-25 00:42", "content": "0. 前言\r\n本文将手把手教你如何写出迷你版微博的一行行代码，迷你版微博包含以下功能：\r\n\r\nFeed 流：关注动态、所有动态\r\n发送图文动态\r\n搜索用户\r\n关注系统\r\n点赞动态\r\n个人主页\r\n\r\n使用到的云开发能力：\r\n\r\n云数据库\r\n云存储\r\n云函数\r\n云调用\r\n\r\n没错，几乎是所有的云开发能力。也就是说，读完这篇实战，你就相当于完全入门了云开发！\r\n咳咳，当然，实际上这里只是介绍核心逻辑和重点代码片段，完整代码建议下载查看。\r\n1. 取得授权\r\n作为一个社交平台，首先要做的肯定是经过用户授权，获取用户信息，小程序提供了很方便的接口：\r\n<button open-type=\"getUserInfo\" bindgetuserinfo=\"getUserInfo\">\r\n  进入小圈圈\r\n</button>\r\n复制代码这个 button 有个 open-type 属性，这个属性是专门用来使用小程序的开放能力的，而 getUserInfo 则表示 获取用户信息，可以从bindgetuserinfo回调中获取到用户信息。\r\n于是我们可以在 wxml 里放入这个 button 后，在相应的 js 里写如下代码：\r\nPage({\r\n  ...\r\n\r\n  getUserInfo: function(e) {\r\n    wx.navigateTo({\r\n      url: \"/pages/circle/circle\"\r\n    })\r\n  },\r\n\r\n  ...\r\n})\r\n复制代码这样在成功获取到用户信息后，我们就能跳转到迷你微博页面了。\r\n需要注意，不能使用 wx.authorize({scope: \"scope.userInfo\"}) 来获取读取用户信息的权限，因为它不会跳出授权弹窗。目前只能使用上面所述的方式实现。\r\n2. 主页设计\r\n社交平台的主页大同小异，主要由三个部分组成：\r\n\r\nFeed 流\r\n消息\r\n个人信息\r\n\r\n那么很容易就能想到这样的布局（注意新建一个 Page 哦，路径：pages/circle/circle.wxml）：\r\n<view class=\"circle-container\">\r\n  <view\r\n    style=\"display:{{currentPage === 'main' ? 'block' : 'none'}}\"\r\n    class=\"main-area\"\r\n  >\r\n  </view>\r\n\r\n  <view\r\n    style=\"display:{{currentPage === 'msg' ? 'flex' : 'none'}}\"\r\n    class=\"msg-area\"\r\n  >\r\n  </view>\r\n\r\n  <view\r\n    style=\"display:{{currentPage === 'me' ? 'flex' : 'none'}}\"\r\n    class=\"me-area\"\r\n  >\r\n  </view>\r\n\r\n  <view class=\"footer\">\r\n    <view class=\"footer-item\">\r\n      <button\r\n        class=\"footer-btn\"\r\n        bindtap=\"onPageMainTap\"\r\n        style=\"background: {{currentPage === 'main' ? '#111' : 'rgba(0,0,0,0)'}}; color: {{currentPage === 'main' ? '#fff' : '#000'}}\"\r\n      >\r\n        首页\r\n      </button>\r\n    </view>\r\n    <view class=\"footer-item\">\r\n      <button\r\n        class=\"footer-btn\"\r\n        bindtap=\"onPageMsgTap\"\r\n        style=\"background: {{currentPage === 'msg' ? '#111' : 'rgba(0,0,0,0)'}}; color: {{currentPage === 'msg' ? '#fff' : '#000'}}\"\r\n      >\r\n        消息\r\n      </button>\r\n    </view>\r\n    <view class=\"footer-item\">\r\n      <button\r\n        class=\"footer-btn\"\r\n        bindtap=\"onPageMeTap\"\r\n        style=\"background: {{currentPage === 'me' ? '#111' : 'rgba(0,0,0,0)'}}; color: {{currentPage === 'me' ? '#fff' : '#000'}}\"\r\n      >\r\n        个人\r\n      </button>\r\n    </view>\r\n  </view>\r\n</view>\r\n复制代码很好理解，画面主要被分为上下两个部分：上面的部分是主要内容，下面的部分是三个 Tab 组成的 Footer。重点 WXSS 实现（完整的 WXSS 可以下载源码查看）：\r\n.footer {\r\n  box-shadow: 0 0 15rpx #ccc;\r\n  display: flex;\r\n  position: fixed;\r\n  height: 120rpx;\r\n  bottom: 0;\r\n  width: 100%;\r\n  flex-direction: row;\r\n  justify-content: center;\r\n  z-index: 100;\r\n  background: #fff;\r\n}\r\n\r\n.footer-item {\r\n  display: flex;\r\n  justify-content: center;\r\n  align-items: center;\r\n  height: 100%;\r\n  width: 33.33%;\r\n  color: #333;\r\n}\r\n\r\n.footer-item:nth-child(2) {\r\n  border-left: 3rpx solid #aaa;\r\n  border-right: 3rpx solid #aaa;\r\n  flex-grow: 1;\r\n}\r\n\r\n.footer-btn {\r\n  width: 100%;\r\n  height: 100%;\r\n  display: flex;\r\n  justify-content: center;\r\n  align-items: center;\r\n  border-radius: 0;\r\n  font-size: 30rpx;\r\n}\r\n复制代码核心逻辑是通过 position: fixed 来让 Footer 一直在下方。\r\n读者会发现有一个 currentPage 的 data ，这个 data 的作用其实很直观：通过判断它的值是 main/msg/me 中的哪一个来决定主要内容。同时，为了让首次使用的用户知道自己在哪个 Tab，Footer 中相应的 button 也会从白底黑字黑底白字，与另外两个 Tab 形成对比。\r\n现在我们来看看 main 部分的代码（在上面代码的基础上扩充）:\r\n...\r\n<view\r\n  class=\"main-header\"\r\n  style=\"display:{{currentPage === 'main' ? 'flex' : 'none'}};max-height:{{mainHeaderMaxHeight}}\"\r\n>\r\n  <view class=\"group-picker-wrapper\">\r\n    <picker\r\n      bindchange=\"bindGroupPickerChange\"\r\n      value=\"{{groupArrayIndex}}\"\r\n      range=\"{{groupArray}}\"\r\n      class=\"group-picker\"\r\n    >\r\n      <button class=\"group-picker-inner\">\r\n        {{groupArray[groupArrayIndex]}}\r\n      </button>\r\n    </picker>\r\n  </view>\r\n  <view class=\"search-btn-wrapper\">\r\n    <button class=\"search-btn\" bindtap=\"onSearchTap\">搜索用户</button>\r\n  </view>\r\n</view>\r\n<view\r\n  class=\"main-area\"\r\n  style=\"display:{{currentPage === 'main' ? 'block' : 'none'}};height: {{mainAreaHeight}};margin-top:{{mainAreaMarginTop}}\"\r\n>\r\n  <scroll-view scroll-y class=\"main-area-scroll\" bindscroll=\"onMainPageScroll\">\r\n    <block\r\n      wx:for=\"{{pageMainData}}\"\r\n      wx:for-index=\"idx\"\r\n      wx:for-item=\"itemName\"\r\n      wx:key=\"_id\"\r\n    >\r\n      <post-item is=\"post-item\" data=\"{{itemName}}\" class=\"post-item-wrapper\" />\r\n    </block>\r\n    <view wx:if=\"{{pageMainData.length === 0}}\" class=\"item-placeholder\"\r\n      >无数据</view\r\n    >\r\n  </scroll-view>\r\n  <button\r\n    class=\"add-poster-btn\"\r\n    bindtap=\"onAddPosterTap\"\r\n    hover-class=\"add-poster-btn-hover\"\r\n    style=\"bottom:{{addPosterBtnBottom}}\"\r\n  >\r\n    +\r\n  </button>\r\n</view>\r\n...\r\n复制代码这里用到了 列表渲染 和 条件渲染，还不清楚的可以点击进去学习一下。\r\n可以看到，相比之前的代码，我添加一个 header，同时 main-area 的内部也新增了一个 scroll-view（用于展示 Feed 流） 和一个 button（用于编辑新迷你微博）。header 的功能很简单：左侧区域是一个 picker，可以选择查看的动态类型（目前有 关注动态 和 所有动态 两种）；右侧区域是一个按钮，点击后可以跳转到搜索页面，这两个功能我们先放一下，先继续看 main-area 的新增内容。\r\nmain-area 里的 scroll-view 是一个可监听滚动事件的列表，其中监听事件的实现：\r\ndata: {\r\n  ...\r\n  addPosterBtnBottom: \"190rpx\",\r\n  mainHeaderMaxHeight: \"80rpx\",\r\n  mainAreaHeight: \"calc(100vh - 200rpx)\",\r\n  mainAreaMarginTop: \"80rpx\",\r\n},\r\nonMainPageScroll: function(e) {\r\n  if (e.detail.deltaY < 0) {\r\n    this.setData({\r\n      addPosterBtnBottom: \"-190rpx\",\r\n      mainHeaderMaxHeight: \"0\",\r\n      mainAreaHeight: \"calc(100vh - 120rpx)\",\r\n      mainAreaMarginTop: \"0rpx\"\r\n    })\r\n  } else {\r\n    this.setData({\r\n      addPosterBtnBottom: \"190rpx\",\r\n      mainHeaderMaxHeight: \"80rpx\",\r\n      mainAreaHeight: \"calc(100vh - 200rpx)\",\r\n      mainAreaMarginTop: \"80rpx\"\r\n    })\r\n  }\r\n},\r\n...\r\n复制代码结合 wxml 可以知道，当页面向下滑动 （deltaY < 0） 时，header 和 button 会 “突然消失”，反之它们则会 “突然出现”。为了视觉上有更好地过渡，我们可以在 WXSS 中使用 transition ：\r\n...\r\n.main-area {\r\n  position: relative;\r\n  flex-grow: 1;\r\n  overflow: auto;\r\n  z-index: 1;\r\n  transition: height 0.3s, margin-top 0.3s;\r\n}\r\n.main-header {\r\n  position: fixed;\r\n  width: 100%;\r\n  height: 80rpx;\r\n  background: #fff;\r\n  top: 0;\r\n  left: 0;\r\n  display: flex;\r\n  justify-content: space-around;\r\n  align-items: center;\r\n  z-index: 100;\r\n  border-bottom: 3rpx solid #aaa;\r\n  transition: max-height 0.3s;\r\n  overflow: hidden;\r\n}\r\n.add-poster-btn {\r\n  position: fixed;\r\n  right: 60rpx;\r\n  box-shadow: 5rpx 5rpx 10rpx #aaa;\r\n  display: flex;\r\n  justify-content: center;\r\n  align-items: center;\r\n  color: #333;\r\n  padding-bottom: 10rpx;\r\n  text-align: center;\r\n  border-radius: 50%;\r\n  font-size: 60rpx;\r\n  width: 100rpx;\r\n  height: 100rpx;\r\n  transition: bottom 0.3s;\r\n  background: #fff;\r\n  z-index: 1;\r\n}\r\n...\r\n复制代码3. Feed 流\r\n3.1 post-item\r\n前面提到，scroll-view 的内容是 Feed 流，那么首先就要想到使用 列表渲染。而且，为了方便在个人主页复用，列表渲染中的每一个 item 都要抽象出来。这时就要使用小程序中的 Custom-Component 功能了。\r\n新建一个名为 post-item 的 Component，其中 wxml 的实现（路径：pages/circle/component/post-item/post-item.js）：\r\n<view\r\n  class=\"post-item\"\r\n  hover-class=\"post-item-hover\"\r\n  bindlongpress=\"onItemLongTap\"\r\n  bindtap=\"onItemTap\"\r\n>\r\n  <view class=\"post-title\">\r\n    <view class=\"author\" hover-class=\"author-hover\" catchtap=\"onAuthorTap\"\r\n      >{{data.author}}</view\r\n    >\r\n    <view class=\"date\">{{data.formatDate}}</view>\r\n  </view>\r\n  <view class=\"msg-wrapper\">\r\n    <text class=\"msg\">{{data.msg}}</text>\r\n  </view>\r\n  <view class=\"image-outer\" wx:if=\"{{data.photoId !== ''}}\" catchtap=\"onImgTap\">\r\n    <image-wrapper is=\"image-wrapper\" src=\"{{data.photoId}}\" />\r\n  </view>\r\n</view>\r\n复制代码可见，一个 poster-item 最主要有以下信息：\r\n\r\n作者名\r\n发送时间\r\n文本内容\r\n图片内容\r\n\r\n其中，图片内容因为是可选的，所以使用了 条件渲染，这会在没有图片信息时不让图片显示区域占用屏幕空间。另外，图片内容主要是由 image-wrapper 组成，它也是一个 Custom-Component，主要功能是：\r\n\r\n强制长宽 1:1 裁剪显示图片\r\n点击查看大图\r\n未加载完成时显示 加载中\r\n\r\n具体代码这里就不展示了，比较简单，读者可以在 component/image-wrapper 里找到。\r\n回过头看 main-area 的其他新增部分，细心的读者会发现有这么一句：\r\n<view wx:if=\"{{pageMainData.length === 0}}\" class=\"item-placeholder\"\r\n  >无数据</view\r\n>\r\n复制代码这会在 Feed 流暂时没有获取到数据时给用户一个提示。\r\n3.2 collections: poster、poster_users\r\n展示 Feed 流的部分已经编写完毕，现在就差实际数据了。根据上一小节 poster-item 的主要信息，我们可以初步推断出一条迷你微博在 云数据库 的 collection poster 里是这样存储的：\r\n{\r\n  \"username\": \"Tester\",\r\n  \"date\": \"2019-07-22 12:00:00\",\r\n  \"text\": \"Ceshiwenben\",\r\n  \"photo\": \"xxx\"\r\n}\r\n复制代码先来看 username。由于社交平台一般不会限制用户的昵称，所以如果每条迷你微博都存储昵称，那将来每次用户修改一次昵称，就要遍历数据库把所有迷你微博项都改一遍，相当耗费时间，所以我们不如存储一个 userId，并另外把 id 和 昵称 的对应关系存在另一个叫 poster_users 的 collection 里。\r\n{\r\n  \"userId\": \"xxx\",\r\n  \"name\": \"Tester\",\r\n  ...（其他用户信息）\r\n}\r\n复制代码userId 从哪里拿呢？当然是通过之前已经授权的获取用户信息接口拿到了，详细操作之后会说到。\r\n接下来是 date，这里最好是服务器时间（因为客户端传过来的时间可能会有误差），而云开发文档里也有提供相应的接口：serverDate。这个数据可以直接被 new Date() 使用，可以理解为一个 UTC 时间。\r\ntext 即文本信息，直接存储即可。\r\nphoto 则表示附图数据，但是限于小程序 image 元素的实现，想要显示一张图片，要么提供该图片的 url，要么提供该图片在 云存储 的 id，所以这里最佳的实践是：先把图片上传到云存储里，然后把回调里的文件 id 作为数据存储。\r\n综上所述，最后 poster 每一项的数据结构如下：\r\n{\r\n  \"authorId\": \"xxx\",\r\n  \"date\": \"utc-format-date\",\r\n  \"text\": \"Ceshiwenben\",\r\n  \"photoId\": \"yyy\"\r\n}\r\n复制代码确定数据结构后，我们就可以开始往 collection 添加数据了。但是，在此之前，我们还缺少一个重要步骤。\r\n3.3 用户信息录入 与 云数据库\r\n没错，我们还没有在 poster_users 里添加一条新用户的信息。这个步骤一般在 pages/circle/circle 页面首次加载时判断即可：\r\ngetUserId: function(cb) {\r\n  let that = this\r\n  var value = this.data.userId || wx.getStorageSync(\"userId\")\r\n  if (value) {\r\n    if (cb) {\r\n      cb(value)\r\n    }\r\n    return value\r\n  }\r\n  wx.getSetting({\r\n    success(res) {\r\n      if (res.authSetting[\"scope.userInfo\"]) {\r\n        wx.getUserInfo({\r\n          withCredentials: true,\r\n          success: function(userData) {\r\n            wx.setStorageSync(\"userId\", userData.signature)\r\n            that.setData({\r\n              userId: userData.signature\r\n            })\r\n            db.collection(\"poster_users\")\r\n              .where({\r\n                userId: userData.signature\r\n              })\r\n              .get()\r\n              .then(searchResult => {\r\n                if (searchResult.data.length === 0) {\r\n                  wx.showToast({\r\n                    title: \"新用户录入中\"\r\n                  })\r\n                  db.collection(\"poster_users\")\r\n                    .add({\r\n                      data: {\r\n                        userId: userData.signature,\r\n                        date: db.serverDate(),\r\n                        name: userData.userInfo.nickName,\r\n                        gender: userData.userInfo.gender\r\n                      }\r\n                    })\r\n                    .then(res => {\r\n                      console.log(res)\r\n                      if (res.errMsg === \"collection.add:ok\") {\r\n                        wx.showToast({\r\n                          title: \"录入完成\"\r\n                        })\r\n                        if (cb) cb()\r\n                      }\r\n                    })\r\n                    .catch(err => {\r\n                      wx.showToast({\r\n                        title: \"录入失败，请稍后重试\",\r\n                        image: \"/images/error.png\"\r\n                      })\r\n                      wx.navigateTo({\r\n                        url: \"/pages/index/index\"\r\n                      })\r\n                    })\r\n                } else {\r\n                  if (cb) cb()\r\n                }\r\n              })\r\n          }\r\n        })\r\n      } else {\r\n        wx.showToast({\r\n          title: \"登陆失效，请重新授权登陆\",\r\n          image: \"/images/error.png\"\r\n        })\r\n        wx.navigateTo({\r\n          url: \"/pages/index/index\"\r\n        })\r\n      }\r\n    }\r\n  })\r\n}\r\n复制代码代码实现比较复杂，整体思路是这样的：\r\n\r\n判断是否已存储了 userId，如果有直接返回并调用回调函数，如果没有继续 2\r\n通过 wx.getSetting 获取当前设置信息\r\n如果返回里有 res.authSetting[\"scope.userInfo\"] 说明已经授权读取用户信息，继续 3，没有授权的话就跳转回首页重新授权\r\n调用 wx.getUserInfo 获取用户信息，成功后提取出 signature（这是每个微信用户的唯一签名），并调用 wx.setStorageSync 将其缓存\r\n调用 db.collection().where().get() ，判断返回的数据是否是空数组，如果不是说明该用户已经录入（注意 where() 中的筛选条件），如果是说明该用户是新用户，继续 5\r\n提示新用户录入中，同时调用 db.collection().add() 来添加用户信息，最后通过回调判断是否录入成功，并提示用户\r\n\r\n不知不觉我们就使用了云开发中的 云数据库 功能，紧接着我们就要开始使用 云存储 和 云函数了！\r\n3.4 addPoster 与 云存储\r\n发送新的迷你微博，需要一个编辑新迷你微博的界面，路径我定为 pages/circle/add-poster/add-poster：\r\n<view class=\"app-poster-container\">\r\n  <view class=\"body\">\r\n    <view class=\"text-area-wrapper\">\r\n      <textarea bindinput=\"bindTextInput\" placeholder=\"在此填写\" value=\"{{text}}\" auto-focus=\"true\" />\r\n      <view class=\"text-area-footer\">\r\n        <text>{{remainLen}}/140</text>\r\n      </view>\r\n    </view>\r\n    <view bindtap=\"onImageTap\" class=\"image-area\">\r\n      <view class=\"image-outer\">\r\n        <image-wrapper is=\"image-wrapper\" src=\"{{imageSrc}}\" placeholder=\"选择图片上传\" />\r\n      </view>\r\n    </view>\r\n  </view>\r\n  <view class=\"footer\">\r\n    <button class=\"footer-btn\" bindtap=\"onSendTap\">发送</button>\r\n  </view>\r\n</view>\r\n复制代码wxml 的代码很好理解：textarea 显示编辑文本，image-wrapper 显示需要上传的图片，最下面是一个发送的 button。其中，图片编辑区域的 bindtap 事件实现：\r\nonImageTap: function() {\r\n  let that = this\r\n  wx.chooseImage({\r\n    count: 1,\r\n    success: function(res) {\r\n      const tempFilePaths = res.tempFilePaths\r\n      that.setData({\r\n        imageSrc: tempFilePaths[0]\r\n      })\r\n    }\r\n  })\r\n}\r\n复制代码直接通过 wx.chooseImage 官方 API 获取本地图片的临时路径即可。而当发送按钮点击后，会有如下代码被执行：\r\nonSendTap: function() {\r\n  if (this.data.text === \"\" && this.data.imageSrc === \"\") {\r\n    wx.showModal({\r\n      title: \"错误\",\r\n      content: \"不能发送空内容\",\r\n      showCancel: false,\r\n      confirmText: \"好的\"\r\n    })\r\n    return\r\n  }\r\n  const that = this\r\n  wx.showLoading({\r\n    title: \"发送中\",\r\n    mask: true\r\n  })\r\n  const imageSrc = this.data.imageSrc\r\n  if (imageSrc !== \"\") {\r\n    const finalPath = imageSrc.replace(\"//\", \"/\").replace(\":\", \"\")\r\n    wx.cloud\r\n      .uploadFile({\r\n        cloudPath: finalPath,\r\n        filePath: imageSrc // 文件路径\r\n      })\r\n      .then(res => {\r\n        that.sendToDb(res.fileID)\r\n      })\r\n      .catch(error => {\r\n        that.onSendFail()\r\n      })\r\n  } else {\r\n    that.sendToDb()\r\n  }\r\n},\r\nsendToDb: function(fileId = \"\") {\r\n  const that = this\r\n  const posterData = {\r\n    authorId: that.data.userId,\r\n    msg: that.data.text,\r\n    photoId: fileId,\r\n    date: db.serverDate()\r\n  }\r\n  db.collection(\"poster\")\r\n    .add({\r\n      data: {\r\n        ...posterData\r\n      }\r\n    })\r\n    .then(res => {\r\n      wx.showToast({\r\n        title: \"发送成功\"\r\n      })\r\n      wx.navigateBack({\r\n        delta: 1\r\n      })\r\n    })\r\n    .catch(error => {\r\n      that.onSendFail()\r\n    })\r\n    .finally(wx.hideLoading())\r\n}\r\n复制代码\r\n首先判断文本和图片内容是否都为空，如果是则不执行发送，如果不是继续 2\r\n提示发送中，上传图片到云存储，注意需要将图片中的临时 url 的一些特殊字符组合替换一下，原因见 文件名命名限制\r\n上传成功后，调用 db.collection().add()，发送成功后退回上一页（即首页），如果失败则执行 onSendFail 函数，后者见源码，逻辑较简单这里不赘述\r\n\r\n于是，我们就这样创建了第一条迷你微博。接下来就让它在 Feed 流中显示吧！\r\n3.5 云函数 getMainPageData\r\n这个函数的主要作用如前所述，就是通过处理云数据库中的数据，将最终数据返回给客户端，后者将数据可视化给用户。我们先做一个初步版本，因为现在 poster_users 中只有一条数据，所以仅先展示自己的迷你微博。getMainPageData 云函数代码如下：\r\n// 云函数入口文件\r\nconst cloud = require(\"wx-server-sdk\")\r\ncloud.init()\r\nconst db = cloud.database()\r\n\r\n// 云函数入口函数\r\nexports.main = async (event, context, cb) => {\r\n  // 通过 event 获取入参\r\n  const userId = event.userId\r\n  let followingResult\r\n  let users\r\n  // idNameMap 负责存储 userId 和 name 的映射关系\r\n  let idNameMap = {}\r\n  let followingIds = []\r\n  // 获取用户信息\r\n  followingResult = await db\r\n      .collection(\"poster_users\")\r\n      .where({\r\n        userId: userId\r\n      })\r\n      .get()\r\n    users = followingResult.data\r\n    followingIds = users.map(u => {\r\n      return u.userId\r\n    })\r\n  users.map(u => {\r\n    idNameMap[u.userId] = u.name\r\n  })\r\n  // 获取动态\r\n  const postResult = await db\r\n    .collection(\"poster\")\r\n    .orderBy(\"date\", \"desc\")\r\n    .where({\r\n      // 通过高级筛选功能筛选出符合条件的 userId\r\n      authorId: db.command.in(followingIds)\r\n    })\r\n    .get()\r\n  const postData = postResult.data\r\n  // 向返回的数据添加 存储用户昵称的 author 属性、存储格式化后的时间的 formatDate 属性\r\n  postData.map(p => {\r\n    p.author = idNameMap[p.authorId]\r\n    p.formatDate = new Date(p.date).toLocaleDateString(\"zh-Hans\", options)\r\n  })\r\n  return postData\r\n}\r\n复制代码最后在 pages/circle/circle.js 里补充云调用：\r\ngetMainPageData: function(userId) {\r\n  const that = this\r\n  wx.cloud\r\n    .callFunction({\r\n      name: \"getMainPageData\",\r\n      data: {\r\n        userId: userId,\r\n        isEveryOne: that.data.groupArrayIndex === 0 ? false : true\r\n      }\r\n    })\r\n    .then(res => {\r\n      that.setData({\r\n        pageMainData: res.result,\r\n        pageMainLoaded: true\r\n      })\r\n    })\r\n    .catch(err => {\r\n      wx.showToast({\r\n        title: \"获取动态失败\",\r\n        image: \"/images/error.png\"\r\n      })\r\n      wx.hideLoading()\r\n    })\r\n}\r\n复制代码即可展示 Feed 流数据给用户。\r\n之后，getMainPageData 还会根据使用场景的不同，新增了查询所有用户动态、查询关注用户动态的功能，但是原理是一样的，看源码可以轻易理解，后续就不再说明。\r\n4. 关注系统\r\n上一节中我们一口气把云开发中的大部分主要功能：云数据库、云存储、云函数、云调用都用了一遍，接下来其他功能的实现也基本都依赖它们。\r\n4.1 poster_user_follows\r\n首先我们需要建一个新的 collection poster_user_follows，其中的每一项数据的数据结构如下：\r\n{\r\n  \"followerId\": \"xxx\",\r\n  \"followingId\": \"xxx\"\r\n}\r\n复制代码很简单，followerId 表示关注人，followingId 表示被关注人。\r\n4.2 user-data 页面\r\n关注或者取消关注需要进入他人的个人主页操作，我们在 pages/circle/user-data/user-data.wxml 中放一个 user-info 的自定义组件，然后新建该组件编辑：\r\n<view class=\"user-info\">\r\n  <view class=\"info-item\" hover-class=\"info-item-hover\">用户名: {{userName}}</view>\r\n  <view class=\"info-item\" hover-class=\"info-item-hover\" bindtap=\"onPosterCountTap\">动态数: {{posterCount}}</view>\r\n  <view class=\"info-item\" hover-class=\"info-item-hover\" bindtap=\"onFollowingCountTap\">关注数: {{followingCount}}</view>\r\n  <view class=\"info-item\" hover-class=\"info-item-hover\" bindtap=\"onFollowerCountTap\">粉丝数: {{followerCount}}</view>\r\n  <view class=\"info-item\" hover-class=\"info-item-hover\" wx:if=\"{{originId && originId !== '' && originId !== userId}}\"><button bindtap=\"onFollowTap\">{{followText}}</button></view>\r\n</view>\r\n复制代码这里注意条件渲染的 button：如果当前访问个人主页的用户 id （originId） 和 被访问的用户 id （userId）的值是相等的话，这个按钮就不会被渲染（自己不能关注/取消关注自己）。\r\n我们重点看下 onFollowTap 的实现：\r\nonFollowTap: function() {\r\n  const that = this\r\n  // 判断当前关注状态\r\n  if (this.data.isFollow) {\r\n    wx.showLoading({\r\n      title: \"操作中\",\r\n      mask: true\r\n    })\r\n    wx.cloud\r\n      .callFunction({\r\n        name: \"cancelFollowing\",\r\n        data: {\r\n          followerId: this.properties.originId,\r\n          followingId: this.properties.userId\r\n        }\r\n      })\r\n      .then(res => {\r\n        wx.showToast({\r\n          title: \"取消关注成功\"\r\n        })\r\n        that.setData({\r\n          isFollow: false,\r\n          followText: \"关注\"\r\n        })\r\n      })\r\n      .catch(error => {\r\n        wx.showToast({\r\n          title: \"取消关注失败\",\r\n          image: \"/images/error.png\"\r\n        })\r\n      })\r\n      .finally(wx.hideLoading())\r\n  } else if (this.data.isFollow !== undefined) {\r\n    wx.showLoading({\r\n      title: \"操作中\",\r\n      mask: true\r\n    })\r\n    const data = {\r\n      followerId: this.properties.originId,\r\n      followingId: this.properties.userId\r\n    }\r\n    db.collection(\"poster_user_follows\")\r\n      .add({\r\n        data: {\r\n          ...data\r\n        }\r\n      })\r\n      .then(res => {\r\n        wx.showToast({\r\n          title: \"关注成功\"\r\n        })\r\n        that.setData({\r\n          isFollow: true,\r\n          followText: \"取消关注\"\r\n        })\r\n      })\r\n      .catch(error => {\r\n        wx.showToast({\r\n          title: \"关注失败\",\r\n          image: \"/images/error.png\"\r\n        })\r\n      })\r\n      .finally(wx.hideLoading())\r\n    }\r\n  }\r\n}\r\n复制代码这里读者可能会有疑问：为什么关注的时候直接调用 db.collection().add() 即可，而取消关注却要调用云函数呢？这里涉及到云数据库的设计问题：删除多个数据的操作，或者说删除使用 where 筛选的数据，只能在服务端执行。如果确实想在客户端删除，则在查询用户关系时，将唯一标识数据的 _id 用 setData 存下来，之后再使用 db.collection().doc(_id).delete() 删除即可。这两种实现方式读者可自行选择。当然，还有一种实现是不实际删除数据，只是加个 isDelete 字段标记一下。\r\n查询用户关系的实现很简单，云函数的实现方式如下：\r\n// 云函数入口文件\r\nconst cloud = require('wx-server-sdk')\r\ncloud.init()\r\nconst db = cloud.database()\r\n\r\n// 云函数入口函数\r\nexports.main = async(event, context) => {\r\n  const followingResult = await db.collection(\"poster_user_follows\")\r\n    .where({\r\n      followingId: event.followingId,\r\n      followerId: event.followerId\r\n    }).get()\r\n  return followingResult\r\n}\r\n复制代码客户端只要检查返回的数据长度是否大于 0 即可。\r\n另外附上 user-data 页面其他数据的获取云函数实现：\r\n// 云函数入口文件\r\nconst cloud = require(\"wx-server-sdk\")\r\ncloud.init()\r\nconst db = cloud.database()\r\n\r\nasync function getPosterCount(userId) {\r\n  return {\r\n    value: (await db.collection(\"poster\").where({\r\n      authorId: userId\r\n    }).count()).total,\r\n    key: \"posterCount\"\r\n  }\r\n}\r\n\r\nasync function getFollowingCount(userId) {\r\n  return {\r\n    value: (await db.collection(\"poster_user_follows\").where({\r\n      followerId: userId\r\n    }).count()).total,\r\n    key: \"followingCount\"\r\n  }\r\n}\r\n\r\nasync function getFollowerCount(userId) {\r\n  return {\r\n    value: (await db.collection(\"poster_user_follows\").where({\r\n      followingId: userId\r\n    }).count()).total,\r\n    key: \"followerCount\"\r\n  }\r\n}\r\n\r\n\r\nasync function getUserName(userId) {\r\n  return {\r\n    value: (await db.collection(\"poster_users\").where({\r\n      userId: userId\r\n    }).get()).data[0].name,\r\n    key: \"userName\"\r\n  }\r\n}\r\n\r\n// 云函数入口函数\r\nexports.main = async (event, context) => {\r\n  const userId = event.userId\r\n  const tasks = []\r\n  tasks.push(getPosterCount(userId))\r\n  tasks.push(getFollowerCount(userId))\r\n  tasks.push(getFollowingCount(userId))\r\n  tasks.push(getUserName(userId))\r\n  const allData = await Promise.all(tasks)\r\n  const finalData = {}\r\n  allData.map(d => {\r\n    finalData[d.key] = d.value\r\n  })\r\n  return finalData\r\n}\r\n复制代码很好理解，客户端获取返回后直接使用即可。\r\n5. 搜索页面\r\n这部分其实很好实现。关键的搜索函数实现如下：\r\n// 云函数入口文件\r\nconst cloud = require('wx-server-sdk')\r\ncloud.init()\r\nconst db = cloud.database()\r\n\r\nconst MAX_LIMIT = 100\r\nasync function getDbData(dbName, whereObj) {\r\n  const totalCountsData = await db.collection(dbName).where(whereObj).count()\r\n  const total = totalCountsData.total\r\n  const batch = Math.ceil(total / 100)\r\n  const tasks = []\r\n  for (let i = 0; i < batch; i++) {\r\n    const promise = db\r\n      .collection(dbName)\r\n      .where(whereObj)\r\n      .skip(i * MAX_LIMIT)\r\n      .limit(MAX_LIMIT)\r\n      .get()\r\n    tasks.push(promise)\r\n  }\r\n  const rrr = await Promise.all(tasks)\r\n  if (rrr.length !== 0) {\r\n    return rrr.reduce((acc, cur) => {\r\n      return {\r\n        data: acc.data.concat(cur.data),\r\n        errMsg: acc.errMsg\r\n      }\r\n    })\r\n  } else {\r\n    return {\r\n      data: [],\r\n      errMsg: \"empty\"\r\n    }\r\n  }\r\n}\r\n\r\n// 云函数入口函数\r\nexports.main = async (event, context) => {\r\n  const text = event.text\r\n  const data = await getDbData(\"poster_users\", {\r\n    name: {\r\n      $regex: text\r\n    }\r\n  })\r\n  return data\r\n}\r\n复制代码这里参考了官网所推荐的分页检索数据库数据的实现（因为搜索结果可能有很多），筛选条件则是正则模糊匹配关键字。\r\n搜索页面的源码路径是 pages/circle/search-user/search-user，实现了点击搜索结果项跳转到对应项的用户的 user-data 页面，建议直接阅读源码理解。\r\n6. 其他扩展\r\n6.1 poster_likes 与 点赞\r\n由于转发、评论、点赞的原理基本相同，所以这里只介绍点赞功能如何编写，另外两个功能读者可以自行实现。\r\n毫无疑问我们需要新建一个 collection poster_likes，其中每一项的数据结构如下：\r\n{\r\n  \"posterId\": \"xxx\",\r\n  \"likeId\": \"xxx\"\r\n}\r\n复制代码这里的 posterId 就是 poster collection 里每条记录的 _id 值，likeId 就是 poster_users 里的 userId 了。\r\n然后我们扩展一下 poster-item 的实现：\r\n<view class=\"post-item\" hover-class=\"post-item-hover\" bindlongpress=\"onItemLongTap\" bindtap=\"onItemTap\">\r\n  ...\r\n  <view class=\"interact-area\">\r\n    <view class=\"interact-item\">\r\n      <button class=\"interact-btn\" catchtap=\"onLikeTap\" style=\"color:{{liked ? '#55aaff' : '#000'}}\">赞 {{likeCount}}</button>\r\n    </view>\r\n  </view>\r\n</view>\r\n复制代码即，新增一个 interact-area，其中 onLikeTap 实现如下：\r\nonLikeTap: function() {\r\n  if (!this.properties.originId) return\r\n  const that = this\r\n  if (this.data.liked) {\r\n    wx.showLoading({\r\n      title: \"操作中\",\r\n      mask: true\r\n    })\r\n    wx.cloud\r\n      .callFunction({\r\n        name: \"cancelLiked\",\r\n        data: {\r\n          posterId: this.properties.data._id,\r\n          likeId: this.properties.originId\r\n        }\r\n      })\r\n      .then(res => {\r\n        wx.showToast({\r\n          title: \"取消成功\"\r\n        })\r\n        that.refreshLike()\r\n        that.triggerEvent('likeEvent');\r\n      })\r\n      .catch(error => {\r\n        wx.showToast({\r\n          title: \"取消失败\",\r\n          image: \"/images/error.png\"\r\n        })\r\n      })\r\n      .finally(wx.hideLoading())\r\n  } else {\r\n    wx.showLoading({\r\n      title: \"操作中\",\r\n      mask: true\r\n    })\r\n    db.collection(\"poster_likes\").add({\r\n        data: {\r\n          posterId: this.properties.data._id,\r\n          likeId: this.properties.originId\r\n        }\r\n      }).then(res => {\r\n        wx.showToast({\r\n          title: \"已赞\"\r\n        })\r\n        that.refreshLike()\r\n        that.triggerEvent('likeEvent');\r\n      })\r\n      .catch(error => {\r\n        wx.showToast({\r\n          title: \"赞失败\",\r\n          image: \"/images/error.png\"\r\n        })\r\n      })\r\n      .finally(wx.hideLoading())\r\n  }\r\n\r\n}\r\n复制代码细心的读者会发现这和关注功能原理几乎是一样的。\r\n6.2 数据刷新\r\n我们可以使用很多方式让主页面刷新数据：\r\nonShow: function() {\r\n  wx.showLoading({\r\n    title: \"加载中\",\r\n    mask: true\r\n  })\r\n  const that = this\r\n  function cb(userId) {\r\n    that.refreshMainPageData(userId)\r\n    that.refreshMePageData(userId)\r\n  }\r\n  this.getUserId(cb)\r\n}\r\n复制代码第一种是利用 onShow 方法：它会在页面每次从后台转到前台展示时调用，这个时候我们就能刷新页面数据（包括 Feed 流和个人信息）。但是这个时候用户信息可能会丢失，所以我们需要在 getUserId 里判断，并将刷新数据的函数们整合起来，作为回调函数。\r\n第二种是让用户手动刷新：\r\nonPageMainTap: function() {\r\n  if (this.data.currentPage === \"main\") {\r\n    this.refreshMainPageData()\r\n  }\r\n  this.setData({\r\n    currentPage: \"main\"\r\n  })\r\n}\r\n复制代码如图所示，当目前页面是 Feed 流时，如果再次点击 首页 Tab，就会强制刷新数据。\r\n第三种是关联数据变更触发刷新，比如动态类型选择、删除了一条动态以后触发数据的刷新。这种可以直接看源码学习。\r\n6.3 首次加载等待\r\n当用户第一次进入主页面时，我们如果想在 Feed 流和个人信息都加载好了再允许用户操作，应该如何实现？\r\n如果是类似 Vue 或者 React 的框架，我们很容易就能想到属性监控，如 watch、useEffect 等等，但是小程序目前 Page 并没有提供属性监控功能，怎么办？\r\n除了自己实现，还有一个方法就是利用 Component 的 observers，它和上面提到的属性监控功能差不多。虽然官网文档对其说明比较少，但摸索了一番还是能用来监控的。\r\n首先我们来新建一个 Component 叫 abstract-load，具体实现如下：\r\n// pages/circle/component/abstract-load.js\r\nComponent({\r\n  properties: {\r\n    pageMainLoaded: {\r\n      type: Boolean,\r\n      value: false\r\n    },\r\n    pageMeLoaded: {\r\n      type: Boolean,\r\n      value: false\r\n    }\r\n  },\r\n  observers: {\r\n    \"pageMainLoaded, pageMeLoaded\": function (pageMainLoaded, pageMeLoaded) {\r\n      if (pageMainLoaded && pageMeLoaded) {\r\n        this.triggerEvent(\"allLoadEvent\")\r\n      }\r\n    }\r\n  }\r\n})\r\n复制代码然后在 pages/circle/circle.wxml 中添加一行：\r\n<abstract-load is=\"abstract-load\" pageMainLoaded=\"{{pageMainLoaded}}\" pageMeLoaded=\"{{pageMeLoaded}}\" bind:allLoadEvent=\"onAllLoad\" />\r\n复制代码最后实现 onAllLoad 函数即可。\r\n另外，像这种没有实际展示数据的 Component，建议在项目中都用 abstract 开头来命名。\r\n6.4 scroll-view 在 iOS 的 bug\r\n如果读者使用 iOS 系统调试这个小程序，可能会发现 Feed 流比较短的时候，滚动 scroll-view header 和 button 会有鬼畜的上下抖动现象，这是因为 iOS 自己实现的 WebView 对于滚动视图有回弹的效果，而该效果也会触发滚动事件。\r\n对于这个 bug，官方人员也表示暂时无法修复，只能先忍一忍了。\r\n6.5 关于消息 Tab\r\n读者可能会疑惑我为什么没有讲解消息 Tab 以及消息提醒的实现。首先是因为源码没有这个实现，其次是我觉得目前云开发所提供的能力实现主动提醒比较麻烦（除了轮询想不到其他办法）。\r\n希望未来云开发可以提供 数据库长连接监控 的功能，这样通过订阅者模式可以很轻松地获取到数据更新的状态，主动提醒也就更容易实现了。到那时我可能会再更新相关源码。\r\n6.6 关于云函数耗时\r\n读者可能会发现我有一个叫 benchmark 的云函数，这个函数只是做了个查询数据库的操作，目的在于计算查询耗时。\r\n诡异的是，我前天在调试的时候，发现查询一次需要1秒钟，而写这篇文章时却不到100ms。建议在一些需要多次操作数据库的函数配置里，把超时时间设置长一点吧。目前云函数的性能不太稳定。\r\n7. 结语\r\n那么关于迷你版微博开发实战介绍就到此为止了，更多资料可以直接下载源码查看哦。\r\n源码链接\r\ngithub.com/TencentClou…"}
{"title": "微信小程序 禁止弹框底部内容滑动 ", "author": "Rolan", "put_time": "2019-7-29 00:11", "content": "我们需要解决的问题：当弹框显示的时候，弹框下面的内容不能滚动小程序的弹框特别多,像下面这样，弹框的底部是一个可以下拉的页面，但是当弹框出现的时候，需要禁止底部的滚动，那么怎么做呢？直接给出答案吧：给 view 加上 catchtouchmove='true' 就可以.比如下面这种：<view catchtouchmove='true' ></view>至于加到哪个view上边，自然是最外边包含整个屏幕的view了。如果你实在不知道哪一个，你试一下也成。网友们的方法网友们有人使用的方式是给 catchtouchmove 绑定一个空方法。这也是一个解决方法。<view catchtouchmove='prevent' ></view>\r\n\r\nprevent(){\r\n    return ;\r\n}友情提醒：关于不能滚动的这个效果需要在真机上面查看，在编辑器上面看不到效果。至此，完成。"}
{"title": "微信小程序通过云函数进行微信支付 ", "author": "Rolan", "put_time": "2019-7-29 00:12", "content": "微信小程序微信支付官方流程图链接我简化的流程：本地发起下单请求调用云函数并传送数据云函数处理数据并返回5个参数本地接受5个参数，发起支付请求交易结束主要代码：//第一步，本地发起下单请求并传送数据。这一步，在你的wxml中的某个元素\r\n//中绑定事件<button bindtap='pay'></button>。通过这个pay函数，\r\n//触发云函数并传递一些数据\r\npay: function(){\r\n\t//需要上传给云函数的数据\r\n\tlet uploadData = {\r\n\t\t//此次需要支付的金额，单位是分。例如¥1.80=180\r\n\t\t\"total_fee\": \"180\",\r\n\t\t//用户端的ip地址\r\n\t\t\"spbill_create_ip\": \"123.123.123.123\"\r\n\t}\r\n\t//调用云函数\r\n\twx.cloud.callFunction({\r\n\t\t//云函数的名字，这里我定义为payment\r\n\t\tname: \"payment\",\r\n\t\t//需要上传的数据\r\n\t\tdata: uploadData\r\n\t}).then(res => {\r\n\t\t//这个res就是云函数返回的5个参数\r\n\t\t//通过wx.requestPayment发起支付\r\n\t\twx.requestPayment({\r\n\t\t\ttimeStamp: res.result.data.timeStamp,\r\n\t\t\tnonceStr: res.result.data.nonceStr,\r\n\t\t\tpackage: res.result.data.package,\r\n\t\t\tsignType: res.result.data.signType,\r\n\t\t\tpaySign: res.result.data.paySign,\r\n\t\t\tsuccess: res => {\r\n\t\t\t\t//支付成功\r\n\t\t\t},\r\n\t\t\tfail: err => {\r\n\t\t\t\t//支付失败\r\n\t\t\t}\r\n\t})\r\n}\r\n\r\n\r\n复制代码以上就是本地端的全部代码，接下来我们只需要搞定云函数的代码就完成全部的工作了。云函数的内容是：调用小程序登陆API -> Openid生成商户订单调用统一下单API -> prepay_id将组合数据再次签名,返回5个参数我创建的云函数命名为payment，此时云函数结构应该为payment\r\n|__index.js\r\n|__package.json\r\n复制代码##每一步的详细做法1. 调用小程序登陆API -> Openid这一步目的是获取用户的Openid在云函数的index.js中加上以下代码//获取云实例\r\nconst cloud = require('wx-server-sdk')\r\n//云初始化\r\ncloud.init()\r\n//获取微信调用上下文信息，其中包括Openid，Appid等\r\nconst wxContext = cloud.getWXContext()\r\n//获取用户openid\r\nconst openid = wxContext.OPENID\r\n复制代码到这里我们已经达成我们第一步的目的了。2. 生成商户订单微信支付开发文档-统一下单这一步的目的是为了 生成调用支付统一下单API的订单 。根据官方文档，我们需要以下数据：appid（小程序ID）openid（用户OPENID）mch_id（商户号）nonce_str（随机字符串）body（商品描述）out_trade_no（商户订单号）total_fee（标价金额）spbill_create_ip（终端IP）notify_url（通知地址）trade_type（交易类型）key（密钥）sign（签名）我们一个一个解决。1. appid小程序管理员进入公众平台、使用小程序帐户登录后，点击左侧菜单中的「设置」，在「开发设置」一项，就可以查询到小程序的AppID。示例值 wxd678efh567hg6787在云函数的index.js中加上以下代码：const appid='wxwxd678efh567hg6787'\r\n复制代码2. openid第一步已经获得。示例值 oUpF8uMuAJO_M2pxb1Q9zNjWeS6o3. mch_id登陆微信支付商户平台pay.weixin.qq.com,点击上方「账户中心」，在「个人信息」中的「登陆账号」就是mch_id。示例值 1230000109在云函数的index.js中加上以下代码：const mch_id='1230000109'\r\n复制代码4. nonce_str任意生成的随机数，不超过32位。你可以自己写个函数。示例值 5K8264ILTKCH16CQ2502SI8ZNMTM67VS我在云函数中创建了一个新的JS文件(random.js)来保存这个函数，此时云函数的结构如下payment\r\n|__index.js\r\n|__package.json\r\n|__random.js\r\n复制代码其中random.js的内容为:function random(){\r\n  var result = ''\r\n  const wordList = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l',\r\n  'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '1', '2',\r\n  '3', '4', '5', '6', '7', '8', '9', '0']\r\n  for(let i=0;i<31;i++){\r\n    result += wordList[Math.round(Math.random()*36)]\r\n  }\r\n  return result\r\n}\r\n\r\nmodule.exports = random()\r\n\r\n复制代码然后在云函数index.js中加上以下代码:const random = require(\"random.js\")\r\n复制代码5. body格式为：商家名称-销售商品类目示例值 腾讯-游戏在云函数index.js中加上以下代码:const body = \"腾讯-游戏\"\r\n复制代码6. out_trade_no商户系统内部订单号，要求32个字符内，只能是数字、大小写字母_-|*且 在同一个商户号下唯一 。由自己定义，推荐用当下时间+商品编号组成。示例值 20150806125346在云函数index.js中的exports.main函数中加上以下代码://这里我只使用了当下时间。只要这个数字不是重复的就可以。\r\nconst out_trade_no = Date.parse(new Date()).toString()\r\n复制代码7. total_fee订单总金额，单位为分。比如当前需支付¥6.80，则total_fee为680。示例值 88这里需要用到我们上传过来的值，先不管8. spbill_create_ip支持IPV4和IPV6两种格式的IP地址。调用微信支付API的机器IP。示例值 123.12.12.123这里需要用到我们上传过来的值，先不管9. notify_url异步接收微信支付结果通知的回调地址，通知url必须为外网可访问的url，不能携带参数。在这里可以填上你自己服务器的url。示例值 http://www.weixin.qq.com/wxpay/pay.php在云函数index.js中加上以下代码://随便填写个服务器就行，我在使用中没有遇到什么问题\r\nconst notify_url = 'http://www.weixin.qq.com/wxpay/pay.php'\r\n复制代码10. trade_type小程序的trade_type为JSAPI。示例值 JSAPI在云函数index.js中加上以下代码:const trade_type = 'JSAPI'\r\n复制代码11. keykey为商户平台设置的密钥key，是由你自己设置的。key设置路径：微信商户平台(pay.weixin.qq.com)-->账户设置-->API安全-->密钥设置。示例值 1a79a4d60de6718e8e5b326e338ae533在云函数index.js中加上以下代码:const key = '1a79a4d60de6718e8e5b326e338ae533'\r\n复制代码12. sign将以上除key外所有信息按照参数名ASCII码从大到小拼接成字符串，用&分割，将key放在最后。字符串示例值:appid=wxd678efh567hg6787&body=微信-游戏&mch_\r\nid=1230000109&nonce_str=5K8264ILTKCH16CQ2502SI8ZNMTM6\r\n7VS&notify_url=http://www.weixin.qq.com/wxpay/pay.php&\r\nopenid=oUpF8uMuAJO_M2pxb1Q9zNjWeS6o&out_trade_no=2015080\r\n6125346&spbill_create_ip=123.12.12.123&total_fee=88&trad\r\ne_type=JSAPI&key=1a79a4d60de6718e8e5b326e338ae533\r\n复制代码此字符串的MD5码的大写就是sign。因为上面的total_fee与spbill_create_ip我们还没处理，所以这个数据放到下面再处理。MD5码示例值 C380BEC2BFD727A4B6845133519F3AD6到此为止你的云函数结构应该为:payment\r\n|__index.js\r\n|__package.json\r\n|__random.js\r\n复制代码其中index.js的内容应该为://云函数入口文件\r\nconst cloud = require('wx-server-sdk')\r\ncloud.init()\r\nconst openid = cloud.getWXContext().OPENID\r\nconst appid = 'wxwxd678efh567hg6787'\r\nconst mch_id = '1230000109'\r\nconst random = require('random.js')\r\nconst body = \"腾讯-游戏\"\r\nconst notify_url = 'http://www.weixin.qq.com/wxpay/pay.php'\r\nconst trade_type = 'JSAPI'\r\nconst key = '1a79a4d60de6718e8e5b326e338ae533'\r\n\r\n//云函数入口函数\r\nexports.main = async (event, content) => {\r\n\tconst out_trade_no = Date.parse(new Date()).toString()\r\n}\r\n复制代码接下来我们处理上面没有处理的total_fee与spbill_create_ip，以及sign。 其中total_fee和spbill_create_ip是由客户端上传的，这两个数据就在云函数入口函数的参数event中，所以我们在云函数入口函数里面加上以下代码const total_fee = event.total_fee\r\nconst spbill_create_ip = event.spbill_create_ip\r\n复制代码最后，我们需要处理sign，按照12.sign提到的规则，在云函数入口函数里面加上以下代码let stringA = `appid=${appid}&body=${body}&\r\nmch_id=${mch_id}&nonce_str=${random}&\r\nnotify_url=${notify_url}&openid=${openid}&\r\nout_trade_no=${out_trade_no}&\r\nspbill_create_ip=${spbill_create_ip}&\r\ntotal_fee=${total_fee}™_type=${trade_type}&\r\nkey=1a79a4d60de6718e8e5b326e338ae533`\r\n复制代码我们现在需要将这个字符串进行MD5码加密，所以需要安装一个npm包来完成这个任务。右键点击云函数pyament，选择「在终端打开」，输入下面的命令：npm install --save crypto\r\n复制代码完成后在云函数入口文件处加上以下代码const crypto = require(\"crypto\")\r\n复制代码这样我们就成功地将crypto这个加密工具包引入我们的云函数里了。然后我们需要在云函数入口函数里使用它对刚刚的stringA进行MD5加密。所以我们在 let stringA = ... 这行代码下面添加以下代码var sign = crypto.createHash('md5').update(stringA).digest('hex').toUpperCase()\r\n复制代码以上除key的11个信息就是我们调用统一下单API所需要的全部数据了我们现在需要将这些数据转成xml格式,例如：<xml>\r\n<appid>wxd930ea5d5a258f4f</appid>\r\n<mch_id>10000100</mch_id>\r\n<device_info>1000</device_info>\r\n<body>test</body>\r\n<nonce_str>ibuaiVcKdpRxkhJA</nonce_str>\r\n<sign>9A0A8659F005D6984697E2CA0A9CF3B7</sign>\r\n...\r\n</xml>\r\n复制代码在云函数中新建一个requestData.js，写下如下函数，用来完成将数据转成xml的任务function requestData(\r\n  appid,\r\n  mch_id,\r\n  nonce_str,\r\n  sign,\r\n  body,\r\n  out_trade_no,\r\n  total_fee,\r\n  spbill_create_ip,\r\n  notify_url,\r\n  trade_type,\r\n  openid\r\n){\r\n  let data = \"<xml>\"\r\n  data += \"<appid>\"+appid+\"</appid>\"\r\n  data += \"<mch_id>\"+mch_id+\"</mch_id>\"\r\n  data += \"<nonce_str>\"+nonce_str+\"</nonce_str>\"\r\n  data += \"<sign>\"+sign+\"</sign>\"\r\n  data += \"<body>\"+body+\"</body>\"\r\n  data += \"<out_trade_no>\"+out_trade_no+\"</out_trade_no>\"\r\n  data += \"<total_fee>\"+total_fee+\"</total_fee>\"\r\n  data += \"<spbill_create_ip>\"+spbill_create_ip+\"</spbill_create_ip>\"\r\n  data += \"<notify_url>\"+notify_url+\"</notify_url>\"\r\n  data += \"<trade_type>\"+trade_type+\"</trade_type>\"\r\n  data += \"<openid>\"+openid+\"</openid>\"\r\n  data += \"</xml>\"\r\n  return data\r\n}\r\n\r\nmodule.exports = requestData\r\n复制代码此时云函数的结构为payment\r\n|__index.js\r\n|__package.json\r\n|__package-lock.json //由npm install产生的文件\r\n|__random.js\r\n|__requestData.js\r\n复制代码我们需要将requestData.js文件导入到我们的项目。在云函数入口文件那里添加以下代码const requestData = require(\"requestData.js\")\r\n复制代码现在，我们可以生成调用支付统一下单API的订单了,这个dataBody就是订单。let dataBody = reqData(\r\n    appid,\r\n    mch_id,\r\n    random,\r\n    sign,\r\n    body,\r\n    out_trade_no,\r\n    total_fee,\r\n    spbill_create_ip,\r\n    notify_url,\r\n    trade_type,\r\n    openid\r\n  )\r\n复制代码到这里我们已经达成我们第二部的目的了。3.调用统一下单API -> prepay_id官方文档我们需要对官方提供的链接 https://api.mch.weixin.qq.com/pay/unifiedorder 发起统一下单，所以这里我们需要一个npm包来帮我们完成request请求，并且由于发起请求后的返回值是xml格式的，所以我们还需要一个npm包来帮助我们解析xml格式文件。故右键点击云函数payment，选择「在终端打开」，输入下面命令：npm install --save request\r\nnpm install --save xmlreader\r\n复制代码在云函数入口文件中引入上面两个包：const request = require(\"request\")\r\nconst xmlreader = require(\"xmlreader\")\r\n复制代码然后就可以在云函数入口函数中发起对统一下单API的request请求了，由于request是异步请求，所以我们需要返回一个Promise。return new Promise(reslove => {\r\n\trequest({\r\n\t\t//官方统一下单api的url\r\n\t\turl: 'https://api.mch.weixin.qq.com/pay/unifiedorder',\r\n\t\t//请求方法，post\r\n\t\tmethod: \"POST\",\r\n\t\t//需要传送的订单，就是刚刚我们生成的dataBody\r\n\t\tbody: dataBody\r\n\t}, body => {\r\n\t\t//body就是我们收到的数据，我们需要得到其中的prepay_id\r\n\t\t//使用xmlreader解析body，获得其中的prepay_id\r\n\t\txmlreader.read(body, res => {\r\n\t\t\t//此时我们已经完成第三步的目的了\r\n\t\t\tlet prepay_id = res.xml.prepay_id.text()\r\n\t\t}\r\n\t}\r\n}\r\n复制代码第三步目的完成4.将组合数据再次签名，返回5个参数已知wx.requestPayment()需要五个参数，分别是timeStampnonceStrpackagesignTypepaySign其中，timeStamp为时间戳，可由 Date.parse(new Date()).toString() 取得。 nonceStr为随机字符串，可由我们的随机函数取得。 package就是上一步获得的prepay_id， signType是签名类型，我们选择的是MD5。所以我们现在只剩下paySign未知，得到paySign的方法为paySign = MD5(appId=wxd678efh567hg6787&nonceStr=5K826\r\n4ILTKCH16CQ2502SI8ZNMTM67VS&package=prepay_id=wx20170\r\n33010242291fcfe0db70013231072&signType=MD5&timeStamp=\r\n1490840662&key=qazwsxedcrfvtgbyhnujmikolp111111) = 22D\r\n9B4E54AB1950F51E0649E8810ACD6\r\n复制代码所以我们在上一步的代码中接着写return new Promise(reslove => {\r\n\trequest({\r\n\t\turl: 'https://api.mch.weixin.qq.com/pay/unifiedorder',\r\n\t\tmethod: \"POST\",\r\n\t\tbody: dataBody\r\n\t}, body => {\r\n\t\txmlreader.read(body, res => {\r\n\t\t\tlet prepay_id = res.xml.prepay_id.text()\r\n\t\t\tlet timeStamp = Date.parse(new Date()).toString()\r\n\t\t\tlet str = `appId=${appid}&nonceStr=${random}&package=prepay_id=${prepay_id}&signType=MD5&timeStamp=${timeStamp}&key=1a79a4d60de6718e8e5b326e338ae533`\r\n\t\t\tlet paySign = crypto.createHash('md5').update(str).digest('hex')\r\n\t\t\t//返回上面的五个参数\r\n\t\t\treslove({\r\n\t\t\t\tdata: {\r\n\t\t\t\t\ttimeStamp: timeStamp,\r\n            \t\tnonceStr: random,\r\n            \t\tpackage: `prepay_id=${prepay_id}`,\r\n            \t\tsignType: 'MD5',\r\n            \t\tpaySign: paySign\r\n            \t}\r\n            })\r\n\t\t}\r\n\t}\r\n}\r\n复制代码至此，微信小程序支付流程结束。此时云函数结构为：payment\r\n|__index.js\r\n|__package.json\r\n|__package-lock.json\r\n|__random.js\r\n|__requestData.js\r\n复制代码index.js://云函数入口文件\r\nconst cloud = require('wx-server-sdk')\r\ncloud.init()\r\nconst openid = cloud.getWXContext().OPENID\r\nconst appid = 'wxwxd678efh567hg6787'\r\nconst mch_id = '1230000109'\r\nconst random = require('random.js')\r\nconst body = \"腾讯-游戏\"\r\nconst notify_url = 'http://www.weixin.qq.com/wxpay/pay.php'\r\nconst trade_type = 'JSAPI'\r\nconst key = '1a79a4d60de6718e8e5b326e338ae533'\r\nconst crypto = require(\"crypto\")\r\nconst requestData = require(\"requestData\")\r\nconst request = require(\"request\")\r\nconst xmlreader = require(\"xmlreader\")\r\n\r\n//云函数入口函数\r\nexports.main = async (event, content) => {\r\n    const out_trade_no = Date.parse(new Date()).toString()\r\n    const total_fee = event.total_fee\r\n    const spbill_create_ip = event.spbill_create_ip\r\n    let stringA = `appid=${appid}&body=${body}&mch_id=${mch_id}&nonce_str=${random}&notify_url=${notify_url}&openid=${openid}&out_trade_no=${out_trade_no}&spbill_create_ip=${spbill_create_ip}&total_fee=${total_fee}™_type=${trade_type}&key=1a79a4d60de6718e8e5b326e338ae533`\r\n    var sign = crypto.createHash('md5').update(stringA).digest('hex').toUpperCase()\r\n    let dataBody = reqData(\r\n\t    appid,\r\n\t    mch_id,\r\n\t    random,\r\n\t    sign,\r\n\t    body,\r\n\t    out_trade_no,\r\n\t    total_fee,\r\n\t    spbill_create_ip,\r\n\t    notify_url,\r\n\t    trade_type,\r\n\t    openid\r\n\t  )\r\n\treturn new Promise(reslove => {\r\n\t    request({\r\n\t        url: 'https://api.mch.weixin.qq.com/pay/unifiedorder',\r\n\t        method: \"POST\",\r\n\t        body: dataBody\r\n\t    }, body => {\r\n\t        xmlreader.read(body, res => {\r\n\t            let prepay_id = res.xml.prepay_id.text()\r\n\t            let timeStamp = Date.parse(new Date()).toString()\r\n\t            let str = `appId=${appid}&nonceStr=${random}&package=prepay_id=${prepay_id}&signType=MD5&timeStamp=${timeStamp}&key=1a79a4d60de6718e8e5b326e338ae533`\r\n\t            let paySign = crypto.createHash('md5').update(str).digest('hex')\r\n\t            //返回上面的五个参数\r\n\t            reslove({\r\n\t                data: {\r\n\t                    timeStamp: timeStamp,\r\n\t                    nonceStr: random,\r\n\t                    package: `prepay_id=${prepay_id}`,\r\n\t                    signType: 'MD5',\r\n\t                    paySign: paySign\r\n\t                }\r\n\t            })\r\n\t        }\r\n\t    }\r\n}\r\n复制代码random.js:function random(){\r\n  var result = ''\r\n  const wordList = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l',\r\n  'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '1', '2',\r\n  '3', '4', '5', '6', '7', '8', '9', '0']\r\n  for(let i=0;i<31;i++){\r\n    result += wordList[Math.round(Math.random()*36)]\r\n  }\r\n  return result\r\n}\r\n\r\nmodule.exports = random()\r\n复制代码requestData.js:function requestData(\r\n  appid,\r\n  mch_id,\r\n  nonce_str,\r\n  sign,\r\n  body,\r\n  out_trade_no,\r\n  total_fee,\r\n  spbill_create_ip,\r\n  notify_url,\r\n  trade_type,\r\n  openid\r\n){\r\n  let data = \"<xml>\"\r\n  data += \"<appid>\"+appid+\"</appid>\"\r\n  data += \"<mch_id>\"+mch_id+\"</mch_id>\"\r\n  data += \"<nonce_str>\"+nonce_str+\"</nonce_str>\"\r\n  data += \"<sign>\"+sign+\"</sign>\"\r\n  data += \"<body>\"+body+\"</body>\"\r\n  data += \"<out_trade_no>\"+out_trade_no+\"</out_trade_no>\"\r\n  data += \"<total_fee>\"+total_fee+\"</total_fee>\"\r\n  data += \"<spbill_create_ip>\"+spbill_create_ip+\"</spbill_create_ip>\"\r\n  data += \"<notify_url>\"+notify_url+\"</notify_url>\"\r\n  data += \"<trade_type>\"+trade_type+\"</trade_type>\"\r\n  data += \"<openid>\"+openid+\"</openid>\"\r\n  data += \"</xml>\"\r\n  return data\r\n}\r\n\r\nmodule.exports = requestData\r\n复制代码"}
{"title": "微信小程序--物流助手对接(中通物流)待续 ", "author": "Rolan", "put_time": "2019-8-13 00:43", "content": "---恢复内容开始---更新中获取所有绑定的物流账号请求地址GET https://api.weixin.qq.com/cgi-bin/express/business/account/getall?access_token=ACCESS_TOKEN首先获取access_token  $url=\"https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&appid=xxxx&secret=xxxx\";//(微信公众号和小程序接口一样)$json_token=m('httpurl')-> http_request($url); $access_token=json_decode($json_token,true);$url=\"https://api.weixin.qq.com/cgi-bin/express/business/account/getall?access_token=\".$access_token['access_token'];$res=m('httpurl')-> http_request($url) 还没绑定的小程序需要先绑定的 //更新快递员信息\r\n$url=\"https://api.weixin.qq.com/cgi-bin/express/business/printer/update?access_token=\".$access_token['access_token'];\r\n$print_member = array(\r\n  \"openid\"=>\"oLCoY4wuHpMKG6V_IHjvXPdocon4\",//\r\n    \"update_type\"=>\"bind\"\r\n\r\n);\r\n$json_template=json_encode($print_member);\r\n\r\n$res=m('httpurl')-> http_request($url,urldecode($json_template)); 返回stdClass Object\r\n(\r\n    [errcode] => 0\r\n    [errmsg] => ok\r\n)"}
{"title": "小程序页面通信解决方案 ", "author": "Rolan", "put_time": "2019-8-14 00:18", "content": "小程序页面通信\r\n解决方案有很多，本地缓存、全局变量、手写订阅发布。本文着重介绍另一个解决方案，就是暂存当前页面的执行上下文，然后在另一个页面调用。\r\ngithub地址\r\n简介\r\n主要是想解决小程序跨页面通信的问题，我想用一种最简单，最优雅，并且让用户可以很方便的使用的小工具。\r\n安装\r\n将 store.js 文件放在 utils 文件夹( 可以是任意文件夹 )下即可，然后引入文件。\r\n引入\r\nimport store from \"path/store.js\"\r\n复制代码使用\r\n推荐的使用流程是这样的，比如 b 页面需要用到 a 页面里的数据。\r\n\r\n先在 a 页面引入 store 然后在 onload 方法里使用 store.addData(this, \"a\") 来将当前页面的执行上下文加载到 store 的数据池里。\r\n在 b 页面引入 store ，然后就可以在 b 页面通过 store.a.数据名 来获取相应数据的值，也可以通过 store.a.数据名 = \"balabala\" 来给相应的数据赋值，这里注意，这样的赋值方式是响应式的，不需要通过 setData 函数来赋值就可以达到效果。(暂未实现 setData 方式赋值，推荐使用直接赋值)\r\n\r\n方法简介\r\n\r\n\r\n添加页面数据\r\nstore.addData( context, name )\r\n复制代码参数说明：\r\n\r\n\r\ncontext\r\n执行上下文，也就是当前页面的 this\r\n\r\n\r\nname\r\n命名当前页面，也就是在别的页面取值的时候 store.name.属性，默认值为当前页面的路径\r\n\r\n\r\n\r\n\r\n移除页面数据\r\nstore.removeData( name )\r\n复制代码参数说明\r\n\r\n\r\nname\r\n希望删除的页面数据的名字\r\n\r\n\r\n\r\n\r\n获取数据\r\nlet value = store.页面name.属性\r\n复制代码这样既可获取数据，后台是用代理封装了数据池，从而方便用户使用\r\n\r\n\r\n修改数据\r\nstore.页面name.属性 = value\r\n复制代码这样赋值即可，后台使用的依然是封装的 setData\r\n\r\n\r\n检测属性是否存在\r\nproperty in store.页面name\r\n复制代码代码\r\n/**\r\n   * @author xiaoheng\r\n   * @time 2019/8/1\r\n   * @github https://github.com/xiaoheng21\r\n   * @tip 还在找工作，有机会望告知，坐标北京\r\n   */\r\n/**\r\n   * 状态管理类\r\n   * @constructor 构造函数\r\n   * @_data  内部数据，用来保存页面数据\r\n   * @addData 添加页面数据的方法\r\n   * @removeData 移除不需要的页面数据，减小内存压力\r\n   */\r\n  class Store {\r\n    constructor() {\r\n      this._data = {};\r\n    }\r\n  \r\n    /**\r\n     * 向数据池里添加数据\r\n     * @param { Object<this> } context 保存当前页面的执行上下文，也就是当前页面的 this\r\n     * @param { String } name 当前页面数据的名字，用于在别的页面读取数据,默认值为当前页面的路径\r\n     */\r\n    addData(context, name) {\r\n      // 如果传了 name 就用传过来的，如果未传就用页面路径\r\n      let routeName = name ? name : context.route;\r\n      //设置代理，用于简化操作\r\n      let proxyContext = new Proxy(context, {\r\n        // 获取数据,如果数据在外层,返回外层数据\r\n        get: function(context, property) {\r\n          if (property in context) {\r\n            return context[property];\r\n          } else {\r\n            // 如果外层找不到数据, 就在 \"this.data\" 里找,若有，返回数据\r\n            if (property in context.data) {\r\n              return context.data[property];\r\n            } else {\r\n              //若没有,报错\r\n              console.error(`${name}页面没有此属性`);\r\n            }\r\n          }\r\n        },\r\n        // 改变数据, 封装 \"this.setData\", 简化操作\r\n        set: function(context, property, value) {\r\n          context.setData({\r\n            [property]: value\r\n          });\r\n          return true;\r\n        },\r\n        // 判断数据是否存在\r\n        has: function(context, property) {\r\n          return property in context.data;\r\n        }\r\n      });\r\n      // 将代理对象添加进数据池\r\n      this._data[routeName] = proxyContext;\r\n    }\r\n  \r\n    /**\r\n     * 从数据池里移除页面数据\r\n     * @param { String } name 需要移除的页面的名字\r\n     */\r\n    removeData(name) {\r\n      if (name in this._data) {\r\n        delete this._data[name];\r\n      } else {\r\n        console.error(`希望删除的属性不存在`);\r\n      }\r\n    }\r\n  }\r\n  \r\n  // 创建单例对象,全局共享一个数据池\r\n  const store = new Store();\r\n  \r\n  // 创建代理, 私有化 _data, 简化用户操作, 提高安全性\r\n  let proxyStore = new Proxy(store, {\r\n    // 若访问的属性为 add remove 函数, 直接返回函数\r\n    get: function(store, property) {\r\n      if (property in store) {\r\n        return store[property];\r\n      } else {\r\n        // 若访问的数据为页面数据, 则返回页面代理对象\r\n        if (property in store._data) {\r\n          return store._data[property];\r\n        } else {\r\n          // 若没有页面信息, 报错\r\n          console.error(\"访问的页面数据未载入数据池\");\r\n        }\r\n      }\r\n    }\r\n  });\r\n  \r\n  export default proxyStore;"}
{"title": "小程序实现语音识别转文字，坑路历程 ", "author": "Rolan", "put_time": "2019-8-14 00:43", "content": "最近为小程序增加语音识别转文字的功能，坑路不断，特此记录。微信开发者工具开发者工具上的录音文件与移动端格式不同，暂时只可在工具上进行播放调试，无法直接播放或者在客户端上播放debug的时候发现，工具上录音的路径是http://tmp/xxx.mp3，客户端上录音是wxfile://xxx.mp3。 忽悠呢，不是格式不同，是映射路径不同。其实做个兼容也不难，每次提示一行文字，很丑。采样率与编码码率限制每种采样率有对应的编码码率范围有效值，设置不合法的采样率或编码码率会导致录音失败。详细看这个https://developers.weixin.qq.com/miniprogram/dev/api/media/recorder/RecorderManager.start.html一开始没有留意，导致录音不成功。试过几次后，采用这样的配置，感觉录音识别率和体积之间比较好平衡：123sampleRate: 16000, //采样率numberOfChannels: 1, //录音通道数encodeBitRate: 96000, //编码码率单通道基本是必选的。因为asr只支持单通道。frameSize也是可以的，但是要考虑截断对识别的影响。暂时没有用上。录音优化因为可能误按，于是对小于500ms的录音直接忽略。另外，松开录音按键后，再延迟一点时间才真正stop录音。录音文件格式微信录音文件支持mp3和aac。这2种格式文件都比较小，aac文件体积更小。这对上传来说是件好事情，速度更快。但是对语音识别转文字就不友好了。因为百度、阿里云ASR、讯飞的语音转文字接口都不支持aac和mp3，通常要求是pcm或者wav格式。如果微信录音能提供wav格式，那么就不用服务器做格式转换了，但是wav格式体积是mp3、aac的5到10倍，至少短期是没戏了，这也是很多人吐槽的地方。服务器转换录音文件格式可以用java第三方库转换，也可以用Process调用ffmpeg转换。要注意的是，根据识别API的要求来做转换。比如阿里云asr的要求是：支持音频编码格式：pcm(无压缩的pcm文件或wav文件)、opus，16bit采样位数的单声道(mono)；支持音频采样率：8000Hz、16000Hz；java ProcessBuilder要使用数组传参转换音视频，习惯用ffmpeg。安装完ffmpeg之后，用java新建进程调用。1Process = new ProcessBuilder(\"ffmpeg -i in.mp3 out.wav\").start();一直提示CreateProcess error。 后来看文档才发现，要以数组的形式传入参数。1Process = new ProcessBuilder(\"ffmpeg\", \"-y\", \"-i\", \"in.mp3\", \"out.wav\").start();这样就启动成功了。关于java启动进程，不是本文重点，以后再写篇文章总结。阿里云asr sdk使用问题这个问题困扰了一天时间，回想起来真是吐血。问题表现是微信录制的语音很多都识别不了。最初是直接把录音mp3文件转换为pcm文件，本地能播放，但是用阿里云asr sdk却识别不了。 一开始以为是文件编码问题。特意查了asr支持的文件格式，用ffprobe检查，potplayer看属性，都没有看出问题。甚至把启动ffmpeg进程转换也改了，用了java的库去做，还是不行。后来为了方便测试问题，用asr的restful接口测试录音文件，都能识别！ 似乎是sdk的问题。于是打开官方文档例子对比。发现用的是sdk 2.x，老铁啊你复制粘贴过来的代码竟然少了！欲哭无泪。1234// TODO  重要提示：这里是用读取本地文件的形式模拟实时获取语音流并发送的，因为read很快，所以这里需要sleep// TODO  如果是真正的实时获取语音，则无需sleep, 如果是8k采样率语音，第二个参数改为8000int deltaSleep = getSleepDelta(len, sampleRate);Thread.sleep(deltaSleep);也少了对sampleRate的设置。阿里云asr token过期因为用的是免费版asr，没有给福报厂充值，因此token一天失效，导致联调的时候突然报错。最后实在受不了，写了个定时任务每小时更新token。这，就是beggar VIP"}
{"title": "微信小程序 - 输入起点、终点获取距离并且进行路线规划（腾讯地图） ... ... ", "author": "Rolan", "put_time": "2019-8-14 00:49", "content": "更新：2018-9-19 腾讯官方经纬度转详细地址，详细地址转经纬度 index.wxml\r\n<map id=\"myMap\" style=\"width: 100%; height: 300px;\" longitude=\"{{longitude}}\" latitude=\"{{latitude}}\" scale='{{scale}}' polyline=\"{{polyline}}\" markers=\"{{markers}}\" covers=\"{{covers}}\" show-location>map>\r\n\r\n\r\n\r\n\r\n起点：<input placeholder='请输入起点' bindinput='getStart'>input>\r\n终点：<input placeholder='请输入终点' bindinput='getEnd'>input>\r\n\r\n两点之间的距离：{{resultDistance}}\r\n\r\n\r\n<button bindtap=\"driving\" disabled='{{openNav}}'>开始导航button> 　　index.wxssinput{\r\n  border: 1px solid #aaa;\r\n} 　　index.js   1 // let coors;\r\n  2 // // 引入SDK核心类\r\n  3 let QQMapWX = require('./qqmap-wx-jssdk.min.js');\r\n  4 \r\n  5 // 实例化API核心类\r\n  6 let qqmapsdk = new QQMapWX({\r\n  7   key: '填写地图key'\r\n  8 });\r\n  9 \r\n 10 Page({\r\n 11 \r\n 12   /**\r\n 13    * 页面的初始数据\r\n 14    */\r\n 15   data: {\r\n 16     openNav: true\r\n 17   },\r\n 18 \r\n 19   /**\r\n 20    * 生命周期函数--监听页面加载\r\n 21    */\r\n 22   onLoad: function (options) {\r\n 23     let _page = this;\r\n 24 \r\n 25     wx.getLocation({\r\n 26       type: 'gcj02', //返回可以用于wx.openLocation的经纬度\r\n 27       success: function (res) {\r\n 28         _page.setData({\r\n 29           latitude: res.latitude,\r\n 30           longitude: res.longitude,\r\n 31           scale: 10\r\n 32         });\r\n 33       }\r\n 34     })\r\n 35     wx.clearStorageSync('latlngstart');\r\n 36     wx.clearStorageSync('latlngend');\r\n 37   },\r\n 38 \r\n 39   /**\r\n 40    * 生命周期函数--监听页面初次渲染完成\r\n 41    */\r\n 42   onReady: function () {\r\n 43 \r\n 44   },\r\n 45 \r\n 46   /**\r\n 47    * 起点\r\n 48    */\r\n 49   getStart(e) {\r\n 50     let _page = this;\r\n 51     \r\n 52 \r\n 53     /**\r\n 54      * 修改：以前示例(2018-09-15)地址转经纬度用错接口了\r\n 55      */\r\n 56     qqmapsdk.getSuggestion({\r\n 57       keyword: e.detail.value,\r\n 58       success: function (res) {\r\n 59         let lat = res.data[0].location.lat;\r\n 60         let lng = res.data[0].location.lng;\r\n 61 \r\n 62         wx.setStorageSync('latlngstart', {\r\n 63           lat: lat,\r\n 64           lng: lng\r\n 65         });\r\n 66       },\r\n 67       fail: function (res) {\r\n 68         console.log(res);\r\n 69       },\r\n 70       complete: function (res) {\r\n 71         console.log(res);\r\n 72       }\r\n 73     });\r\n 74 \r\n 75 \r\n 76     /**\r\n 77      * 修改为（2018-09-19）\r\n 78      */\r\n 79 \r\n 80     qqmapsdk.geocoder({\r\n 81       address: res.address,\r\n 82       success: function(res) {\r\n 83         let lat = res.result.location.lat;\r\n 84         let lng = res.result.location.lng;\r\n 85         wx.setStorageSync('latlngendSend', {\r\n 86           lat: lat,\r\n 87           lng: lng\r\n 88         });\r\n 89 \r\n 90         // 起点经纬度\r\n 91         let latStart = wx.getStorageSync('latlngstartSend').lat;\r\n 92         let lngStart = wx.getStorageSync('latlngstartSend').lng;\r\n 93 \r\n 94         // 终点经纬度\r\n 95         let latEnd = wx.getStorageSync('latlngendSend').lat;\r\n 96         let lngEnd = wx.getStorageSync('latlngendSend').lng;\r\n 97 \r\n 98         qqmapsdk.calculateDistance({\r\n 99           to: [{\r\n100             latitude: latStart,\r\n101             longitude: lngStart\r\n102           }, {\r\n103             latitude: latEnd,\r\n104             longitude: lngEnd\r\n105           }],\r\n106           success: function(res) {\r\n107             console.log(res, '两点之间的距离(代送)：', res.result.elements[1].distance);\r\n108             wx.setStorageSync('kmSend', res.result.elements[1].distance + \"\");\r\n109           }\r\n110         });\r\n111       }\r\n112     });\r\n113 \r\n114 \r\n115 \r\n116     // 如果输入地点为空：则不规划路线\r\n117     if (e.detail.value == '') {\r\n118       _page.setData({\r\n119         openNav: true,\r\n120         resultDistance: ''\r\n121       });\r\n122     } else {\r\n123       _page.setData({\r\n124         openNav: false\r\n125       });\r\n126     }\r\n127   },\r\n128 \r\n129   /**\r\n130    * 终点\r\n131    */\r\n132   getEnd(e) {\r\n133     let _page = this;\r\n134     // 输入地点获取经纬度,我取得是数据的第一条数据.\r\n135     qqmapsdk.getSuggestion({\r\n136       keyword: e.detail.value,\r\n137       success: function (res) {\r\n138         let lat = res.data[0].location.lat;\r\n139         let lng = res.data[0].location.lng;\r\n140 \r\n141         wx.setStorageSync('latlngend', {\r\n142           lat: lat,\r\n143           lng: lng\r\n144         });\r\n145       },\r\n146       fail: function (res) {\r\n147         console.log(res);\r\n148       },\r\n149       complete: function (res) {\r\n150         console.log(res);\r\n151       }\r\n152     });\r\n153     // 如果输入地点为空：则不规划路线\r\n154     if (e.detail.value == '') {\r\n155       _page.setData({\r\n156         openNav: true,\r\n157         resultDistance: ''\r\n158       });\r\n159     } else {\r\n160       _page.setData({\r\n161         openNav: false\r\n162       });\r\n163     }\r\n164   },\r\n165   //事件回调函数\r\n166   driving: function () {\r\n167 \r\n168     let _page = this;\r\n169 \r\n170     // 起点经纬度\r\n171     let latStart = wx.getStorageSync('latlngstart').lat;\r\n172     let lngStart = wx.getStorageSync('latlngstart').lng;\r\n173 \r\n174     // 终点经纬度\r\n175     let latEnd = wx.getStorageSync('latlngend').lat;\r\n176     let lngEnd = wx.getStorageSync('latlngend').lng;\r\n177 \r\n178 \r\n179     _page.setData({\r\n180       latitude: latStart,\r\n181       longitude: lngStart,\r\n182       scale: 16,\r\n183       markers: [{\r\n184         id: 0,\r\n185         latitude: latStart,\r\n186         longitude: lngStart,\r\n187         // 起点图标\r\n188         iconPath: '../image/location.png'\r\n189       },\r\n190       {\r\n191         id: 1,\r\n192         latitude: latEnd,\r\n193         longitude: lngEnd,\r\n194         // 终点图标\r\n195         iconPath: '../image/location.png'\r\n196       },\r\n197       ]\r\n198     });\r\n199     ``\r\n200 \r\n201     /**\r\n202      * 获取两点的距离\r\n203      */\r\n204     qqmapsdk.calculateDistance({\r\n205       to: [{\r\n206         latitude: latStart,\r\n207         longitude: lngStart\r\n208       }, {\r\n209         latitude: latEnd,\r\n210         longitude: lngEnd\r\n211       }],\r\n212       success: function (res) {\r\n213         console.log(res, '两点之间的距离：', res.result.elements[1].distance);\r\n214         _page.setData({\r\n215           resultDistance: res.result.elements[1].distance + '米'\r\n216         });\r\n217       },\r\n218       fail: function (res) {\r\n219         console.log(res);\r\n220       },\r\n221       complete: function (res) {\r\n222         console.log(res);\r\n223       }\r\n224     });\r\n225 \r\n226     //网络请求设置\r\n227     let opt = {\r\n228       //WebService请求地址，from为起点坐标，to为终点坐标，开发key为必填\r\n229       url: `https://apis.map.qq.com/ws/direction/v1/driving/?from=${latStart},${lngStart}&to=${latEnd},${lngEnd}&key=${qqmapsdk.key}`,\r\n230       method: 'GET',\r\n231       dataType: 'json',\r\n232       //请求成功回调\r\n233       success: function (res) {\r\n234         let ret = res.data\r\n235         if (ret.status != 0) return; //服务异常处理\r\n236         let coors = ret.result.routes[0].polyline,\r\n237           pl = [];\r\n238         //坐标解压（返回的点串坐标，通过前向差分进行压缩）\r\n239         let kr = 1000000;\r\n240         for (let i = 2; i < coors.length; i++) {\r\n241           coors[i] = Number(coors[i - 2]) + Number(coors[i]) / kr;\r\n242         }\r\n243         //将解压后的坐标放入点串数组pl中\r\n244         for (let i = 0; i < coors.length; i += 2) {\r\n245           pl.push({\r\n246             latitude: coors[i],\r\n247             longitude: coors[i + 1]\r\n248           })\r\n249         }\r\n250         //设置polyline属性，将路线显示出来\r\n251         _page.setData({\r\n252           polyline: [{\r\n253             points: pl,\r\n254             color: '#FF0000DD',\r\n255             width: 4\r\n256           }]\r\n257         })\r\n258       }\r\n259     };\r\n260     wx.request(opt);\r\n261   }\r\n262 })"}
{"title": "微信小程序文档没写支持, 但是实际支持的选择器有哪些? ", "author": "Rolan", "put_time": "2019-8-16 00:17", "content": "小程序文档上说\r\n目前支持的选择器有：\r\n\r\n在实践中我发现, 除了文档上说的几种选择器, 经过测试发现其实还有几种支持的选择器没有列举!\r\n还支持哪些选择器?\r\n后面讲解的例子都以此xml结构为基础:\r\n<view class=\"parent\">\r\n    <text class=\"son son-1\">大儿子</text>\r\n    <text class=\"son son-2\" space>二儿子</text>\r\n    <text class=\"son son-3\">三儿子</text>\r\n</view>\r\n<button type=\"primary\">按钮</button>\r\n复制代码\"~\"选择器\r\n选择其后所有同级元素:\r\n.parent text {\r\n  display: block;\r\n  font-size: 24px;\r\n}\r\ntext.son-1 ~ text {\r\n  color: #69c;\r\n}\r\n复制代码\r\n\"+\"选择器\r\n选择其后紧邻同级元素:\r\n.parent text {\r\n  display: block;\r\n  font-size: 24px;\r\n}\r\ntext.son-1 + text {\r\n  color: #69c;\r\n}\r\n复制代码\r\nxx:nth-child(n)\r\n第n个xx表达式对应的元素\r\n.parent>text {\r\n  display: block;\r\n  font-size: 24px;\r\n}\r\n.parent>text:nth-child(2) {\r\n  color: #f10;\r\n}\r\n复制代码\r\n经过测试, 类似的还有 ::last-of-type(n),  :nth-last-child(n), :nth-last-of-type(n), :first-of-type 也都好使.\r\n[attribute]\r\n拥有attribute属性的元素\r\nbutton[type]{\r\n    height: 200px;\r\n}\r\n复制代码\r\n经过测试, 类似的还有 :[attribute=value], [attribute~=value], [attribute|=value] 也都好使.\r\n注: 由于微信支持的标签上的属性和html的并不一致, 有很多html支持的属性微信是不支持的, 如果不支持的属性是没有使用属性选择器的.\r\n微信支持的标签\r\n总结\r\n列一下本文补充的选择器:\r\n\r\n:nth-child(n)\r\n:last-of-type(n)\r\n:nth-last-child(n)\r\n:nth-last-of-type(n)\r\n:first-of-type\r\n[attribute]\r\n[attribute=value]\r\n[attribute~=value]\r\n[attribute|=value]\r\n\r\n我也是刚开始学习微信小程序开发可能还有遗漏, 还请大家包涵以及指正,后续如有新的发现我也会补充到本文, 方便大家查阅, 感谢阅读."}
{"title": "微信小程序日常排坑(持续更新) ", "author": "Rolan", "put_time": "2019-8-16 00:31", "content": "日常排坑\r\n\r\n小程序这些发展很火，当时被公司派去做小程序是17年底，是一个无人货架的小程序，至今已经过了这么久，总结一下自己的经验教训吧，从原生小程序到框架小程序谈谈自己看法的同时，也记录一些排坑，不是大神，简陋勿怪\r\n\r\n脚手架\r\n分享一个cli(看个人习惯用js还是ts)\r\n链接地址\r\nrequesst封装\r\n\r\n一般只看掘金啊，思否这些,自己代码的质量还不是很能保证。希望这里能有大佬给出优化\r\n\r\n\r\n    let $ajax = {\r\n      header: {\r\n        \"content-type\": \"application/json\"\r\n      },\r\n      get: function(param) {\r\n        return this.methods(\"GET\", param);\r\n      },\r\n      post: function(param) {\r\n        return this.methods(\"POST\", param);\r\n      },\r\n      methods: function(type = \"GET\", param = {}) {\r\n        const token=wx.getStorageSync('token');\r\n        token===undefined?wx.navigateTo({\r\n          url:'/login'\r\n        }):\"\"\r\n        return new Promise((resolve, reject) => {\r\n          wx.request({\r\n            url: \"test.php\", //仅为示例，并非真实的接口地址\r\n            data: param,\r\n            header: this.header,\r\n            success(res) {\r\n              resolve(res);\r\n            },\r\n            fail(err) {\r\n              reject(err);\r\n            }\r\n          });\r\n        });\r\n      }\r\n    };\r\n    }\r\n\r\n复制代码小程序优化方案\r\n\r\n唔。。大家一起折腾一下 欢迎留言\r\n\r\n滚动和点击优化\r\n函数优化,防抖节流(代码网上一堆，不搬了)\r\n我用的最多就是节流函数，一般在页面滚动scroll, 按钮反复点击(如果网络比较慢，反复点击会发现从A->B页面时进入了两次)\r\n\r\n节流函数\r\n\r\n比如5秒内，无论你怎么触发，都不会执行，原理利用了定时器Timeout。\r\n\r\n防抖函数\r\n\r\n说白了就是延迟函数。即触发之后立即执行，5秒后再执行\r\n数据优化\r\n1.反复setData一个很大的数组不是一件好事，会重绘\r\n如果只修改单条数据\r\nlet obj={\r\n    name:'张三',\r\n    age:'23',\r\n    gender:'男'\r\n}\r\nlet userList=[{\r\n    userName:'小明'\r\n},{\r\n    userName:'小王'\r\n}]\r\n//数组\r\nthis.setData({\r\n    'userList[0].userName':value\r\n})\r\n//对象\r\nthis.setData({\r\n    'obj.gender':value\r\n})\r\n复制代码滚动底部加载分页数据，优化一次性setData数据过多的情况\r\n\r\n采用二维数组的形式\r\n\r\n理由:小程序有数据限制，一次性setData太多数据不然会凉凉,当然这是考虑大佬们的公司数据特多的时候，一般情况还是没问题的。\r\n//场景如下：此时已经加载了两页数据即两个数组userList\r\nlet userList=[[{a:2}],[b:2]] //目前所存\r\nlet page=3;  //\r\nlet data=[{a:3}]  //是后台返回第三页的数组\r\nthis.setData({\r\n    ['userList[' + (page - 1) + ']']: data\r\n})\r\n复制代码图片优化\r\n1.前端一些小icon图片压缩,其余用cdn服务器\r\n2.微信也提供了API 监听wxml的位置是否出现在界面上，API我就放到这了，大概的作用就是监听wxml是否在用户显示区域，如果不在 就可以不加载看不见的图片(最好用Proomise和匿名函数封装一下再用)\r\nkey值\r\n这点应该不止在小程序，在Vue,React中都有体现，Key是有作用的，如果不是很有用的数据用index做key没啥问题，如果不是，首先用key，因为index是会改变的，原本缓存的数据会因为key值的改变导致重绘,消耗了小程序的性能\r\n\r\n我就讲大白话了。。key值就是后端传入的数组中唯一的值，以此作为key\r\n\r\n代码优化\r\n\r\n在目录设计上要有公共的utils,css,以及组件(在app.js中使用usingComponents)，能复用就复用，跟UI小姐姐讲讲不要同一个功能各种花里胡哨...\r\n在实际运用中,建议使用分包加载功能，在初次进入时,减少加载的代码体积，提高速度，等进入到分包的页面，才加载\r\n代码方面 我一般是一个函数就做一件事情，不混在一起，比如购物车等，这样子也方便维护著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}
{"title": "微信小程序之富文本解析（附源码和效果图） ", "author": "Rolan", "put_time": "2019-8-16 00:41", "content": "示例效果图：\r\n\r\n一、简介及说明\r\n在小程序项目开发中，会遇到富文本编辑的内容，后台返回到小程序端无法解析，这时就需要一个插件来处理。\r\n微信小程序没有提供webview等html解析，原展示类文本没有办法图文并茂的原生展示，wxParse主要目的就是弥补富文本解析空缺的问题。\r\n插件由联盟网站DEV开发，开发者：icindy，最新版本请查看github地址：wxParse\r\n二、 使用方法\r\n1、下载wxParese文件，拷贝wxParse文件夹到自己的小程序项目中。\r\n\r\n2、在项目文件中使用\r\n（1）在需要使用的wxml文件中引入WxParse.wxml\r\n示例：\r\n<!--index.wxml-->\r\n<import src=\"../../wxParse/wxParse.wxml\" />\r\n复制代码（2）在当前页对应的js中引入wxParse.js\r\n示例：\r\n//index.js \r\nconst WxParse = require('../../wxParse/wxParse.js');\r\n复制代码（3）使用template组件\r\n在刚刚引入的wxml中插入组件，具体插入的位置是需要转换的地方。\r\n示例:\r\n<!--index.wxml-->\r\n<import src=\"../../wxParse/wxParse.wxml\" />\r\n<view class=\"container\">\r\n  <view class='uinn'>\r\n    <template is=\"wxParse\" data=\"{{wxParseData:article.nodes}}\" />\r\n  </view>\r\n</view>\r\n复制代码（4）在当前页的js中使用WxParse中的方法\r\n//index.js\r\nconst WxParse = require('../../wxParse/wxParse.js');\r\nPage({\r\n  data: {\r\n    \r\n  }, \r\n  onLoad: function () {\r\n    let that = this;\r\n    let ceshi = \r\n    `<div>\r\n\t\t\t<span>请说出你喜欢的水果？</span>\r\n\t\t\t<ul>\r\n\t\t\t\t<li>苹果</li>\r\n\t\t\t\t<li>香蕉</li>\r\n\t\t\t\t<li>橙子</li>\r\n\t\t\t</ul>\r\n\t\t</div>`;\r\n    WxParse.wxParse('article', 'html', ceshi, that, 5); \r\n  }, \r\n})\r\n复制代码参数说明：\r\n\r\n示例代码已上传到GitHub上，可直接拷贝示例代码的wxParse文件使用，地址：wx-wxParese，欢迎start。\r\n其它文章请访问：\r\n\r\n微信小程序之自定义组件\r\n微信小程序之根据经纬度反查地址\r\n微信小程序之转发功能（附效果图和源码）\r\n微信小程序之轮播图的实现（附效果图和源码）\r\n微信小程序之tab的实现（附源代码和效果图）\r\n微信小程序之多列表的显示和隐藏功能（附源码）"}
{"title": "vue项目微信小程序页面跳转web-view不刷新 ", "author": "Rolan", "put_time": "2019-8-16 00:49", "content": "背景#最近项目需要适配小程序，项目是使用了vue开发的网站，其中改造方式是，每个页面都使用小程序创建一个页面通过web-view来显示指定页面的。在没有使用小程序时，路由跳转时，刷新页面等等，这个是很顺畅的，在使用了小程序之后，需要适配小程序的页面，比如后退到前一页，这个时候要刷新页面，于是遇到了小程序的一些特性。问题描述#有两个页面：A=http://demo.com/#/A?code=12，B=http://demo.com/#/B?index=2A页面跳到B页面，B页面把一些处理后的结果以参数的形式传给A页面。例如：B页面的使用了wx.navigateBack（其它跳转函数同理），且url（http://demo.com/#/A?code=12&index=12）以参数的形式传给了A页面，A页面在OnShow方法里面重新设置了web-view的src地址，能保证正确，但是页面就是不刷新，且使用微信开发者工具，能看到src已经被改变了。尝试解决#网上一些方法：比如先设置src为空字符串，然后再通过setTimeout设置src为期望的值，且要设置时间为60ms以上（玄学），这个方法之前我还真解决了一个问题，不过那个场景是：A是一个web-view页面，B是一个小程序页面，B返回A时，通过给A传递参数，设置src可以通过此方法正确显示，此方法但是没有解决A、B页面都是web-view的形式。网上一些方法：在B页面先把A页面的src设置为空，然后再直接设置为需要的url，此方法依然对本问题无效我把1、2两种方案结合也没有解决。最小化正确原型这个时候，我在思考这个页面到底能不能正常刷新，注意这个想法非常的重要：我用了最小正确原型来先验证，能否正确得到期望，最小原型如下：A的页面web-view src=https://baidu.com，然后打开看一下，可以正常显示页面，之后在B页面返回A页面时，给A页面传递了一个url，在A页面OnShow里面设置了A的src=https://www.qq.com，结果页面刷新了，正确的显示了www.qq.com页面，也就是说不需要什么settimeout。之后反复测试，同样的连接是不刷新的；设置为空是不刷新的。这个时候，已经找到了可以正常刷新的条件，不是原链接、不是空，都可以刷新页面，那么问题来了，A页面的链接都已经变了，后面的参数变了，怎么还跟缓存了一样（同一个get链接，会被缓存起来的）。再分析原始的A的链接从http://demo.com/#/A?code=12，变成了http://demo.com/#/A?code=12&index=12，这个形式，改变够大了，但是还是缓存了，这个时候应该就是缓存策略问题了，毕竟以前解决ie浏览器时，我们通过添加url随机数就可以避免。注意到了吗?vue页面中使用了#作为路由判断的，而#在浏览器中是作为锚点使用的，是不是小程序对这个解析也有差别，认为是同一个页面，于是做了如下的测试：http://demo.com/?code=12&index=12/#/A结果，参数放到#之前，小程序果然刷新了，看来小程序对#就是按照同一个页面解析的，好了刷新的问题解决了，下来看看vue是否能正确识别参数使用this.$route.query.index的值，成功取得了值。最后#自此问题得以解决，总结如下：网上的很多解决方法适用场景可能跟你的不一样；黔驴技穷时，使用最小正确原型开始验证期望；找到差异的地方，或者特殊的地方可能就是问题所在；懂原理、机制能事半功倍快速解决问题小程序还可以提升的更好，比如方案1真的有效，要不是之前第一版迁移方案我遇到过，我都觉得这个是开玩笑的方法"}
{"title": "微信小程序中web-view再次刷新后页面需要退两次 ", "author": "Rolan", "put_time": "2019-8-16 00:58", "content": "背景#在上一章(直击根源：vue项目微信小程序页面跳转web-view不刷新)解决了vue在小程序回退不刷新的问题之后，会引出了一个刷新的页面需要点击返回两次才能返回上一个页面问题描述#在A页面从B页面带了参数返回之后，A页面会刷新，直接导致了，A页面返回上一个页面需要点击两次，其中点击一次时还是A页面。解决方案#首先第一个想法就是，设置一下退回按钮直接跳到上一个页面去；经过资料查找，回退按钮是没有直接触发函数的，也就是说不能直接控制回退的功能。在寻找资料时，发现可以间接的触发一个unload函数，于是尝试在当前页面退回按钮点击后，会立即触发当前页面的unload方法，在unload里面尝试跳转到A的前一页，结果如下：Copy1. 在第一次点击退回，没有触发unload\r\n2. 再次点击退回，成功触发了unload与期望不符，预期unload第一次退回触发才可以进行页面跳转那么是web-view刷新产生的这个页面，也不能干掉，让web-view刷新这个页面就可以了，找了很多资料，没有理出一个头绪，web-view既然是第二次刷新产生的，那么让只刷新第一次是不是就可以解决了，于是做了如下尝试：在B页面把A页面的web-view的src变量置为空，然后在A页面web-view上添加wx:if={{src!==''}}的条件控制，在src为空时销毁web-view，然后在B页面退回通过另一个变量把需要的url传递过去在A页面onShow，再设置src为一个我们期望的跳转url，总结一下：Copy A页面跳到B页面时设置A的src为空-销毁了`web-view`，退回A页面时在onShow方法在设置src的值-`web-view`被重新渲染测试结果得到了预期：页面被刷新，且没有了A页面退回两次的情况总结#Copy1. web-view在src变化之后，会产生一个新的页面，并加入的页面栈里面\r\n2. 刷新之后的页面回退不会有unload方法调用\r\n3. web-view销毁重建可以避免产生新的页面\r\n4. 销毁重建解自此，微信小程序使用vue嵌套页面刷新的核心问题都解决了"}
{"title": "uni-app微信小程序接入人脸核身SDK ", "author": "Rolan", "put_time": "2019-8-19 00:37", "content": "这几天使用uni-app开发某银行的一个微信小程序，需要集成接入腾讯云的人脸核身SDK，如上图所示，记录下整合接入过程及踩的一些坑，帮助后面需要的朋友们。关于uni-app接入人脸核身SDK有不懂的地方可以在下面提问，看到会及时回复。申请服务不是所有的企业都能够申请的，需要符合以下行业要求的客户才能申请政务：政府机构或事业单位金融：银行、保险医疗：公立医疗机构运营商：电信运营商教育：公立教育机构交通：航空、客运、网约车、交通卡、共享交通、轨道交通、租车旅游：酒店物流：快递、邮政、物流由于SDK会调用小程序原生的 wx.startFacialRecognitionVerify 方法，所以总共得申请2个服务SDK服务： 申请人脸核身服务小程序： 查看申请流程 （需要发送邮件申请，使用该服务的小程序的appid，后面开发也是用的这个）重要的事情说3遍以上这2个服务都需要申请，缺一不可。以上这2个服务都需要申请，缺一不可。以上这2个服务都需要申请，缺一不可。下载SDK由于不是我申请的，所以怎么下载我也不知道，听群里的人说的是SDK腾讯云下发给客户的。SDK目录结构SDK接入参考腾讯云文档的接入方法： https://cloud.tencent.com/document/product/1007/31071文档是针对原生小程序写的，所以页面引入的方法有所不同由于uni-app不支持直接引入小程序的原生页面，所以这里能想到的就是将它当作成一个微信小程序的组件，然后uni-app的页面引入这个组件解压引入SDK在uni-app项目中新建 wxcomponents 目录，将SDK解压后放到该目录pages.json 中 globalStyle 中全局引入小程序的组件，注意引用的路径\"usingComponents\": {\r\n  \"verify-mpsdk\": \"/wxcomponents/verify_mpsdk/index/index\"\r\n}新建人脸核身页面pages 中新建人脸核身的页面 face (名字可以随意，根据自己的需要起名)，pages.json 中配置页面face 页面中引入 verify-mpsdk 组件最终的人脸核身的页面访问就是 /pages/face/face初始化SDK在需要的页面初始化SDK，如有个页面需要点击按钮进行人脸核身，就在这个页面进行初始化。这个直接照着文档 快速入门 中的来就行了，这里就直接使用uni-app默认的 index 页面，适当修改下即可，大概代码如下：<template>\r\n  <view class=\"content\">\r\n    <button type=\"primary\"\r\n      @tap=\"gotoVerify\">\r\n      进入人脸核身\r\n    </button>\r\n  </view>\r\n</template>\r\n\r\n<script>\r\n    export default {\r\n        data() {\r\n            return {\r\n                BizToken: ''\r\n            }\r\n        },\r\n        onLoad() {\r\n            // 初始化慧眼实名核身组件\r\n            const Verify = require('@/wxcomponents/verify_mpsdk/main.js')\r\n            Verify.init()\r\n        },\r\n        methods: {\r\n            // 单击进入人脸核身按钮时，触发该函数\r\n            gotoVerify () {\r\n                this.BizToken = '' // 这里需要我们去客户后端调用DetectAuth接口获取BizToken\r\n                // 调用实名核身功能\r\n                wx.startVerify({\r\n                        data: {\r\n                            token: this.BizToken // BizToken\r\n                        },\r\n                        success: (res) => { // 验证成功后触发\r\n                                // res 包含验证成功的token, 这里需要加500ms延时，防止iOS下不执行后面的逻辑\r\n                                setTimeout(() => {\r\n                                    // 验证成功后，拿到token后的逻辑处理，具体以客户自身逻辑为准\r\n                                    console.log(res)\r\n                                }, 500)\r\n                        },\r\n                        fail: (err) => {  // 验证失败时触发\r\n                                // err 包含错误码，错误信息，弹窗提示错误\r\n                                setTimeout(() => {\r\n                                        console.log(err)\r\n                                        wx.showModal({\r\n                                            title: \"提示\",\r\n                                            content: err.ErrorMsg,\r\n                                            showCancel: false\r\n                                        })\r\n                                }, 500)\r\n                        }\r\n                })\r\n            }\r\n        }\r\n    }\r\n</script>注意下这里的 BizToken ,需要调用后端服务接口来获取，需要后端的同学调用腾讯云提供的 DetectAuth 来返回前端需要的 BizToken ，调试开发阶段我们可以先通过腾讯云提供的工具API 3.0 Explorer直接来获取这个 BizToken 如果服务申请成功后控制台一般能找到 SecretId ， SecretKey ， RuleId 注意 Endpoint 和 Region 选择的地区得保持和申请时选择的地区一致。填写完成后点击 在线调用 中的 发送请求 按钮，如果填的都对的话返回信息里面会有 BizToken 拿到 BizToken 后就可以直接使用了，修改下上面的代码：xxxxxxxxxxxxxxxxx就是拿到的 BizTokenthis.BizToken = 'xxxxxxxxxxxxxxxxx' // 这里需要我们去客户后端调用DetectAuth接口获取BizToken开发调试上面都做完后就可以进行调试了需要先在项目中 manifest.json 中配置上小程序的appid，这个appid就是上面 申请服务 中的appid，不然无法开启调试。然后运行到微信开发工具（这里就不多说了），如果提示不是开发人员，就让该appid的管理员将你加到开发组里面就行了。运行成功后点击开发者工具的真机调试，扫描二维码开启真机调试模式。接下来就是踩坑了，会出现各种问题。踩坑及解决方法Component is not found in path这里开发者工具里面都是显示正常的，不会报这个错，手机扫码进入调试后控制台会出现这个报错，提示组件找不到，但是我们的路径都是对的，Component is not found in path \"wxcomponents/verify_mpsdk/index/index\" 问题出在这里将 verify_mpsdk 当成自定义组件了，小程序自定义组件引入的时候需要在文件JSON中指定 \"component\": true 找到 wxcomponents\\verify_mpsdk\\index\\index.json 文件，加入 \"component\": true 即可重新开启调试扫码后上面的报错就没了。 navigateTo:fail page点击按钮调用 gotoVerify 后会报一个页面找不到的错navigateTo:fail page \"verify_mpsdk/index/index?isNotice=false\" is not found SDK默认的是跳转验证页面的地址是 verify_mpsdk/index/index ，文档找了半天也没找到相应的配置地址，最后在SDK里面搜索找到了这个地址。所以只需要把这个地址改成我们所需要的地址就行了。找到 wxcomponents\\verify_mpsdk\\main.js ，里面搜索 verify_mpsdk/index/index ,找到后修改成上面 人脸核身页面 的地址 pages/face/face 保存后重试就能跳转到人脸核身的页面了。无操作、无报错大坑进入人脸核身的页面后会发现啥操作都没，控制台也没报错，一度认为我自己弄的有问题，搞了好久也没弄好，也提了个工单（腾讯云工单反馈率还是很快的，几分钟后就有人回复了，这点赞一个），将代码和相关操作在工单里描述了下，对方也觉得的没问题，按照快速入门的代码应该是没问题的，对方也没找到啥问题，就让我加了一个腾讯云慧眼小助手的微信，本想着下午加人家看看啥问题的，中午吃完饭闲着的时候将SDK里面的文件都格式化后终于在 index.js 里面找到问题所在了。wxcomponents\\verify_mpsdk\\index\\index.js 文件中有个 onLoad 生命周期，正常原生微信小程序进入到这个页面的时候会执行 onLoad 里面的代码，但是我们上面将这个SDK当作是一个自定义组件了，在uni-app中组件是不存在 onLoad 这个生命周期的，这个是页面所属的生命周期。找到问题所在就好解决了，我们可以在人脸核身的页面 pages/face/face 手动执行 onLoad 修改下 pages/face/face 的代码，如下：<template>\r\n  <view class=\"face\">\r\n    <verify-mpsdk ref=\"verifyMpsdk\"></verify-mpsdk>\r\n  </view>\r\n</template>\r\n\r\n<script>\r\n    export default {\r\n        data() {\r\n            return {\r\n                \r\n            }\r\n        },\r\n        onLoad(i) {\r\n            // 页面onLoad的时候手动调用\r\n            this.$refs.verifyMpsdk.onLoad(i)\r\n        }\r\n    }\r\n</script>保存后重试，就能正常显示了SDK图片异常点击快速验证进入下一步及后面的步骤的时候发现，页面的图片都挂掉了不显示，一开始我一直用的真机调试，页面上也不会出现破图，控制台也不会报图片异常的错误，导致我不知道怎么进行拍摄身份证，以为会自动识别身份证然后自动下一步，最后在开发者工具里面跑了一遍才知道是图片找不到了，然后拍照的图片按钮自然也就显示不了了。最后在SDK里面搜索 /verify_mpsdk/images ，在下面文件中找到关键词，wxcomponents\\verify_mpsdk\\templates\\ocr\\ocr.wxml 既然这种形式导致运行的时候图片找不到，我们可以把SDK所用的图片都复制到项目的 static目录里在 static 中新建 verify_mpsdk 目录，将SDK中的图片即 wxcomponents\\verify_mpsdk\\images 复制到 static\\verify_mpsdk 中，最终形成以下目录形式最后将 wxcomponents\\verify_mpsdk\\templates\\ocr\\ocr.wxml 中的 /verify_mpsdk/images 批量替换成/static/verify_mpsdk/images 后重试即可，然后就都正常了。完整流程最后用真机调试完整跑一把备注：如果最上面的 wx.startFacialRecognitionVerify 服务没有申请到此时点击下一步的会弹出一个无权限的弹窗无法进行下一步这里就是活体人脸检测了，需要将脸对准框框，点击开始后需要读几个数字，最后验证通过后会回到之前的页面（调用gotoVerify()方法的页面），验证成功后，会拿到一个 BizToken ，可以在 wx.startVerify 回调函数 success 中打印自行查看。拿到 BizToken 后可以调用后端的接口，后端通过调用  GetDetectInfo 接口获取并返回本次核身的详细信息，包括身份证上的信息和身份证证图片等信息。前端拿到这些信息后根据自己的程序需要做处理。结语整合过程中遇到不少问题，百度加google也找不到相关的详细信息，人脸核身的相关文档都很简单，出现问题后无从下手，只能慢慢自己摸索解决了，最后写篇文章记录下整个过程，也能帮到后面需要集成这个SDK的朋友们。"}
{"title": "微信小程序canvas绘制圆角base64图片 ", "author": "Rolan", "put_time": "2019-8-19 00:47", "content": "接口返回base64格式小程序二维码，以往的做法是需要再调一个接口去拿到jpg/png格式的图片。如果没有这个接口呢，是不是也可以？然而小程序canvas并不支持直接使用base64绘制，好在小程序的文件系统提供了方法，可以把base64经过进一步处理转成本地图片。获取base64格式图片getXcxQrcode() {\r\n\twx.request({\r\n\turl: app.globalData.globalUrl + \"/get_wx_code\",\r\n\tdata: {\r\n\t\ttoken: app.globalData.weixin_token,\r\n\t\tscene: app.globalData.page_key,\r\n\t\tpage: \"pages/index/index\"\r\n\t},\r\n\tsuccess: (res) => {\r\n\t\tif (data.data.success) {\r\n\t\t\tthis.base64src(data.data)\r\n\t\t}\r\n\t}\r\n\t})\r\n}\r\nbase64格式图片转换成本地图片base64src(base64data) {\r\n\tconst filePath = `${wx.env.USER_DATA_PATH}/tmpbase64.png`;\r\n\tconst buffer = wx.base64ToArrayBuffer(base64data.buffer);\r\n\tlet that = this;\r\n\tfsm.writeFile({\r\n\t  filePath,\r\n\t  data: buffer,\r\n\t  encoding: 'binary',\r\n\t  success() {\r\n\t    that.setData({\r\n\t      qrcodeUrl: filePath  // 得到http://usr/tmpbase64.png\r\n\t    })\r\n\t  },\r\n\t  fail() {\r\n\t    reject(new Error('ERROR_BASE64SRC_WRITE'));\r\n\t  },\r\n\t});\r\n},\r\n使用获得的本地图片绘制圆角二维码var qrW = 150; //绘制的二维码宽度\r\nvar qrH = 150; //绘制的二维码高度\r\nvar qr_x = 540; //绘制的二维码在画布上的位置\r\nvar qr_y = 960; //绘制的二维码在画布上的位置\r\nctx.save();\r\n\r\nctx.beginPath(); //开始绘制\r\n//先画个圆   前两个参数确定了圆心 （x,y） 坐标  第三个参数是圆的半径  四参数是绘图方向  默认是false，即顺时针\r\nctx.arc(qrW / 2 + qr_x, qrH / 2 + qr_y, qrW / 2, 0, Math.PI * 2, false);\r\n\r\nctx.clip(); //画好了圆 剪切  原始画布中剪切任意形状和尺寸。一旦剪切了某个区域，则所有之后的绘图都会被限制在被剪切的区域内 这也是我们要save上下文的原因\r\nctx.drawImage(this.data.qrcodeUrl, qr_x, qr_y, qrW, qrH);\r\nctx.draw()"}
{"title": "扫小程序码实现网站登陆,提供源代码 ", "author": "Rolan", "put_time": "2019-8-19 00:51", "content": "使用扫小程序码登陆网站\r\n网络上关于实现本本功能的文章很多，但是给出案列的几乎没有，今天笔者实现用小程序码实现网站登陆，体验地址如下\r\nidea.techidea8.com/open/login.…\r\n思路\r\n\r\n关键流程\r\n建立场景sceneid和websocket的绑定关系\r\n获得sceneid\r\n场景ID可以前端生成，也可以后端生成，只需要保证sceneid的同一时间唯一性即可。\r\n前端生成可以采用随机数加时间戳的形式,也可以用uuid算法\r\n//时间戳\r\nvar sceneid =\"scend-\" +  new Data().getTime() + Math.ceil(Math.random()*888888+1000000);\r\n复制代码建立websocket\r\nvar ws = new WebSocket(\"ws://192.168.0.106/websocket?clientid=\"+sceneid )\r\nws.onopen=function(env){\r\n\tconsole.log(env)\r\n} \r\nws.onmessage=function(env){\r\n\tvar data = env.data;\r\n\t//这个data 就是后端发来的用户数据\r\n} \r\n\r\n复制代码后端建立websocket\r\n后端采用go语言github.com/gorilla/websocket包建立websocket.因为golang 非常适合高并发场景。\r\nfunc (ctrl *PushCtrl) websocket(w http.ResponseWriter, req *http.Request) {\r\n\r\n\t//fmt.Printf(\"%+v\",request.Header)\r\n\t//todo 检验接入是否合法\r\n\t//checkToken(userId int64,token string)\r\n\tquery := req.URL.Query()\r\n\tclientid := query.Get(\"clientid\")\r\n\r\n\tconn, err := (&websocket.Upgrader{\r\n\t\tCheckOrigin: func(r *http.Request) bool {\r\n\t\t\treturn true\r\n\t\t},\r\n\t}).Upgrade(w, req, nil)\r\n\r\n\tif err != nil {\r\n\t\tlog.Println(err.Error())\r\n\t\treturn\r\n\t}\r\n\r\n\tclientMap.Store(clientid, conn)\r\n\tgo func(clientId string, conn *websocket.Conn) {\r\n\t\t//处理出错信息\r\n\t\tdefer func() {\r\n\t\t\tconn.Close()\r\n\t\t\tclientMap.Delete(clientid)\r\n\t\t}()\r\n\t\tfor {\r\n\t\t\t_, _, err := conn.ReadMessage()\r\n\t\t\tif err != nil {\r\n\t\t\t\tlog.Println(err.Error())\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t}\r\n\t}(clientid, conn)\r\n}\r\n复制代码我们采用sync.map建立sceneid和websocket的对应关系\r\nclientMap.Save(sceneid,conn)\r\n复制代码对于因为异常断开的con我们需要移除\r\nclientMap.Delete(sceneid)\r\n复制代码获得小程序二维码\r\n获得小程序的accesstoken\r\n小程序access 请求接口如下\r\n``\r\n该接口日使用频率有限制，因此我们需要将这些数据缓存起来,缓存方案很多，有redis,也有内存，我们这里直接用一个变量即可存储\r\naccesstoken :=\"\"\r\nfunc GetAccessToken() string{\r\n\treturn accesstoken \r\n}\r\nfunc RefreshAccessToken()string{\r\n\turl = \"\"\r\n\tresp := httpget(url)\r\n\t//resp 是一个包含accesstoken的json字符串,我们解析这个json即可\r\n\taccesstoken = decodeaccesstokenfromjson(resp)\r\n\treturn accesstoken \r\n}\r\n复制代码我们还需要一个滴答计数器用来刷新accesstoken,accesstoken 的有效期是7200秒，我们4000秒刷新一次accesstoken 即可\r\nfunc refreshAccessToken(){\r\n\tticker := time.NewTicker(time.Second *4000)\r\n\tfor{\r\n\t\tselect {\r\n\t\t\tcase <-ticker.C:\r\n\t\t\t\tRefreshAccessToken()\r\n\t\t}\r\n\t}\r\n}\r\n复制代码在init.go 中的init方法中启动协程\r\ngo refreshAccessToken()\r\n复制代码小程序二维码编程技巧\r\n小程序二维码请求接口如下\r\nhttps://api.weixin.qq.com/wxa/getwxacodeunlimit?access_token=ACCESSTOKEN\r\n由于该链接会返回俩种结果\r\n错误返回Json\r\n{\r\n\"errcode\":400001,\r\n\"errmsg\":\"什么什么原因\"\r\n}\r\n复制代码正确返回j图片buffer\r\n这是一个二进制码流，因此我们需要对返回结果进行标准化处理\r\n我们建议一种标准化结果\r\n{\r\ncode:0,\r\ndata:\"\",\r\nmsg:\"结果说明\"\r\n}\r\n复制代码\r\n\r\n\r\n参数\r\n说明\r\n\r\n\r\n\r\n\r\ncode\r\n标识成功或者失败,200为成功,400为失败\r\n\r\n\r\ndata\r\n图片的base64格式编码\r\n\r\n\r\nmsg\r\n结果说明,或者出错提示\r\n\r\n\r\n\r\n代码示例如下\r\nurl := fmt.Sprintf(\"https://api.weixin.qq.com/wxa/getwxacodeunlimit?access_token=%s\", token)\r\nret, err := util.PostJSON(url, arg)\r\nif err != nil {\r\n\t\tutil.FailMsg(w, err.Error())\r\n\t\treturn\r\n}\r\n\r\njsonstr := string(ret)\r\nif strings.Contains(jsonstr, \"errmsg\") {\r\n\tutil.FailMsg(w, jsonstr)\r\n\treturn\r\n} else {\r\n\tbase64data := base64.StdEncoding.EncodeToString(ret)\r\n\tutil.RespOk(w, \"data:image/png;base64,\"+base64data)\r\n}\r\n复制代码其中util是笔者封装的常用工具包\r\n\r\n前端请求成功后获得data,可以利用$(\"#qrcode\").attr(\"src\",res.data)刷新图片二维码\r\nfunction refreshqrcode(){\r\n    clientId = \"scene-\"+new Date().getTime();\r\n    var api = restgo.buildapi(\"miniapp/getwxacodeunlimit\")\r\n    restgo.post(api,{\"scene\":clientId}).then(res=>{\r\n        if(res.code==200){\r\n            $(\"#qrcode\").attr(\"src\",res.data)\r\n        }else{\r\n            alert(res.msg)    \r\n        }\r\n        intiwebsocket()\r\n    },res=>{\r\n        alert(res.msg)\r\n    })\r\n}\r\n复制代码小程序处理关键点\r\n采用好的框架\r\n我们编程过程才用了uniapp，这个框架不错,完全是vue的语法，\r\n一套代码可以生成H5/小程序/android/ios\r\n我们采用了vue的watch特性,通过监听userid来确定是否发送信息\r\nwatch:{\r\n\t userid:function(a,b){\r\n\t\t\t\r\n\t\t\tif(a==0){\r\n\t\t\t\treturn \r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tthis.loaddata()\r\n\t\t\t//如果clientid是空的说明不是扫码进来的\t\r\n\t\t\tif(!this.clientid){\r\n\t\t\t\treturn \r\n\t\t\t}\r\n//如果是扫码进来的,那么我们还需要推送消息到服务器后端\r\nserver.PublishMsg(this.clientid,this.userid,this.role,this.avatarUrl,this.nickName).then(res=>{\r\n\t\t\t\ttip.error(res.msg)\r\n\t\t\t},res=>{\r\n\t\t\t\ttip.error(res.msg)\r\n\t\t\t})\r\n\t\t\t\r\n\t }\r\n  }\r\n复制代码获取sceneid\r\n我们通过onload方法获得sceneid\r\nonLoad(arg) {\r\n\t\tif(!!arg && !!arg.scene){\r\n\t\t\t\t\tthis.clientid = decodeURIComponent(arg.scene)\r\n\t\t}\r\n\t\t\t\t\r\n\t},\r\n复制代码核心代码如下\r\n通过gotUserInfo获得用户头像、昵称等,通过uni.login获得code\r\ngotUserInfo :function(e) {\r\n\t\t\t //获得用户头像、昵称、\r\n\t\t\t  uni.login(\r\n\t\t\t  {\r\n\t\t\t\t  success:(res) =>{\r\n\t\t\t\t\t        //通过wx.login获得code\r\n\t\t\t      \t\t\tuserInfo.code = res.code\r\n                                                //统一传递到后端      \r\n\t\t\t\t\t\tthis.authwithcode(userInfo)\r\n\t\t\t\t  }\r\n\t\t\t  }\r\n\t\t\t  )\r\n\t\t\t}\r\n\t\t  },\r\n\t\tauthwithcode:function(userInfo){\r\n                        //code获得openid在后端做,做了后继续去查User表\r\n\t\t\tserver.AuthWithCode(userInfo).then(res=>{\r\n\t\t\t\t\t//如果这个openid绑定了用户\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\tif(res.data.id>0){\r\n\t\t\t\t\t\t//这里res.data 就是user对象,可以继续操作\r\n\t\t\t\t\t\treturn ;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t//如果没有那么注册\r\n\t\t\t\t\tserver.RegisterWithOpenId(res.data.mini_openid,userInfo.avatarUrl,userInfo.nickName)#.then(res=>{\r\n\t\t\t\t\t\t//注册成功则返回\r\n\t\t\t\t\t\t//这里res.data 就是user对象可以继续操作\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t},res=>{\r\n\t\t\t\t\t\ttip.error(res.msg)\r\n\t\t\t\t\t})\r\n\t\t\t\t},res=>{\r\n\t\t\t\t\ttip.error(res.msg||\"\");\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t},\t\r\n复制代码体验地址\r\n本文所有应用体验地址如下\r\n互联网行业解决方案吧https://idea.techidea8.com/open/idea.shtml?id=5\r\n关于代码\r\n代码获得地址\r\n小程序码登陆\r\n代码配置\r\n请认真阅读readme.md"}
{"title": "微信小程序支持 webP 的 WebAssembly 方案 ", "author": "Rolan", "put_time": "2019-8-20 00:24", "content": "相信不少人听说过 WebAssembly，它是由 Google、Microsoft、Mozilla、Apple 等几家大公司合作发起的一个关于面向 Web 的通用二进制和文本格式的项目。本文我们将跟随作者一步步揭开 WebAssembly 的神秘面纱，并了解 WebAssembly 是如何应用在实际业务中的。引言实践检验真理，让我们一起动手将 WebAssembly 应用在微信小程序场景中，让微信小程序环境支持解码 webP 格式（不了解或没听过 webP 的各位同仁，请先移步到 “探究 WebP 的一些事儿” ）。WebAssembly 工作流程动手之前，让我们先来了解下如何加载和运行 WebAssembly 的代码：C / C++ / Rust / Java 等高级语言开发的代码或功能库 -> Emscripten 编译 -> wasm 文件 -> 结合 WebAssembly JS API -> 浏览器环境中运行，如下图所示：简单来说，编译前端 LLVM / Emscripten 流程可以获得 wasm 文件和胶水 js。然后，通过胶水 js 来加载 wasm 并转为 arrayBuffer 格式。紧接着进行编译和实例化后，即可用 JavaScript 与 WebAssembly 通信。详细过程以及每个过程调用的 API 如下图所示：浏览器环境支持 webP了解完 WebAssembly 的工作流程后，是不是还不清楚要从哪开始搞起？你可以去 github 官网上看一下 libwebp 开源项目 ，Google 已经完全支持把 libwebp 源码编译为 wasm 和 asm.js 两个版本了。针对不支持 WebAssembly 的系统或不兼容 WebAssembly 的浏览器，可以在损失一点性能的情况下降级为使用 asm.js。具体编译步骤如下图所示：待编译完之后，我们便可获得 wasm 文件和胶水 JS。然后，我们可以用“python -m SimpleHTTPServer 8080”启动一个本地服务，在浏览器地址栏输入 http://localhost:8080 后就能看到 webP 解码后的图片。最后，让我们来总结下整个流程。（1）用 LLVM / Emscripten / CMake 工具对 libwebp 解码库进行编译，获得 wasm 文件和胶水 JS。（2）胶水 JS 申请内存，对 wasm 文件进行编译、加载和实例化后，导出 Module 对象。（3）利用 Module 对象上的 WebpToSDL 方法对 webP 进行解码，并转成 Canvas 在浏览器渲染显示出来，呈现最终的图片。微信小程序环境支持 webP微信小程序在 Android / iOS 上用于执行脚本以及渲染组件的环境都不尽相同。在 Android 上，微信小程序逻辑层的 JavaScript 代码运行在 V8 中，视图层是由自研 XWeb 引擎基于 Mobile Chrome 67 内核来渲染，天然支持 webP 格式；在 iOS 上，微信小程序逻辑层的 JavaScript 代码运行在 JavaScriptCore 中，视图层是由 WKWebView 来渲染，宿主 Safari 浏览器内核不支持 webP 格式。通过第 3 节内容，我们知道浏览器环境已经能够支持 webP 了，那直接把之前编译好的 wasm 文件和胶水 JS 扔进微信小程序的运行环境，然后跑起来不就搞定了？Too young too simple!浏览器环境支持 webP 的思路是 libwebp 解码 webP -> jpg / png / gif 的 canvas 图片渲染显示，这已经改变了原来 image 组件的结构。而微信小程序提供给开发者的组件不允许去改变它原来的结构，因此换种思路是 libwebp 解码 webP -> jpg / png / gif 的 rgb data -> jpg / png / gif base64 -> 回传给 JS 并赋值给 image src 进行渲染显示。下面我罗列下从 libwebp 编译 wasm 文件和胶水 JS 开始，直到在微信小程序环境跑通为止，整个过程中遇到的一些坑点和优化点：（1）编译 CMakeLists.txt 时需加上“-O3”选项，大大提升编译速度。（2）编译 CMakeLists.txt 时需加上“-s USE_PTHREADS=0”选项，因为 iOS Safari 浏览器不兼容 ShareArrayBuffer 共享缓冲区。（3）编译 CMakeLists.txt 时需加上“-s ALLOW_MEMORY_GROWTH=1”选项，目的是为了解决解码超大分辨率的 webP 图片时出现的 OOM 问题。（4）由于微信小程序环境的兼容性问题，去除胶水 JS 代码中 libwebp 编译时加上的 SDL 相关代码，能节省 100KB 左右的空间。（5）去除胶水 JS 中 ENVIRONMENT_IS_NODE / ENVIRONMENT_IS_SHELL 相关的代码，因为微信小程序环境并未使用到。（6）由于 iOS Safari 浏览器的兼容性问题，将胶水 JS 中流式编译和实例化的方法去掉，替换成非流式编译和实例化的方法。（7）由于 WebAssembly 还没有和 <script type='module'> 或 ES6 的 import 语句集成，因此将 wasm 文件先转成 base64 字符串。等胶水 JS 运行加载逻辑时，再将 base64 转成 ArrayBuffer 并编译和实例化后导出 Module 对象，节省从服务器下载 wasm 文件的时间。（8）编译 CMakeLists.txt 时需加上“-s USE_LIBPNG=1”选项编译 libpng.a 库，然后将 webP 解码获得的 rgb 数据，通过 png 解码库转成 png 内存数据，紧接着转成 base64 回传给 JS，最后赋值给 image src 进行渲染显示。难点是 rgb 转成 png 内存数据这一步出了点问题，但是 wasm 无法调试代码，只能通过搭建 libpng 的 VS 工程进行断点调试，最终定位到是 rgb 转 png data 时传入的 data_size 为 0 导致。（9）胶水 JS 里的 new WebAssembly.Memory 代码在微信小程序环境运行时，会报“refused to create a webassembly object without ‘unsafe-eval’”的错误，必须在 page-frame.html 里的 CSP 设置里加上 unsafe-eval 才能解决。踩了这么多坑之后，终于能在微信小程序环境里支持 webP 了。实测 WebAssembly 在解码不同格式不同分辨率的 webP 时，性能都完胜 JavaScript。写在最后虽然 WebAssembly 的解码性能比 JavaScript 快不少，但遇到超大分辨率（如 1920 x 1080 等）的 webP 时，却远远落后于客户端的解码性能。综合对比各种方案的性能和兼容性之后，我们还是采用了基于 iOS 客户端自定义协议 webphttps 的方案，大致步骤如下：（1）首先，微信小程序基础库判断开发者在 image 组件使用的是 webP 格式时，则在 image src 里加上 webp 头部如 webphttps://example.png。（2）然后，客户端通过 NSURLProtocol 协议挟持 webphttps 的请求，并下载相应的 webP 数据进行解码。（3）最后，再把解码后的 image 数据回吐给浏览器进行渲染显示。到最后，我们完成了微信小程序环境支持 webP 的方案落地。"}
{"title": "微信小程序 webview 与 h5 实时通讯的实现 ", "author": "Rolan", "put_time": "2019-8-21 00:07", "content": "在做 React Native 应用时，如果需要在 App 里面内嵌 H5 页面，那么 H5 与 App 之间可以通过 Webview 的 PostMessage 功能实现实时的通讯，但是在小程序里面，虽然也提供了一个\twebview 组件，但是，在进行\tpostMessage 通讯时，官方文档里面给出了一条很变态的说明：网页向小程序\tpostMessage 时，会在特定时机（小程序后退、组件销毁、分享）触发并收到消息。\te.detail = { data } ，\tdata 是多次\tpostMessage 的参数组成的数组这里面已经说的很明白了，不管我们从 H5 页面里面\tpostMessage 多少次，小程序都是收不到的，除非：用户做了回退到上一页的操作组件销毁用户点击了分享这里面其实我没有完全说对，官方其实说的是\t小程序后退 ，并没有说是用户做回退操作，经过我的实测，确实人家表达得很清楚了，我们通过微信官方的SDK调起的回退也是完全可行的：wx.miniProgram.navigateBack()大体思路从上面的分析和实测中我们可以知道，要实现无需要用户操作即可完成的通讯，第三种情况我们是完全不需要考虑了的，那么来仔细考虑第 1 和第 2 种场景。第 1 种方式：回退当我们想通过网页向小程序发送数据，同时还可以回退到上一个页面时，我们可以在\twx.miniProgram.postMessage 之后，立马调用一次\twx.miniProgram.navigateBack() ，此时小程序的操作是：postMessage\r\n我们在处理\tpostMessage 的时候做一些特殊操作，可以将这些数据保存下来第 2 种方式：组件销毁这是我感觉最合适的一种方式，可以让小程序拿到数据，同时还保留在当前页面，只需要销毁一次\twebview 即可，大概的流程就是：小程序\tpostMessage小程序\tnavigateTo 将小程序页面导向一个特殊的页面小程序的那个特殊页面立马回退到\twebview 所在的页面webview 所在的页面的\tonShow 里面，做一次处理，将\twebview 销毁，然后再次打开触发\tonMessage 拿到数据H5 页面再次被打开这种方式虽然变态，但是至少可以做到实时拿到数据，同时还保留在当前 H5 页面，唯一需要解决的是，在做这整套操作前，H5 页面需要做好状态的缓存，要不然，再次打开之后，H5 的数据就清空了。第 1 种方式：通过回退，将数据提交给小程序之后传递给\twebview 的上一页面这种方式实现起来其实是很简单的，我们现在新建两个页面：sandbox/canvas-by-webapp/index.jsconst app = getApp();\r\n\r\nPage({\r\n  data: {\r\n    url: '',\r\n    dimension: null,\r\n    mime: '',\r\n  },\r\n  handleSaveTap: function() {\r\n    wx.navigateTo({\r\n      url: '/apps/browser/index',\r\n      events: {\r\n        receiveData: data => {\r\n          console.log('receiveData from web browser: ', data);\r\n          if (typeof data === 'object') {\r\n            const { url, mime, dimension } = data;\r\n            if (url && mime && dimension) {\r\n              this.setData({\r\n                url,\r\n                dimension,\r\n                mime,\r\n              });\r\n\r\n              this.save(data);\r\n            }\r\n          }\r\n        }\r\n      }\r\n    })\r\n  },\r\n\r\n  save: async function({ url, mime, dimension }) {\r\n    try {\r\n      await app.saveImages([url]);\r\n      app.toast('保存成功！');\r\n    } catch (error) {\r\n      console.log(error);\r\n      app.toast(error.message || error);\r\n    }\r\n  },\r\n});上面的代码中，核心点，就在于\twx.navigateTo 调用时，里面的\tevents 参数，这是用来进行与\t/apps/browser/index 页面通讯，接收数据用的。apps/browser/index.js我省略了绝大多数与本文无关的代码，保存最主要的三个：Page({\r\n  onLoad() {\r\n    if (this.getOpenerEventChannel) {\r\n      this.eventChannel = this.getOpenerEventChannel();\r\n    }\r\n  },\r\n  handleMessage: function(message) {\r\n    const { action, data } = message;\r\n    if (action === 'postData') {\r\n      if (this.eventChannel) {\r\n        this.eventChannel.emit('receiveData', data);\r\n      }\r\n    }\r\n  },\r\n\r\n  handlePostMessage: function(e) {\r\n    const { data } = e.detail;\r\n    if (Array.isArray(data)) {\r\n      const messages = data.map(item => {\r\n        try {\r\n          const object = JSON.parse(item);\r\n          this.handleMessage(object);\r\n          return object;\r\n        } catch (error) {\r\n          return item;\r\n        }\r\n      });\r\n\r\n      this.setData({\r\n        messages: [...messages],\r\n      });\r\n    }\r\n  },\r\n})其实，\tonLoad 方法中，我们使用了自微信 SDK\t2.7.3 版本开始提供的\tgetOpenerEventChannel 方法，它可以创建一个与上一个页面的事件通讯通道，这个我们会在\thandleMessage 中使用。handlePostMessage 就是被\tbindmessage 至\twebview 上面的方法，它用于处理从 H5 页面中\tpostMessage 过来的消息，由于小程序是将多次\tpostMessage 的消息放在一起发送过来的，所以，与其它的Webview不同点在于，我们拿到的是一个数组：\te.detail.data ，\thandlePostMessage的作用就是遍历这个数组，取出每一条消息，然后交由\thandleMessage 处理。handleMessage 在拿到\tmessage 对象之后，将\tmessage.action 与\tmessage.data 取出来（*这里需要注意，这是我们在 H5 里面的设计的一种数据结构，你完全可以在自己的项目中设计自己的结构），根据\taction 作不同的操作，我在这里面的处理是，当\taction === 'postData' 时，就通过\tgetOpenerEventChannel 得到的消息通道\tthis.eventChannel 将数据推送给上一级页面，也就是\t/sandbox/canvas-by-webapp ，但是不需要自己执行\tnavigateBack ，因为这个需要交由H5 页面去执行。H5 页面的实现我的 H5 主要就是使用\thtml2canvas 库生成 Canvas 图（没办法，自己在小程序里面画太麻烦了），但是这个不在本文讨论过程中，我们就当是已经生成了\tcanvas 图片了，将其转为\tbase64文本了，然后像下面这样做：wx.miniProgram.postMessage({\r\n  data: JSON.stringify({\r\n    action: 'postData',\r\n    data: 'BASE 64 IMAGE STRING'\r\n  })\r\n});\r\n\r\nwx.miniProgram.navigateBack()将数据\tpostMessage 之后，立即\tnavigateBack() ，来触发一次回退，也就触发了\tbindmessage 事件。使用销毁\twebview 实现实时通讯接下来，咱就开始本文的重点了，比较变态的方式，但是也没想到更好的办法，所以，大家将就着交流吧。"}
{"title": "微信小程序WebSocket实践 ", "author": "Rolan", "put_time": "2019-6-5 00:23", "content": "微信基础库1.7.0之后的版本提供了新版的WebSocket API，考虑到兼容性问题，尝试整合新旧两种版本的API，进行简单的封装。从以下几个角度对微信小程序中所提供的WebSocket API封装API兼容性重连机制小程序WebSocket API旧版WebSocket API的使用创建 - wx.connectSocket发送消息 - sendSocketMessage监听事件 - onSocketOpenlet socketOpen = false\r\nconst socketMsgQueue = []\r\n// 连接socket\r\nwx.connectSocket({\r\n  url: 'test.php'\r\n})\r\n// 监听打开事件\r\nwx.onSocketOpen(function(res) {\r\n  socketOpen = true\r\n  for (let i = 0; i < socketMsgQueue.length; i++){\r\n    sendSocketMessage(socketMsgQueue[i])\r\n  }\r\n  socketMsgQueue = []\r\n})\r\n// 发送消息\r\nfunction sendSocketMessage(msg) {\r\n  if (socketOpen) {\r\n    wx.sendSocketMessage({\r\n      data:msg\r\n    })\r\n  } else {\r\n    socketMsgQueue.push(msg)\r\n  }\r\n}新版WebSocket API的使用支持1.7.0+，连接后会返回一个SocketTask对象，在该对象上监听该连接的各种事件与执行发送消息等操作。let socketTask = wx.connectSocket({\r\n  url: 'test.php'\r\n})\r\n// 监听打开事件\r\nsocketTask.onOpen(function(res) {\r\n  socketOpen = true\r\n  // 发送信息\r\n  socketTask.send({msg: \"hello world\"})\r\n})并发数1.7.0 及以上版本，最多可以同时存在\t5 个\tWebSocket 连接。1.7.0 以下版本，一个小程序同时只能有一个\tWebSocket 连接，如果当前已存在一个 WebSocket 连接，会自动关闭该连接，并重新创建一个\tWebSocket 连接。模块封装简单封装封装一个兼容新旧socketAPI的模块，仅考虑存在单个socket连接的情况创建与事件监听新版: 在socket连接时会返回一个socketTask对象，监听事件是在该对象的基础上进行旧版: 直接使用wx放进行创建与监听方法统一创建与添加监听函数init() {\r\n  let st = this.connect()\r\n  this.listen(st)\r\n  this.manualClose = false\r\n}创建连接connect() {\r\n  let st = wx.connectSocket(this.config.server)\r\n  return st\r\n}添加事件监听函数listen(st) {\r\n  if (st !== undefined) {\r\n    this.ws = st\r\n    this.ws.onOpen(() => this.openHandle())\r\n    this.ws.onError(() => this.errorHandle())\r\n    this.ws.onClose(() => this.closeHandle())\r\n    this.ws.onMessage(res => this.messageHandle(res))\r\n  } else {\r\n    wx.onSocketOpen(() => this.openHandle())\r\n    wx.onSocketError(() => this.errorHandle())\r\n    wx.onSocketClose(() => this.closeHandle())\r\n    wx.onSocketMessage(res => this.messageHandle(res))\r\n  }\r\n}重连机制预设标记位retryLock = false; // 避免多次同时重连\r\nsocketOpen = false; // 连接状态\r\nmanualClose = false; // 主动断开标记在连接关闭监听函数中执行重连closeHandle() {\r\n  console.info('WebSocket closed')\r\n  this.socketOpen = false\r\n  this.retryLock = false\r\n  // 不论是error还是close都会触发close事件，统一在这里进行重连\r\n  // 初次连接失败不进行重连(失败不会进入到onOpen的监听事件中，那时未声明retryTimes变量)\r\n  this.retryTimes !== undefined && this.reconnect()\r\n}判断重连锁与是否主动断开进行重连reconnect() {\r\n  if (this.retryLock) return\r\n  this.retryLock = true\r\n  // 若manualClose为true，表明不是主动断开\r\n  if (!this.manualClose) {\r\n    // 开始重连\r\n    setTimeout(() => {\r\n      this.retry()\r\n    }, this.retryInterval)\r\n  }\r\n}重连函数，包含重连次数的限制retry() {\r\n  if (\r\n    this.socketOpen ||\r\n    (this.retryTimes > 0 && this.retryCount <= this.retryTimes)\r\n  ) {\r\n    console.warn(`reconnect ending. reconnect ${this.retryTimes} times`)\r\n    if (!this.socketOpen) {\r\n      this.config.closeCallback()\r\n    }\r\n    return\r\n  }\r\n  this.retryTimes += 1\r\n  console.warn(`[ ${this.retryTimes} ]th reconnect WebSocket...`)\r\n  this.init()\r\n}消息队列添加消息队列，当重连后自动发送缓存消息openHandle() {\r\n  this.retryTimes = 0\r\n  this.socketOpen = true\r\n  this.retryLock = false\r\n\r\n  this.messageQueue.map(e => this.send(e))\r\n  this.messageQueue = []\r\n}若发送时断开则先将消息缓存到消息队列中send(value) {\r\n  let data = this.msgWrapper(value)\r\n  data = JSON.stringify(data)\r\n  if (!this.socketOpen) {\r\n    this.messageQueue.push(data)\r\n  } else {\r\n    if (this.ws) {\r\n      this.ws.send({ data })\r\n    } else {\r\n      wx.sendSocketMessage({ data })\r\n    }\r\n  }\r\n}辅助函数添加一些包裹消息格式的工具函数messageIndex = 0;\r\nhelper = {\r\n  isPlainObject: val =>\r\n    Object.prototype.toString.call(val) === '[object Object]',\r\n  nextId: () => {\r\n    this.messageIndex += 1\r\n    return this.messageIndex\r\n  },\r\n  id: () => Date.now() + '.' + this.helper.nextId()\r\n};\r\nmsgWrapper(data) {\r\n  let msg = data\r\n  if (this.helper.isPlainObject(msg)) {\r\n    if (msg.type) {\r\n      return msg\r\n    } else {\r\n      return this.msgWrapper({ type: 'message', msg, id: this.helper.id() })\r\n    }\r\n  } else {\r\n    return this.msgWrapper({ type: 'message', msg, id: this.helper.id() })\r\n  }\r\n}完整代码export default class WXWebSocket {\r\n  messageQueue = []; // 消息队列\r\n  retryLock = false; // 避免多次同时重连\r\n  socketOpen = false;\r\n  manualClose = false; // 主动断开标记\r\n  constructor(config) {\r\n    this.config = config || {}\r\n    // 重连间隔\r\n    this.retryInterval =\r\n      this.config.retryInterval && this.config.retryInterval > 100\r\n        ? this.config.retryInterval\r\n        : 3000\r\n    // 重连次数\r\n    this.retryCount = this.config.retryCount || 5\r\n    this.init()\r\n  }\r\n  init() {\r\n    let st = this.connect()\r\n    this.listen(st)\r\n    this.manualClose = false\r\n  }\r\n  connect() {\r\n    let st = wx.connectSocket(this.config.server)\r\n    console.log('current socket: ', st)\r\n    return st\r\n  }\r\n  listen(st) {\r\n    // 添加监听事件\r\n    if (st !== undefined) {\r\n      // 若存在SocketTask，则要通过readyState判断状态\r\n      // CONNECTING: 0\r\n      // OPEN: 1\r\n      // CLOSING: 2\r\n      // CLOSE: 3\r\n      this.ws = st\r\n      this.ws.onOpen(() => this.openHandle())\r\n      this.ws.onError(() => this.errorHandle())\r\n      this.ws.onClose(() => this.closeHandle())\r\n      this.ws.onMessage(res => this.messageHandle(res))\r\n    } else {\r\n      wx.onSocketOpen(() => this.openHandle())\r\n      wx.onSocketError(() => this.errorHandle())\r\n      wx.onSocketClose(() => this.closeHandle())\r\n      wx.onSocketMessage(res => this.messageHandle(res))\r\n    }\r\n  }\r\n  close() {\r\n    this.manualClose = true\r\n    if (this.ws) {\r\n      this.ws.close()\r\n    } else {\r\n      wx.closeSocket()\r\n    }\r\n  }\r\n  send(value) {\r\n    console.log('send value: ', value)\r\n    let data = this.msgWrapper(value)\r\n    data = JSON.stringify(data)\r\n    if (!this.socketOpen) {\r\n      // add new message to queue\r\n      this.messageQueue.push(data)\r\n    } else {\r\n      if (this.ws) {\r\n        this.ws.send({ data })\r\n      } else {\r\n        wx.sendSocketMessage({ data })\r\n      }\r\n    }\r\n  }\r\n  openHandle() {\r\n    console.info('WebSocket connected')\r\n    this.retryTimes = 0\r\n    this.socketOpen = true\r\n    this.retryLock = false\r\n\r\n    this.messageQueue.map(e => this.send(e))\r\n    this.messageQueue = []\r\n  }\r\n  errorHandle() {\r\n    console.error('WebSocket error')\r\n    this.socketOpen = false\r\n  }\r\n  closeHandle() {\r\n    console.info('WebSocket closed')\r\n    this.socketOpen = false\r\n    this.retryLock = false\r\n    // 不论是error还是close都会触发close事件，统一在这里进行重连\r\n    // 初次连接失败不进行重连(失败不会进入到onOpen的监听事件中，那时未声明retryTimes变量)\r\n    this.retryTimes !== undefined && this.reconnect()\r\n  }\r\n  reconnect() {\r\n    if (this.retryLock) return\r\n    this.retryLock = true\r\n    // 若manualClose为true，表明不是主动断开\r\n    if (!this.manualClose) {\r\n      // 开始重连\r\n      setTimeout(() => {\r\n        this.retry()\r\n      }, this.retryInterval)\r\n    }\r\n  }\r\n  retry() {\r\n    if (\r\n      this.socketOpen ||\r\n      (this.retryTimes > 0 && this.retryCount <= this.retryTimes)\r\n    ) {\r\n      console.warn(`end reconnect. reconnect ${this.retryTimes} times`)\r\n      if (!this.socketOpen) {\r\n        this.config.closeCallback()\r\n      }\r\n      return\r\n    }\r\n    this.retryTimes += 1\r\n    console.warn(`[ ${this.retryTimes} ]th reconnect WebSocket...`)\r\n    this.init()\r\n  }\r\n  messageHandle(res) {\r\n    this.config.responseCallback(res)\r\n  }\r\n  msgWrapper(data) {\r\n    let msg = data\r\n    if (this.helper.isPlainObject(msg)) {\r\n      if (msg.type) {\r\n        return msg\r\n      } else {\r\n        return this.msgWrapper({ type: 'message', msg, id: this.helper.id() })\r\n      }\r\n    } else {\r\n      return this.msgWrapper({ type: 'message', msg, id: this.helper.id() })\r\n    }\r\n  }\r\n  messageIndex = 0;\r\n  helper = {\r\n    isPlainObject: val =>\r\n      Object.prototype.toString.call(val) === '[object Object]',\r\n    nextId: () => {\r\n      this.messageIndex += 1\r\n      return this.messageIndex\r\n    },\r\n    id: () => Date.now() + '.' + this.helper.nextId()\r\n  };\r\n}使用创建连接let socketTask = new WXWebSocket({\r\n  server: this.wsServerOption,\r\n  responseCallback: e => {\r\n    let { data } = e\r\n    let { msg } = JSON.parse(data)\r\n    this.msgStack.push(msg)\r\n  },\r\n  closeCallback: () => {\r\n    this.socketTask = null\r\n  }\r\n})\r\nthis.socketTask = socketTask发送消息sendWSMessage(msg) {\r\n  this.msgStack.push(msg)\r\n  this.socketTask && this.socketTask.send(msg)\r\n},关闭连接closeWS() {\r\n  if (!this.socketTask) return\r\n  if (this.socketTask.socketOpen) {\r\n    this.socketTask.close()\r\n    this.socketTask = null\r\n  }\r\n}"}
{"title": "微信小程序上传文件小结 ", "author": "Rolan", "put_time": "2019-6-11 00:09", "content": "前言后端用的是\tRails ActiveStorage direct_upload 的处理方式, 前端被要求：MD5-Base64\r\nsigned_id\r\n相关知识因为目前开发任务重且紧，暂时略过此部分，只记录结论要点，后续有时间再补充相关知识要点小结3.0 上传文件（后端 Rails: activeStorage）Step 1: 计算文件MD5-Base64摘要小程序中前端无法获取文件的Binary格式 ，因此无法自行或使用第三方库来计算文件的\tMD5值，但幸运的是，小程序也提供了API来做这件事，请使用：\twx.getFileInfo将获得的\tMD5 值转为\tBase64 格式。可使用此项目中\tutils/base64.js 的\tencode 方法，该方法适用于转换字符串。也可使用\tCryptoJS 库，需要注意的是，\tCryptoJS.enc.Base64.stringify 需要的参数是\tWordArray 格式，不能直接传\tString ，要先用\tCryptoJS.enc.Utf8.parse 转换一下字符串Step 2: 上传文件到上一步返回的指定\tdirect_upload 地址小程序前端无法直接获得文件的\tBinary 格式传给后端，但可以通过\twx.uploadFile 上传文件，通过此接口发送请求，后端可获取到文件\tBinary 格式后端提供的上传文件接口需符合\twx.uploadFile 的要求，即\t请求方式为\tPOST , 并指定所需文件\tkey 名（而不是直接要求把\tBinary 文件丢在请求\tbody 中）"}
{"title": "当微信小程序遇上TensorFlow - tensorflow.js篇 ", "author": "Rolan", "put_time": "2019-6-11 00:24", "content": "在上一篇推送《 重磅好消息！TensorFlow开始支持微信小程序 》中，介绍了TensorFlow开始支持微信小程序平台，并计划将我之前开发的人工智能微信小程序 识狗君 使用tensorflow js改写。这个端午节，趁着放假，空余时间比较多，开始研究微信小程序中如何使用tensorflow.js。在写下上一篇推送后，我简单尝试过在微信小程序中使用tensorflow.js，发现直接使用还是存在一点问题，所以本次的目标是走通简单的流程：加载预训练模型mobilenet，可以用来识别图片所属分类。示例代码位于: https://github.com/mogoweb/aidog请切换到tfjs分支。运行起来，效果是这样的：嗯，示例是简单了一点，但所有使用tensorflow js的关键步骤都包括。下面就简要描述一下我所遇到的坑及解决之道：loadLayersModel无法加载模型使用tfjs定义模型，训练模型并进行预测都没问题，但是使用 loadLayersModel 加载预训练模型，却出现如下错误：Uncaught (in promise) Error: Unable to find the fetch() method. Please add your own fetch() function to the global namespace.为什么会出现这个问题呢，原来tfjs-core为了可移植性，平台相关的操作，由各平台自行实现。从网络上获取数据就是这样的平台相关操作，浏览器、Node各有自己的实现方法。浏览器的实现依赖于fetch API，而微信小程序上，非常遗憾的看到了一条更新日志：微信小程序中，网络请求可以通过 wx.request 实现，问题是如何实现全局的fetch函数呢？这可难倒了我。在网上搜索的时候，发现了一个项目：https://github.com/HunterXuan/wx-tfjs-core.git\r\n原来这哥们早就研究过将tfjs移植倒微信小程序平台，写了几篇博客，值得看一看。参考了他的修改，我也完成了tfjs-core的改造，参考我在GitHub上建的项目:https://github.com/mogoweb/wechat-tfjs-core.git\r\n我的修改有点不同，新定义了PlatformMP，主要是考虑到微信小程序和普通浏览器还有一些差异，以后存在差异的代码都放到PlatformMP里面实现。是不是还有更好的方法，比如不需要修改tfjs的代码，在微信小程序里面实现全局fetch函数？我不太确定，希望前端高手指点。预训练模型被墙由于一些众所周知的原因，访问Google的服务总是不顺畅。我长期挂VPN，这倒不是问题。关键是，如果在微信小程序中访问Google，这就有些麻烦，不可能期望用户能够个个玩转VPN。幸运的是，tfjs上有一个issue： Model accessibility issues in China #1375 。里面给出了临时解决方案，我们可以通过镜像：https://cnpmjs.org/mirrors/tfjs-models/ 获取模型。这个镜像能够存在多久还是个未知数，可能最靠谱的还是将模型同步下来，自己存储。这种方式还没有来得及研究，有时间再看看。获取图像数据在tfjs-examples中，是通过： tf.browser.fromPixels 接口获取图像数据，但在微信小程序中却行不通，因为微信小程序平台中移除掉了document对象。好在以前在开发 识狗君 微信小程序识研究过通过wx canvas获取图像数据，具体实现请参考源码。有一点需要注意，通过canvas获取到的图像数据是RGBA格式，而mobilenet模型接收的却是RGB，为此我写了一个转换函数：// RGBA to RGB\r\nvar rgbData = new Uint8Array(res.width * res.height * 3);\r\nlet idx = 0;\r\nfor (let i = 0; i < res.data.length; i +=4) {\r\n  rgbData[idx] = res.data[i];\r\n  rgbData[idx + 1] = res.data[i + 1];\r\n  rgbData[idx + 2] = res.data[i + 2];\r\n  idx += 3;\r\n}感觉这个函数实现得效率有些低，是否有更好的方法，还请高手指教。async / await作为一名浏览器内核开发人员，平常也接触一些js代码，但前端发展实在太迅猛了，好些新式的js代码已经完全看不懂。比如在 tfjs-examples 代码中，就有许多async / await等用法，模块导出也有好几种方式，Promise又是什么鬼？搞的我头晕脑胀，多亏了知识搜索能力还不错，遇到问题就Google，每次都能逢凶化吉。要在微信小程序中使用async / await，需要打开项目配置的增强编译开关：待完善问题模型每次都需要从网络加载，需要研究如何利用微信小程序的storage，这样模型可以缓存到本地，避免每次从网络加载。由于微信小程序包有大小限制，所以将模型打包到小程序不可能。将自己的模型转化为tfjs模型，并在微信小程序中使用。不修改tfjs-core，将平台相关代码放到微信小程序中实现。你还可以看：当微信小程序遇上TensorFlow：Server端实现当微信小程序遇上TensorFlow：Server端实现补充当微信小程序遇上TensorFlow：小程序实现当微信小程序遇上TensorFlow：接收base64编码图像数据当微信小程序遇上TensorFlow：终章识狗君微信小程序的部署"}
{"title": "细数百度小程序踩的坑 ", "author": "Rolan", "put_time": "2019-6-11 00:32", "content": "最近接触百度小程序挺多，开发了几个产品，都快被百度的小程序折磨死。真的是不想吐槽了，接下来我就讲讲我遇到的坑与一些经验。1. s-for这个for循环的写法为 s-for='arr' 或者 s-for = 'item,index in arr' 。这些到没什么，主要是s-for不能循环常数。。。这让我从微信小程序转到百度小程序不太习惯。。。官方回应说什么底层diff差异哦，后面会修复。不知道现在修复好没。2. 自定义组件之命名与路径引用组件的时候，在json文件中，usingComponents 选项里填入要引入的组件并自定义名称：\"my-radio\":\"/components/bd-radio/bd-radio\"。需要注意的是：这个组件的名称不支持驼峰和大写写法。路径支持绝对路径和相对路径。3. 自定义组件之组件通讯子组件 this.triggerEvent('getchange', idx); 触发事件，getchange是父组件需要接收的事件名，第二个参数是需要传回去的数据，最好是object，其它的参数，在2.0.3之前不支持。父组件 <my-radio bindgetchange='getSex'></my-radio> bindgetchange bind后面的就是子组件传过来的事件名，再后面一个(getSex)就是父组件中定义的函数，接收的时候e.detail，就是自组件传过来的数据4. 获取索引值如果要获取s-for中当前点击元素的索引值，只有在元素上添加 data-idx='{{index}}' 自定义属性，然后点击事件里面，通过：e.currentTarget.dataset.idx 获取。5. swan.request百度小程序的 swan.request 只支持 https协议。如果你不小心接口弄成了HTTP协议的url，在开发者工具上完全没问题，但是真机调试的话，如果你运气好，就没问题，运气不好在某些手机上就会出现接口无反应的情况，并且swan.request 的fail打印出： illegal request 非法请求。但是又没报错。所以，这个情况的提示也是不明显的，谁知道那个非法请求是接口还是url地址的错啊。还有就是百度好像并没有对这个接口中的url进行encodeURIComponent，所以如果有中文，那自己需要进行编码一次。6. swan.setStorageSyncswan.setStorageSync 这个同步的存储数据接口，官方文档说：参数支持String key, Object/String data。我第一次使用这个接口的时候，没注意看参数，结果传了一个布尔值进去，但是使用swan.getStorageSync获取的时候，始终获取不了，结果发现数据最外层包了一个data属性。即正常是xxx:true，实际上取出来是 data:{xxx:true} 也是醉了。。。不支持的至少给个错误提示啊。。。7. rich-text使用rich-text富文本组件的时候<rich-text node=\"{{a.b}}\"></rich-text>\r\n//如果a是后台取的，在js的data中初始化的时候，如果a设置为null，有可能会报错，导致页面复制相同的内容，即出现两个相同的内容连在一起。所以最好设置为 {} 空对象。而且如果遇到识别不了的标签会停止渲染，并且不会有错误提示。。。我遇到过几次出现两个相同的内容连在一起的情况，忘了截图的，具体怎样出现的也忘了。。。8. image 组件出现 image load faild如果遇到某些时候图片路径是正确的，但是出现 image load faild 这个错误，我也不知道怎么解决。官方回答说不影响开发就行。。。特别是从一个页面navgitor或者其它的跳转方式跳转到另外的页面，就有可能会出现这种情况。而且图片还是本地的。。。官方回复说：image图片地址只支持https协议，并且在小程序后台进行域名配置，或者百度域名的图片，不满足条件的话，图片将无法正常显示。不过有时候还是会出现上面的问题。9. H5支付 转到 百度支付 swan.requestPolymerPayment关于百度小程序支付：最开始我天真的以为，web-view嵌套一个已经完善的H5商城，支付的时候也可以直接使用自己对接的H5的支付。因为在本地预览时，不管安卓还是IOS，都可以支付成功，没问题。但是只要一发布上线，支付的时候就调不起微信或者支付宝的支付弹窗了。都不能跳转到支付弹窗的页面。安卓机全部不得行，IOS没问题。抓包发现结果返回正常，没有错误。我估计是百度官方屏蔽了。官方给出的回答是：为保护用户的资金安全，小程序的web-view不支持自行调用第三方支付服务。如有支付需求，建议接入百度收银台。。。但是，但是，但是。。。我看到苏宁易购的百度小程序就是使用的自己对接的第三方支付，并没有使用百度的支付接口。。。我就很奇怪了，为撒子苏宁易购就可以？？？10. web-view的src也可以使用localhostweb-view的src也可以弄成IP地址的情况。比如我本地使用vue-cli运行了一个项目，假设为http://localhost:8087/szxgcs/detail.html。这时我把localhost改成自己的IP地址，然后在web-view的src中：<web-view src='http://192.168.xxx.xxx:8087/szxgcs/detail.html'></web-view>\r\n//这样就能运行在本地的代码了 11. 使用未申明的变量，有可能会没错误提示有时候在某些接口中，或者request的data中，使用that.data.xxx的时候，由于我粗心，that没有声明。所以在运行的时候，发现调接口没反应。但是又没有提示哪里有错，就很懵逼。所以一定要检查某些变量是否声明的。不过现在好像改好了，不声明会报错了。12. swan.setPageInfo接入百度信息流接入百度信息流的申请，就是在页面配置swan.setPageInfo，如果小程序首页是web-view嵌套的页面，不是百度小程序原生开发的页面。那么就会申请不了。现在默认都是接入了百度信息流的，所以如果没配置，会出现让你配置的警告信息。建议代码写成swan.setPageInfo && swan.setPageInfo({配置内容}) ，如果不这样写，按照官方的写法，在真机调试中，会报错。13. 发布审核时设置基础库版本高一点。建议发布审核的时候，把开发者平台 --- 设置 --- 基本设置 --- 基础库最低版本设置 设置高一点。低版本出现了问题，如果是百度的问题，官方是不会给你修复的，这是官方技术人员回复我的原话。一般设置3.xxx以上就可以了，3.xxx以前的没多少用户了。这样也可以避免审核的时候测试人员在低版本测试，出现不清楚原因的bug。14. s-if不能和s-for一起用。有可能出现不可预知的错误。还有就是 s-if 一定要写在最前面，不然有可能也会出现一些小问题。。。.假如需要给组件传递内容，这个内容是异步获取的，那么在组件里，获取的时候，有可能会遇到获取不到传过来的内容，这个很正常。在H5的vue中，我使用v-if来避免获取不了的情况。类似：</ child :sendval='data' v-if='data' >\r\n//data初始化为false，这样，只有在data真实获取到内容的时候，才渲染组件。\r\n//但是，在百度小程序中，判断条件必须写在前面即：\r\n<child  s-if='data' :sendval='data' ></child>\r\n//不然，还是会出现获取不了内容的情况 15. swan.createSelectorQuery() 有时需要延时获取宽高等信息。swan.createSelectorQuery()这个获取dom元素的接口，如果获取的dom元素是动态添加的，那么，在调用boundingClientRect获取宽高等信息的时候，是需要延时获取的。这个在组件中更明显，就算组件加了s-if，在数据成功返回之后再渲染组件，但是渲染的过程也需要耗时，所以，不能及时地获取到元素的信息。就算使用swan.nextTick()也没作用，有时候也会获取不到。我设置setTimeout延时一般是150ms16. swan.nextTick()swan.nextTick()就是提供一个异步操作。从来就没用过，官方的描述也是云里雾里的。感觉和vue的nextTick不太一样。因为我试过相同情况下相同的代码，两个的表现不一样。17. 慎用sConsoleweb-view中的h5页面跳转到小程序会打开两次。这个情况是打开了SConsole调试面板的，关闭之后就不会出现这个情况。其它情况使用sConsole也有可能会出现某些小问题。。。18. getSwanIdgetSwanId在开发者工具上，返回的是SWAN-DEVELOP，而真机上是一段长度为几十个的字母和数字组成的字符串。19. css单位css单位基本都支持，不过如果是rpx这种，小程序会自动转换成vw或者vh，所以你会看到控制台里的单位都是vw或者vh20. getStoragegetStorage获取本地不存在的数据，默认进入success，不会进入fail回调21. 分享到贴吧这个功能，官方有说明： 这里是接入文档       这里是简单说明。在代码中配置好，并且上线小程序后，我以为这样就能申请分享白名单了。。。然而，按钮竟然没给我激活，点不动。。。搞不清楚原因。。。然后就放弃了 上面这些是真实遇到的情况，真的累，本来只花一天的时间搞得定的内容，一路踩坑结果多花了两三倍的时间。。。逐渐怀疑我是不是做程序员的料。。。后面还会继续开发百度小程序，估计又会折寿了。。。"}
{"title": "我写小程序像菜虚鲲—— 唱，跳，rap，篮球 ", "author": "Rolan", "put_time": "2019-6-11 00:38", "content": "引言大家好，我是练习时长两年半的个人练习生菜虚鲲，我喜欢唱，跳，rap，篮球，Music！为了避免律师含，就不po鲲鲲的原图咯~在小作坊待久了，都忘记自己的本职工作当初进来是一枚Android开发了，写写下APP和py脚本，偶尔帮人修修电脑。感觉如果自己大只点，可能饮水机的水都要我来换了…因为一些原因，旧APP不再更新迭代了，新的APP没开始做，不想赔钱把我开掉，就把我晾着摸鱼。而我自己比较腊鸡，感觉出去会找不到好的工作（不想再去小作坊，一个人玩好累，感觉再这样下去，会废掉…）晾着摸鱼不做事，工资照发，管理肯定不愿意啊，要给我找点事做做咯：要不你学下前端吧，做下小程序，后面做APP了，你再回去做APP…我TM，说得好像学东西不用学习成本一样，特别是跨域，最怕最后四不像，啥也什么都学得半桶水，如果真转的话，我更想转后端，毕竟前端技术更新换代速度实在是太快了，是真的快，学不来学不来。唉，自己又不是大神，人在屋檐下，不得不低头，安慰自己：小程序外包的单子挺多的，毕竟开发一个小程序的成本比APP少太多，很多甲方爸爸动不动就要做一个小程序，学了小程序，以后可以接点外包苟活下…自己摸索着玩了一个多星期，有点意思：老规矩，记录下自己的学习过程，方便自己日后回顾，也方便后来者。看过网上很多《从零开始学习微信小程序开发》类型的教程，大都废话太多，或者不是真的零基础入门，学着学着者突然来些高深玩意，看得我头皮发麻读者一脸懵逼，笔者深知自学循序渐进的重要性。另外，之前群里有小火汁问我学东西为啥那么快，其实，我学东西还真不快，主要有几点：顺带分享下自己的学习姿势吧~① 兴趣驱动 ：「 你想学 」而非「 要你学 」，主动去探索而非被动接受。② 专注 ：心无旁骛，别一下折腾这个，一下子又折腾那个，三分钟热度。③ 反思总结 ：及时总结归纳，形成自己的知识脉络，同时反思学习过程中的一些问题。④ 去实践 ：你掌握多少知识，取决于你能调用多少，而非记忆了多少知识。⑤ 度 ：把握一个度，知道自己要学习到什么程度，不要去钻牛角尖，等等。大概就这些，笔者是前端小白，并不会深刨，只是希望初学者学完这个系列可以撸出一个简单基本的小程序。现学现卖，难免有错，还望海涵，欢迎前端大神指出。如无意外，一周1-2更。不要有太多期待，因为还在准备Android面试相关。废话就那么多，开始本系列教程。Tips：个人觉得学习小程序最佳的学习方式就是肝官方文档~微信小程序官网： developers.weixin.qq.com/miniprogram…0x1、你看这个面又长又宽（开发环境搭建）官网点击：「 指南 」-> 「 开始 」1、申请账号账号可以申请也可以不申请不是一定要申请账号，如果你只是想 自己瞎玩不发布 的话，可以跳过这一步。当然，你也可以申请，申请后会给你的小程序分配一个「 AppID 」，类似于身份标识。可以在小程序后台，依次点击「 设置 」->「 开发设置 」获取到这个「 AppID 」：2、下载安装微信开发者工具官网依次点击「 工具 」-> 「 下载 」，或者直接打开下述链接跳转下载：developers.weixin.qq.com/miniprogram…用哪个版本看个人喜欢，笔者用的是 开发版 ，你也可以使用稳定版，下载完以后，无脑下一步安装即可。安装完后，其实就可以直接进行小程序开发，只是微信开发者工具自带的IDE比较简陋，没有自带api智能提醒和语法高亮等，写起代码来不是很顺手，所以一般只是拿微信开发者工具来「 看下运行效果 」和「 调试 」，写代码的话用的看看 运行效果，调试 ，二用第三方的IDE来编写代码，常见的两款组合：VS Code + minapp插件Sublime Text 3 + Sublime wxapp插件笔者使用的是前者，接着说下VS Code的下载安装。3、下载安装VS Code并安装minapp插件VS Code直接在官网下载就好： code.visualstudio.com/ ，默认英文。如果你想使用中文可以按快捷键：Windows 或 Linux => Ctrl + Shift + PMac => Command + Shift + P然后在弹出的对话框中输入：「 Configure Language 」，如图：接着点击「 Install additional languages… 」，如图：点击后左侧会出现一个插件安装的，选择中文，如图：安装完，提示重启，重启后就是中文了，接着安装一波minapp插件。点击左侧边栏的第四个图标，然后搜索栏键入「 minapp 」，然后点击Install进行安装，如图：。安装后可能需要重启，重启即可。除此之外，还安利一个插件：「 wechat-snippet 」，自动生成微信代码片段，如果想了解更多插件可见VS官网： marketplace.visualstudio.com/0x2、就像这个碗又大又圆（创建项目）直接打开微信开发者工具，可以「 新建项目 」或者「 导入项目 」，填写项目相关的信息，这里如果你没有申请账号的话可以用随机生成的AppID，如图所示：0x3、你们来这里吃饭（界面熟悉）创建后会自动生成相关代码，创建后的页面如图所示：简单介绍下，圈住的页面内容如下：简单说下页面中圈住的部分都是些什么：① 菜单栏 ：提供项目，文件，编辑等相关操作，自己点开看就知道了。② 视图开关 ：控制模拟器，编辑器和调试器视图的显示和隐藏。③ 模拟器 ：模拟小程序在手机上的界面效果，上面的栏可以进行模拟器的相关配置： 模拟器分辨率、缩放比例、连接网络方式、模拟操作、是否静音、独立成小窗口。④ 编辑器-项目文件目录 ：小程序文件目录，顶部菜单依次为：添加文件、搜索文件、 从硬盘打开、折叠某个目录，隐藏。⑤ 编辑器-文件内容编辑 ：就是编写代码的地方。⑥ 调试器 ：定制版的Chrome开发者工具，用于调试：页面结构，CSS，抓包，AppData等。⑧ 编译相关 ：可以选择编译选项：普通编译，添加编译模式(直接打开特定页面)或通过二维码编译，点击编译即可进行编译。点击预览可以生成二维码，然后在手机上查看效果。⑨ 真机调试 ：同样是生成二维码扫描看效果，不过多了调试功能。⑩ 切后台 ：切换场景值。⑪ 清缓存 ：就是清理缓存，可以清理：数据，文件，授权，网络，登录状态。⑫ 版本管理 ：小程序项目Git版本管理。⑬ 详情 ：项目的相关信息，项目配置，以及域名信息配置。⑭ 页面路径 ：当前页面的路径，场景值和页面参数。关于微信开发者工具的界面的简单介绍就到这里，接着我们来说下小程序的基本结构。0x4、觉得饭很好吃（基本结构）1、四类文件小程序一般由下面四类文件组成：json ： 配置文件 ，页面和开发工具的相关配置。wxml ： 模板文件 ，堆砌控件形成小程序页面，有点像HTML。wxss ： 样式文件 ，调整页面样式，有点像CSS。js ： 脚本逻辑文件 ，完成一些逻辑处理操作，比如发起请求，事件触发等。简单点说： wxml里写页面，wxss里写样式，js里写逻辑，json里改配置。2、三个重要的配置文件① 开发工具配置 ：「 project.config.json 」开发者工具的统一配置，界面设置以及云函数相关，更多可见：developers.weixin.qq.com/miniprogram…② 小程序全局配置 ：「 app.json 」比如：页面路径列表，默认窗口，底部tab栏，网络超时等，更多可见：developers.weixin.qq.com/miniprogram…③ 单页面配置 ：「 page.json 」使用「 同名.json 」文件来对本页面的窗口表现进行配置，会覆盖app.json的window中相同的配置项，更多可见：developers.weixin.qq.com/miniprogram…0x5、就像我给你们拉面一样很开心（小程序初体验）接着，通过编写一个简陋的页面，来体验下小程序的开发~1、全局窗口配置先来配置一波小程序的窗口，要求如下：蕾姆蓝背景，白色文字，菜单栏显示抠腚男孩打开 app.json 文件，添加下述配置：\"navigationBarBackgroundColor\": \"#5A78EA\",\r\n\"navigationBarTitleText\": \"抠腚男孩\",\r\n\"navigationBarTextStyle\": \"white\"\r\n复制代码编译运行后，效果如图所示：2、编写简陋页面接着开始着手编写这个简陋页面，定义一个顶部头像，新建 asserts 文件夹，用来存放 静态资源文件 ，接着往 index.wxml 中添加一个image控件：<image src=\"../../assets/codingboy.png\" />\r\n复制代码编译运行后，效果如图所示：3、调整样式可以，很骚气，但是作为头像有点太大了，调整一下它的样式，打开 index.wxss ，添加一个类选择器：.user-icon-image{\r\n    width: 150rpx;\r\n    height: 150rpx;\r\n}\r\n复制代码image标签设置一下这个选择器：<image class=\"user-icon-image\" src=\"../../assets/codingboy.png\"/>\r\n复制代码编译运行后，效果如图所示：Tips：这里还可以利用 宽高自适应 的，即：设置宽度，保持原图宽高比不变，高度自动变化。为image标签设置属性：mode=\"widthFix\"，效果是一样的。4、获取用户授权这里有个需求：如果已经获取了用户授权，就显示微信头像，否则显示这个默认头像在 index.wxml 中添加一个用于获取用户昵称和头像的按钮：<button open-type=\"getUserInfo\">获取头像昵称</button>\r\n复制代码编译运行后，点击按钮会弹出一个授权对话框：点击允许即可完成授权，但是授权的信息并没有保存起来。5、获取授权信息授权是授权了，但是信息却没有拿到，button有一个属性： bindgetuserinfo ，当用户点击按钮时，会返回获取到的用户信息，我们在这里绑定一个保存用户信息的回调函数，在 index.js 中添加下述代码直接把授权信息给打印出来：getUserInfo: function (e) {\r\n    app.globalData.userInfo = e.detail.userInfo\r\n    console.log(app.globalData.userInfo)\r\n}\r\n复制代码接着 index.wxml 中绑定一下：<button open-type=\"getUserInfo\" bindgetuserinfo=\"getUserInfo\">获取头像昵称</button>\r\n复制代码清一波缓存，然后重新编译，点击获取头像昵称的按钮，对话框授权，在Console可以看到用户的相关信息：6、保存授权信息授权信息可以获取到了，接下来我们通过定义一个变量的方式把信息保存下来，另外，我们还需要定义一个变量作为是否获得授权信息的标记，用于控制显示微信头像还是默认头像，打开 index.js 添加下述代码：Page({\r\n    data: {\r\n        userInfo: {}, //用户信息\r\n        hasUserInfo: false, //是否有用户信息\r\n    }\r\n})\r\n复制代码修改下getUserInfo函数，修改后的代码如下：getUserInfo: function (e) {\r\n    app.globalData.userInfo = e.detail.userInfo\r\n    this.setData({\r\n        userInfo: e.detail.userInfo,\r\n        hasUserInfo: true\r\n    })\r\n}\r\n复制代码另外授权信息，其实可以通过 app.globalData.userInfo 获取，在程序初始化的时候在onLoad函数中去获取下，添加一个 onLoad 函数，代码如下：onLoad: function () { \r\n    if (app.globalData.userInfo) {\r\n        this.setData({\r\n            userInfo: app.globalData.userInfo,\r\n            hasUserInfo: true\r\n         })\r\n    }\r\n}\r\n复制代码7、wx:if，wx:elif，wx:else判断结构接着在 index.wxml 中通过 wx:if 判断是加载默认图还是微信头像，代码如下：<block wx:if=\"{{!hasUserInfo}}\">\r\n    <image class=\"user-icon-image\" src=\"../../assets/codingboy.png\" mode=\"widthFix\" />\r\n    <button open-type=\"getUserInfo\" bindgetuserinfo=\"getUserInfo\">获取头像昵称</button>\r\n</block>\r\n<block wx:else>\r\n    <image class=\"user-icon-image\" src=\"{{userInfo.avatarUrl}}\" mode=\"widthFix\" />\r\n    <text>{{userInfo.nickName}}</text>\r\n</block>\r\n复制代码运行后可以看到显示的是微信用户昵称和头像，如图：接着调整一下样式，外层包一个view，接着让这两个东西居中：.user-icon-wrapper{\r\n  display:flex;                 \r\n  justify-content: center; \r\n  flex-direction: column;\r\n  align-items: center\r\n} \r\n复制代码有点挤，顶部加padding，图片圆角，调整背景颜色， index.wxss 添加：page {\r\n  background: #f6f6f6;\r\n  position: relative;\r\n  padding-top: 30rpx;\r\n  color: #323233;\r\n}\r\n\r\n.user-icon-wrapper{\r\n  display:flex;                 \r\n  justify-content: center; \r\n  flex-direction: column;\r\n  align-items: center\r\n} \r\n\r\n.user-icon-image{ \r\n  width: 150rpx;\r\n  border-radius: 20rpx;\r\n}\r\n\r\n.authorize-button{\r\n  margin-top: 30rpx;\r\n}\r\n\r\n.nickname-text{\r\n  margin-top: 30rpx;\r\n}\r\n复制代码接着修改下 index.wxml ，代码如下：<!-- index.wxml -->\r\n<block wx:if=\"{{!hasUserInfo && canIUse}}\">\r\n    <view class=\"user-icon-wrapper\">\r\n        <image class=\"user-icon-image\" src=\"../../assets/codingboy.png\" mode=\"widthFix\" />\r\n        <button class=\"authorize-button\" open-type=\"getUserInfo\" bindgetuserinfo=\"getUserInfo\">\r\n            获取头像昵称\r\n        </button>\r\n    </view>\r\n</block>\r\n<block wx:else>\r\n    <view class=\"user-icon-wrapper\">\r\n        <image class=\"user-icon-image\" src=\"{{userInfo.avatarUrl}}\" mode=\"widthFix\" />\r\n        <text class=\"nickname-text\">{{userInfo.nickName}}</text>\r\n    </view>\r\n</block>\r\n复制代码运行结果如下：8、单机版天气预报(wx:for循环结构)只是点击授权然后获取头像显示，感觉好low，跟官方的例子有啥区别，加个天气预报的东东吧，这里采用的天气接口是： 魅族天气API ，接口地址如下：aider.meizu.com/app/weather…访问看下，返回的数据如下：开发初期，为了提高开发的效率，会先造假数据，前后端约定好接口的返回数据。由后端写一个接口返回假数据，或者前端本地跑一个mock服务器，也可以直接写死在程序中。这里为了方便，直接写死，在 index.js 的page中添加下述数据：city: '深圳',\r\nprovince: '广东省',\r\nrealtime: {\r\n  img: \"1\",\r\n  sD: \"72\",\r\n  sendibleTemp: \"25\",\r\n  temp: \"25\",\r\n  time: \"2019-04-17 16:35:08\",\r\n  wD: \"西南风\",\r\n  wS: \"1级\",\r\n  weather: \"多云\",\r\n  ziwaixian: \"N/A\"\r\n},\r\nindexes: [{\r\n  abbreviation: \"uv\",\r\n  alias: \"\",\r\n  content: \"辐射较弱，涂擦SPF12-15、PA+护肤品。\",\r\n  level: \"弱\",\r\n  name: \"紫外线强度指数\"\r\n},\r\n{\r\n  abbreviation: \"pp\",\r\n  alias: \"\",\r\n  content: \"建议用露质面霜打底，水质无油粉底霜，透明粉饼，粉质胭脂。\",\r\n  level: \"控油\",\r\n  name: \"化妆指数\"\r\n},\r\n{\r\n  abbreviation: \"yd\",\r\n  alias: \"\",\r\n  content: \"天气较好，且紫外线辐射不强，适宜户外运动。\",\r\n  level: \"适宜\",\r\n  name: \"运动指数\"\r\n},\r\n{\r\n  abbreviation: \"xc\",\r\n  alias: \"\",\r\n  content: \"洗车后，只能保持1天车辆清洁，不太适宜洗车。\",\r\n  level: \"较不适宜\",\r\n  name: \"洗车指数\"\r\n},\r\n{\r\n  abbreviation: \"ct\",\r\n  alias: \"\",\r\n  content: \"天气较热，衣物精干简洁，室内酌情添加空调衫。\",\r\n  level: \"热\",\r\n  name: \"穿衣指数\"\r\n},\r\n{\r\n  abbreviation: \"gm\",\r\n  alias: \"\",\r\n  content: \"感冒较易发生，干净整洁的环境和清新流通的空气都有利于降低感冒的几率，体质较弱的童鞋们要特别加强自我保护。\",\r\n  level: \"较易发\",\r\n  name: \"感冒指数\"\r\n}],\r\n复制代码接着index.wxml添加控件：<button style=\"margin-top: 50rpx\">刷新天气</button>\r\n<view style=\"height: 100rpx;flex-direction:column;\">\r\n  <text>城市：{{city}}</text>\r\n  <text>省：{{province}}</text>\r\n  <text>天气：{{realtime.weather}}</text>\r\n  <text>温度：{{realtime.temp}}°C</text>\r\n  <text>湿度：{{realtime.sD}}</text>\r\n  <text>更新时间：{{realtime.time}}</text>\r\n  <text>风向：{{realtime.wD}}</text>\r\n  <text>风力：{{realtime.wS}}</text>\r\n</view>\r\n复制代码运行结果如下：文字都堆叠到一起了，设置下样式：.message-text {\r\n  margin-left: 15rpx;\r\n  display: block;\r\n  margin-top: 50rpx;\r\n}\r\n复制代码接着每个text设置下message-text这个类选择器，运行效果如下：接着把indexes里的数据也显示出来，通过 wx:for 循环生成结点：<block wx:for=\"{{indexes}}\" wx:for-item=\"item\" wx:key=\"key\">\r\n    <text>{{item.name}}：{{item.abbreviation}}</text>\r\n    <text>{{item.content}}</text>\r\n    <text>{{item.level}}</text>\r\n</block>\r\n复制代码运行后结果如下：文本都堆在一起密密麻麻的，写个样式：.indexes-text {\r\n  display: block;\r\n  margin-left: 15rpx;\r\n}\r\n\r\n.indexes-text-last{\r\n  display: block;\r\n  margin-left: 15rpx;\r\n  padding-bottom: 50rpx;\r\n}\r\n复制代码运行结果如下：9、网络版天气预报(wx.request发起请求)单机版的就完成了，接着通过 wx.requests 来请求接口，实现一个网络版的天气预报。index.js中新增刷新天气的函数：refreshWeather: function () {\r\n    var that = this\r\n    wx.request({\r\n      url: 'http://aider.meizu.com/app/weather/listWeather',\r\n      data: {\r\n        'cityIds': '101280601'\r\n      },\r\n      method: 'GET',\r\n      headers: {\r\n        'User-Agent:': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.103 Safari/537.36',\r\n        'Host': 'aider.meizu.com'\r\n      },\r\n      success: function (res) {\r\n        if (res.data.code == 200) {\r\n          that.setData({\r\n            weather: res.data.value[0]\r\n          })\r\n        }\r\n      },\r\n    })\r\n  },\r\n复制代码接着按钮设置下点击时触发这个网络请求：<button style=\"margin-top: 50rpx\" bindtap=\"refreshWeather\">刷新天气</button>\r\n复制代码因为接口是http的，还需要微信开发者工具点开 详情 ，勾选下：接着点击运行，点击刷新天气，在Network选项卡可以看到发出的请求信息：然后咧，微信小程序的视图层和逻辑层类似MVVM模式，逻辑层只需对数据对象更新，即可改变视图层的数据数据显示，这里setData后，对应的控件也会改变。到此一个非常简单的天气预报小程序就完成了。小结本节介绍了微信小程序开发环境的搭建，开发一个简易天气小程序体验了一波微信小程序，相信读者对于微信小程序有个基本的了解了，接下来的章节会慢慢细化一些知识点，比如控件定位，UI相关，请求封装，开源开发框架WePY等等，敬请期待~如果本文对你有所帮助，欢迎留言，点赞，转发 素质三连，谢谢:kissing_heart:~"}
{"title": "小程序营销组件：红包雨、大转盘、九宫格翻牌…… ", "author": "Rolan", "put_time": "2019-6-12 00:23", "content": "前言商城没几个营销活动能叫商城吗？这里你能找到的有：1.红包雨2.大转盘3.九宫格翻牌4...所以就来几个组件吧，写的不好轻踩，对你有帮助记得给个小星星哦直接上链接github链接运行例子git clone https://github.com/sunnie1992/soul-weapp.git\r\n复制代码微信开发者工具打开项目营销组件大转盘 \"pages/wheel/index\" 九宫格翻牌 \"pages/gridCard/index\" 红包雨 \"pages/packetRain/index\" 页面\"pages/filter/index\" 功能筛选筛选预览"}
{"title": "微信小程序前端实现自定义分享 ", "author": "Rolan", "put_time": "2019-6-13 00:06", "content": "目前手上有一个小程序的项目，希望转发时分享消息的界面能够自定义,然而微信小程序只提供设置图片的url和title。/**\r\n     * 用户点击右上角分享\r\n     */\r\n    onShareAppMessage: function() {\r\n        return {\r\n          imageUrl:'',\r\n          title:''\r\n        };\r\n    }\r\n复制代码实现我们要转发的显示内容多了一点东西: 头像 ， 用户名 和 点赞数。好在这个排版不是很复杂，所以我们思考了一下通过canvas去生成一张图片再return canvas所生成的图片url。代码如下（其实还要作出一些显示上的优化，具体你们自己去调试）： 先在页面里新建一个canvas 标签<canvas canvas-id=\"canvasid\" style=\"width: 375px; height: 500px;\" wx:if=\"{{canvasShow}}\"></canvas>\r\n复制代码let context = wx.createCanvasContext('canvasid')\r\n     context.drawImage(back.path, 0, 60, backWidth, backHeight) //绘制下方背景图\r\n     //绘制圆形头像，参考教程：https://www.jianshu.com/p/9a6ee2648d6f 第二种方法\r\n\r\n      context.save();\r\n      var d = 2 * 25;\r\n      var cx = 0 + 25;\r\n      var cy = 0 + 25;\r\n      context.arc(cx, cy,25, 0, 2 * Math.PI);\r\n      context.clip();\r\n      context.drawImage(avatar.path, 0,0, d, d);\r\n      context.restore();\r\n      //绘制名字和点赞数\r\n      context.setFontSize(14)\r\n      context.fillText('userName', 70, 32)\r\n      let zanLength = ('100' + '次赞').length\r\n      context.fillText('100'+ '次赞', 375 - 14 * zanLength, 32)\r\n      //执行draw进行渲染 并返回图片url\r\n      context.draw(true, () => {\r\n        //此方法应执行在draw的回调中\r\n        wx.canvasToTempFilePath({\r\n          x: 0,\r\n          y: 0,\r\n          width: 375,\r\n          height: 400,\r\n          destWidth: 375,\r\n          destHeight: 400,\r\n          canvasId: 'canvasid',\r\n          success(res) {\r\n        //设置onShareAppMessage所返回的数据格式\r\n           let shareInfo = {\r\n              title: 'customTitle',\r\n              imageUrl\r\n            }\r\n           //隐藏画布\r\n            that.setData({\r\n              canvasShow: false\r\n            })\r\n          }\r\n        })\r\n      });\r\n复制代码然而！ 在canvas中绘制的图片要在真机上显示出来是有问题的（画布污染），非同源的图片在canvas不会显示出来的。后来我们使用 wx.getImageInfo 去获取图片信息，通过里面的地址去显示图片(相当于是把图片转了一道)。wx.getImageInfo({\r\n                src: imgUrl,\r\n                success: function(res) {\r\n                     /**拿到返回值res[0].path,再把该值作为canvas绘制图片的路径 \r\n                        context.drawImage(res[0].path,x,x,x)**/\r\n                    let drawImgUrl =  res[0].path\r\n                }\r\n            }); \r\n复制代码emmmm....文章很短暂，这里只是提供一下解决的思路，希望能帮助到大家~"}
{"title": "小程序打怪之在线客服自动回复功能(node版) ", "author": "Rolan", "put_time": "2019-6-13 00:14", "content": "我们知道H5页面经常需要将用户导流到APP，通过下载安装包或者跳转至应用宝市场/Appstore等方式进行导流。但是由于小程序嵌套webview时需要校验域名，因此跳转到第三方应用市场和Appstroe无法实现导流。那怎么办呢? 只能说道高一尺魔高一丈，看看微博小程序是怎么导流的:曲线救国的方式，利用小程序的在线功能可以打开H5的方式，去进行下载引导。 于是，就引出了这次文档的主题，小程序在线客服自动回复功能。:laughing:阅读本文档之前，最好已经了解过小程序客服信息官方的相关文档:1. 客服消息使用指南2. 小程序客服消息服务端接口3. 客服消息开发文档这次开发做在线客服功能也踩了不少坑，网上也查阅不少资料，但大部分的后台都是基于php或者python,java开发，node.js开发的较少，因此将这次开发的流程记录一下，供大家参考，避免大家踩坑。可能会有一些错误地方欢迎指正交流。 另外，我们用的node框架是基于koa自行封装的，在一些细节实现上和其他框架会有区别，不必纠结。需求描述小程序中点按钮跳转在线客服界面，根据关键词自动回复 客服回复判断条件，支持cms配置key，及 respond respond 支持配置以下类型，及回复内容:type内容texttext=文本回复内容linktitle=标题 description=描述 url=跳转链接 thumb_url=图片地址imageimageurl=图片地址配置后用户需要精准匹配回复条件才可收到自动回复可支持配置多个key，及对应respond除了配置的key以外的回复，可配置默认的自动回复开发流程写个跳转客服的按钮吧index.wxml<button open-type=\"contact\">转在线客服</button>\r\n复制代码后台配置登录小程序后台后，在「开发」-「开发设置」-「消息推送」中，管理员扫码启用消息服务，填写服务器地址（URL）、令牌（Token） 和 消息加密密钥（EncodingAESKey）等信息。URL服务器地址URL: 开发者用来接收微信消息和事件的接口 URL。开发者所填写的URL 必须以 http:// 或 https:// 开头，分别支持 80 端口和 443 端口。务必要记住，服务器地址必须是 线上 地址，因为需要微信服务器去访问。localhost，IP，内网地址都不行的。不然会提示 '解析失败，请检查信息是否填写正确'。那么问题来了，不同的公司都有一套上线流程，总不能为了调试URL是否可用要上到线上去测试，成本太大，也不方便。这就要引出 内网穿透 了，简单来说就是配置一个线上域名，但是这个域名可以穿透到你配置的本地开发地址上，这样可以方便你去调试看日志。 推荐一个可以实现内网穿透的工具。(非广告 :laughing:)NATAPP 具体不详细介绍，免得广告嫌疑。简单说，NATAPP有免费和付费两种模式，免费的是域名不定时更换，对于微信的推送消息配置一个月只有3次更改机会来说，有点奢侈。不定什么时候配置的域名就不能访问，得重新配置。而付费的则是固定域名，映射的内网地址也可以随时更改。楼主从免费切到付费模式，一个月的VIP使用大概十几块钱吧。2.TokenToken自己随便写就行了，但是要记住它，因为你在接口中要用的。3.EncodingAESKey随机生成即可。4.加密方式和数据格式根据自己喜欢选择，楼主选择的安全模式和JSON格式。 不同的模式和数据格式，在开发上会有不同，自己衡量。 既然这些配置都清楚，那开始码代码。验证消息的确来自微信服务器配置提交前，需要把验证消息来自微信服务器的接口写好。server.js/*\r\n     * https://developers.weixin.qq.com/miniprogram/dev/framework/server-ability/message-push.html\r\n     * 验证消息的确来自微信服务器\r\n     * 开发者通过检验 signature 对请求进行校验（下面有校验方式）。\r\n     * 若确认此次 GET 请求来自微信服务器，请原样返回 echostr 参数内容，\r\n     * 则接入生效，成为开发者成功，否则接入失败。加密/校验流程如下：\r\n     * 将token、timestamp、nonce三个参数进行字典序排序\r\n     * 将三个参数字符串拼接成一个字符串进行sha1加密\r\n     * 开发者获得加密后的字符串可与signature对比，标识该请求来源于微信\r\n     */\r\n     const crypto = require('crypto');\r\n     async wxCallbackAction(){\r\n        const ctx = this.ctx;\r\n        const method = ctx.method;\r\n     \t//微信服务器签名验证，确认请求来自微信\r\n     \tif(method === 'GET') {\r\n     \t\t// 1.获取微信服务器Get请求的参数 signature、timestamp、nonce、echostr\r\n     \t\tconst {\r\n     \t\t\tsignature,\r\n     \t\t\ttimestamp,\r\n     \t\t\tnonce,\r\n     \t\t\techostr\r\n     \t\t} = ctx.query;\r\n     \t\t\r\n     \t\t// 2.将token、timestamp、nonce三个参数进行字典序排序\r\n     \t\tlet array = ['yourToken', timestamp, nonce];\r\n     \t\tarray.sort();\r\n     \t\t\r\n     \t\t// 3.将三个参数字符串拼接成一个字符串进行sha1加密\r\n     \t\tconst tempStr = array.join('');\r\n     \t\tconst hashCode = crypto.createHash('sha1'); //创建加密类型\r\n     \t\tconst resultCode = hashCode.update(tempStr, 'utf8').digest('hex');\r\n     \t\t\r\n     \t\t// 4.开发者获得加密后的字符串可与signature对比，标识该请求来源于微信\r\n     \t\tif (resultCode === signature) {\r\n     \t\t\tconsole.log('验证成功，消息是从微信服务器转发过来');\r\n     \t\t\treturn this.json(echostr);\r\n     \t\t}else {\r\n     \t\t\tconsole.log('验证失败！！！');\r\n     \t\t\treturn this.json({\r\n     \t\t\t\tstatus: -1,\r\n     \t\t\t\tmessage: \"验证失败\"\r\n     \t\t\t});\r\n     \t\t}\r\n            \r\n     \t}\r\n     }\r\n复制代码验证接口开发完毕，后台配置可以去点提交了。配置成功会提示如下:接收消息和推送消息当用户在客服会话发送消息、或由某些特定的用户操作引发事件推送时，微信服务器会将消息或事件的数据包发送到开发者填写的 URL。开发者收到请求后可以使用发送客服消息接口进行异步回复。本文以接收文本消息为例开发:server.jsconst WXDecryptContact = require('./WXDecryptContact');\r\n    async wxCallbackAction(){\r\n        const ctx = this.ctx;\r\n        const method = ctx.method;\r\n        //接收信息时为POST请求；(完整代码自行与上面验证时的合并即可)\r\n        if(method === 'POST'){\r\n            const { Encrypt } = ctx.request.body;\r\n            //配置时选的安全模式 因此需要解密\r\n            if(!Encrypt){\r\n                return this.json('success');\r\n            }\r\n            const decryptData = WXDecryptContact(Encrypt);\r\n            await this._handleWxMsg(decryptData);\r\n            return this.json('success');\r\n \t\t}\r\n \t}\r\n \t\r\n \t//处理微信回调消息的总入口 (只处理了文本类型，其他类型自行添加)\r\n    async _handleWxMsg(msgJson){\r\n        if(!msgJson){\r\n            return ;\r\n        }\r\n\r\n        const { MsgType } = msgJson;\r\n        if(MsgType === 'text'){\r\n            await this._sendTextMessage(msgJson);\r\n        }\r\n        \r\n    }\r\n    //微信文本信息关键字自动回复\r\n    async _sendTextMessage(msgJson){\r\n \t    //获取CMS客服关键词回复配置\r\n \t    const result = await this.callService('cms.getDataByName', 'wxApplet.contact');\r\n \t\t\r\n \t\tlet keyWordObj = result.data || {};\r\n \t\r\n \t\t//默认回复default\r\n \t\tlet options = keyWordObj.default;\r\n \t\tfor(let key in keyWordObj){\r\n \t\t\t//查看是否命中配置的关键词\r\n \t\t\tif(msgJson.Content === key){\r\n \t\t\t    //CMS配置项\r\n \t\t\t\toptions = keyWordObj[key];\r\n \t\t\t}\r\n \t\t}\r\n \t}\r\n \t\t\r\n \t//获取access_token\r\n \tconst accessToken = await this._getAccessToken();\r\n \t\r\n \t/*\r\n \t* 先判断配置回复的消息类型是不是image类型\r\n \t* 如果是 则需要先通过 新增素材接口 上传图片文件获得 media_id\r\n \t*/\r\n \t\r\n \tlet media_id = '';\r\n \tif(options.type === 'image'){\r\n \t\t//获取图片地址(相对路径)\r\n \t\tlet url = options.url;\r\n \t\tconst file = fs.createReadStream(url);\r\n \t\t\r\n \t\t//调用微信 uploadTempMedia接口 具体实现见 service.js\r\n \t\tconst mediaResult = await this.callService('wxApplet.uploadTempMedia',\r\n \t\t\t{\r\n \t\t\t\taccess_token: accessToken,\r\n \t\t\t\ttype: 'image'\r\n \t\t\t},\r\n \t\t\t{\r\n \t\t\t\tmedia: file\r\n \t\t\t}\r\n \t\t);\r\n \t\t\r\n \t\tif(mediaResult.status === 0){\r\n \t\t\tmedia_id = mediaResult.data.media_id;\r\n \t\t}else {\r\n \t\t\t//如果图片id获取失败 则按默认处理\r\n \t\t\toptions = keyWordObj.default;\r\n \t\t}\r\n \t}\r\n \t\r\n \t//回复信息给用户\r\n \tconst sendMsgResult = await this.callService('wxApplet.sendMessageToCustomer',\r\n \t\t{\r\n \t\t\taccess_token: accessToken,\r\n \t\t\ttouser: msgJson.FromUserName,\r\n \t\t\tmsgtype: options.type || 'text',\r\n \t\t\ttext: {\r\n \t\t\t\tcontent: options.description || '',\r\n \t\t\t},\r\n \t\t\tlink: options.type === \"link\" ? \r\n \t\t\t\t{\r\n \t\t\t\t\ttitle: options.title,\r\n \t\t\t\t\tdescription: options.description,\r\n \t\t\t\t\turl: options.url,\r\n \t\t\t\t\tthumb_url: options.thumb_url\r\n \t\t\t\t}\r\n \t\t\t\t:\r\n \t\t\t\t{},\r\n \t\t\timage: {\r\n \t\t\t\tmedia_id\r\n \t\t\t}\r\n \t\t}\r\n \t);\r\n \t\r\n }\r\n复制代码service.jsconst request = require('request');\r\n\r\n\r\n/*\r\n* 获取CMS客服关键词回复配置\r\n* 这个接口只是为了回去CMS配置的字段回复关键字配置 返回的data数据结构如下\r\n*/\r\nasync contact(){\r\n\treturn {\r\n\t\tdata: {\r\n\t\t\t\"1\": {\r\n\t\t\t    \"type\": \"link\",\r\n\t\t\t    \"title\": \"点击下载[****]APP\",\r\n\t\t\t    \"description\": \"注册领取领***元注册红包礼\",\r\n\t\t\t    \"url\": \"https://m.renrendai.com/mo/***.html\",\r\n\t\t\t    \"thumb_url\": \"https://m.we.com/***/test.png\"\r\n\t\t\t  },\r\n\t\t\t  \"2\": {\r\n\t\t\t    \"url\": \"http://m.renrendai.com/cms/****/test.jpg\",\r\n\t\t\t    \"type\": \"image\"\r\n\t\t\t  },\r\n\t\t\t  \"3\": {\r\n\t\t\t    \"url\": \"/cms/***/test02.png\",\r\n\t\t\t    \"type\": \"image\"\r\n\t\t\t  },\r\n\t\t\t  \"default\": {\r\n\t\t\t    \"type\": \"text\",\r\n\t\t\t    \"description\": \"再见\"\r\n\t\t\t  }\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/*\r\n * 把媒体文件上传到微信服务器。目前仅支持图片。用于发送客服消息或被动回复用户消息。\r\n * https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/customer-message/customerServiceMessage.uploadTempMedia.html\r\n */\r\n \r\n async uploadTempMedia(data,formData){\r\n \tconst url = `https://api.weixin.qq.com/cgi-bin/media/upload?access_token=${data.access_token}&type=${data.type}`;\r\n \treturn new Promise((resolve, reject) => {\r\n \t\trequest.post({url, formData: formData}, (err, response, body) => {\r\n \t\t\ttry{\r\n \t\t\t\tconst out = JSON.parse(body);\r\n \t\t\t\tlet result = {\r\n \t\t\t\t\tdata: out,\r\n \t\t\t\t\tstatus: 0,\r\n \t\t\t\t\tmessage: \"ok\"\r\n \t\t\t\t}\r\n \t\t\t\t\r\n \t\t\t\treturn resolve(result);\r\n \t\t\t\r\n \t\t\t}catch(err){\r\n \t\t\t\treturn reject({\r\n \t\t\t\t\tstatus: -1,\r\n \t\t\t\t\tmessage: err.message\r\n \t\t\t\t});\r\n \t\t\t}\r\n \t\t});\r\n \t}\r\n }\r\n \r\n /*\r\n * 发送客服消息给用户\r\n * https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/customer-message/customerServiceMessage.send.html\r\n */\r\n \r\n async sendMessageToCustomer(data){\r\n \tconst url = `https://api.weixin.qq.com/cgi-bin/message/custom/send?access_token=${data.access_token}`;\r\n \treturn new Promise((resolve, reject) => {\r\n \t\trequest.post({url, data}, (err, response, body) => {\r\n \t\t\t...\r\n \t\t});\r\n \t}\r\n\r\n }\r\n \r\n复制代码WXDecryptContact.js消息加密解密文档const crypto = require('crypto'); // 加密模块\r\n\r\nconst decodePKCS7 = function (buff) {\r\n    let pad = buff[buff.length - 1];\r\n    if (pad < 1 || pad > 32) {\r\n        pad = 0;\r\n    }\r\n    return buff.slice(0, buff.length - pad);\r\n};\r\n\r\n// 微信转发客服消息解密\r\nconst decryptContact = (key, iv, crypted) => {\r\n    const aesCipher = crypto.createDecipheriv('aes-256-cbc', key, iv);\r\n    aesCipher.setAutoPadding(false);\r\n    let decipheredBuff = Buffer.concat([aesCipher.update(crypted, 'base64'), aesCipher.final()]);\r\n    decipheredBuff = decodePKCS7(decipheredBuff);\r\n    const lenNetOrderCorpid = decipheredBuff.slice(16);\r\n    const msgLen = lenNetOrderCorpid.slice(0, 4).readUInt32BE(0);\r\n    const result = lenNetOrderCorpid.slice(4, msgLen + 4).toString();\r\n    return result;\r\n};\r\n\r\n// 解密微信返回给配置的消息服务器的信息\r\nconst decryptWXContact = (wechatData) => {\r\n    if(!wechatData){\r\n        wechatData = '';\r\n    }\r\n    //EncodingAESKey 为后台配置时随机生成的\r\n    const key = Buffer.from(EncodingAESKey + '=', 'base64');\r\n    const iv = key.slice(0, 16);\r\n    const result = decryptContact(key, iv, wechatData);\r\n    const decryptedResult = JSON.parse(result);\r\n    console.log(decryptedResult);\r\n    return decryptedResult;\r\n};\r\n\r\nmodule.exports = decryptWXContact;\r\n复制代码呼~ 代码终于码完，来看看效果:总结开发并不是一帆风顺的，也遇到了一些值得留意的坑，强调一下:后台配置URL地址一定外网可访问(可以通过内网穿透解决)文件上传接口 uploadTempMedia media 参数要用 FormData数据格式 (用node的 request 库很容易实现。 urllib 这个库有坑有坑 都是泪T_T)切记接收消息不论成功失败都要返回 success ，不然即使成功接收返回消息，日志没有报错的情况下，还是出现IOS提示该小程序提供的服务出现故障 请稍后再试。"}
{"title": "微信小程序胶囊按钮返回|首页自定义导航栏详解 ", "author": "Rolan", "put_time": "2019-6-14 00:43", "content": "项目代码：https://github.com/Shay0921/header-navbar.git在小程序中，从转发出来的小程序消息卡片进入，因为页面栈中只有一个，所以不会出现返回按钮，对于一些电商平台来说，当商品被转发后会很影响客户查看其它产品和首页，这时候就需要使用自定义导航栏自己写一个“胶囊按钮”。如下图所示：从别的页面点到商品页时会有返回和首页按钮；当从分享页进入到商品页时，因为页面栈只有一个，所以只有首页按钮；首先我们需要如何开启自定义导航栏，查看手册后会发现一个页面配置项：navigationStyle之前的版本此配置项只能在app.js中配置，是全局的属性，而现在可以在单独的页面json中配置，实现单独页面自定义导航栏。整体思路当使用了navigationStyle:custom后，之前的顶部标题栏会被删除，右侧的胶囊按钮则会固定在右上角。然后在当前页面添加了三个view(状态栏、标题栏、主体内容)，可以看出三块的布局，我直接写死的高度：状态栏20px，标题栏44px。这个是自定义导航栏的关键，需要去计算这两块的高度，还有返回|首页胶囊按钮的位置。基础库 2.1.0开始可以使用wx.getMenuButtonBoundingClientRect()来获得右侧胶囊按钮的位置信息，而有了这个信息，就能相对的算出我们想要在左侧添加的胶囊按钮的位置。通过wx.getSystemInfoSync()中的statusBarHeight找到状态栏的高度。目录结构├── components                  组件\r\n│  ├── headerNavbar             顶部自定义导航栏\r\n│  │  └── headerNavbar.js\r\n│  │  └── headerNavbar.json\r\n│  │  └── headerNavbar.wxml\r\n│  │  └── headerNavbar.wxss\r\n├── pages                       页面\r\n│  ├── index                    首页\r\n│  │  └── index.js\r\n│  │  └── index.json\r\n│  │  └── index.wxml\r\n│  │  └── index.wxss\r\n│  ├── navigationStyle          引入自定义导航栏的页面(单独配置了navigationStyle)\r\n│  │  └── navigationStyle.js\r\n│  │  └── navigationStyle.json\r\n│  │  └── navigationStyle.wxml\r\n│  │  └── navigationStyle.wxss\r\n│  │  └── testPage.js           路由测试页面(后面用来测试跳转显示不同胶囊按钮)\r\n│  │  └── testPage.json\r\n│  │  └── testPage.wxml\r\n│  │  └── testPage.wxss复制代码全局变量app.js在app.js中要先获得状态栏高度和右侧胶囊位置信息App({\r\n    onLaunch: function (options) {\r\n      // 这里省略掉了登录和获取用户信息等函数\r\n      // 因为我在别的页面也需要使用此信息，所以没有单独获得 statusBarHeight\r\n      wx.getSystemInfo({ // 获取设备信息\r\n        success: (res) => {\r\n          this.globalData.systeminfo = res\r\n        },\r\n      })\r\n      // 获得胶囊按钮位置信息\r\n      this.globalData.headerBtnPosi = wx.getMenuButtonBoundingClientRect()\r\n    },\r\n    globalData: {\r\n        systeminfo: {}, // 系统信息\r\n        headerBtnPosi: {} // 胶囊按钮位置信息\r\n    }\r\n})\r\n复制代码这里需要注意wx.getMenuButtonBoundingClientRect()，并不是像wx.getSystmInfo一样有success回调函数，而是像对象一样wx.getMenuButtonBoundingClientRect().height来使用。组件代码headerNavbar.wxml<!-- 自定义导航栏 -->\r\n<view class='navbar-wrap' \r\n  style='height:{{navbarHeight}}px;padding-top:{{statusBarHeight}}px;'>  \r\n  <view class=\"navbar-text\"\r\n    style='line-height:{{navbarBtn.height + navbarBtn.top}}px;'>\r\n    {{navbarData.title ? navbarData.title : \"默认标题\"}}{{navbarHeight}}\r\n  </view>\r\n  <view class=\"navbar-icon\"\r\n    wx:if='{{navbarData.showCapsule ? navbarData.showCapsule : true}}'\r\n    style=\"top:{{navbarBtn.top + statusBarHeight}}px;left:{{navbarBtn.right}}px;height:{{navbarBtn.height}}px;\"> \r\n      <image wx:if='{{haveBack}}' bindtap=\"_goBack\" class=\"floatL\" src=\"/img/navbar_back_white.png\"></image>      \r\n      <view wx:if='{{haveBack}}' class=\"floatL\"></view>\r\n      <image bindtap=\"_goHome\" src=\"/img/navbar_home_white.png\"></image>\r\n  </view>\r\n</view>\r\n<!-- 手写loading -->\r\n<view class=\"navbar-loading\" style='height:{{navbarHeight}}px;line-height:{{navbarHeight}}px;'>\r\n  <text>...</text>\r\n</view>复制代码为了适配不同手机屏幕，高度和胶囊按钮的位置都需要在html里面赋值，下面会详细的说明高度如何计算。在自定义导航栏组件中分为两部分，一个是顶部的导航栏另一个是自己写的loading。因为自定义导航栏是fixed到顶部的，为了保证不挡住下面的主体内容，我们需要在导航栏和主体内容之间添加一个跟导航栏相同的高度，class先叫做box。这样可以保证导航栏不挡着主体内容。但是会出现另一个问题，如果此页面支持下拉刷新，那么导航栏会把小程序原生的loading样式挡住，而在主体内容的前面会出现一个空白的box，虽说不影响使用，但是在用户看来会很奇怪，莫名其妙的多出来一块，box只有在loading结束后才会上去。所以在这里需要自己手写一个loading的动画效果放在组件的最底下，高度跟导航栏一样。可以看到下面的最终效果，蓝色导航条下面的三个点是小程序原生loading，再下面三个小点是自己写的loading。而我们想要的效果则是，当小程序原生的loading被当时，自己写的loading就可以替代原生的loadingheaderNavbar.js状态栏高度 = app.globalData.systeminfo.statusBarHeight需要注意胶囊位置信息的原点是在页面的左上角，所以需要转换一下，把原胶囊位置信息起名为胶囊，转换后的叫做现胶囊。/*** iphone6 的胶囊位置信息\r\n* wx.getMenuButtonBoundingClientRect() 坐标信息以屏幕左上角为原点\r\n* 胶囊宽度： 87\r\n* 胶囊高度： 32\r\n* 胶囊左边界坐标： 278\r\n* 胶囊上边界坐标： 26\r\n* 胶囊右边界坐标： 365\r\n* 胶囊下边界坐标： 58\r\n* 状态栏高度：20*/复制代码现胶囊上边距 = 胶囊上边界坐标 - 状态栏高度现胶囊右边距 = 屏幕宽度 - 胶囊右边界坐标现胶囊下边距 = 胶囊下边界坐标 - 胶囊高度 - 状态栏高度导航栏高度 = 胶囊下边界坐标 + 现胶囊下边距注意：胶囊下边界坐标包含了状态栏、胶囊高度和状态栏和胶囊高度之间的距离，因为胶囊是居中在导航栏里的，所以上边距与下边距应该一致，所以是\r\n胶囊下边界坐标 - 胶囊高度 - 状态栏高度。const app = getApp();\r\nComponent({\r\n  properties: {\r\n    navbarData: { // 由父页面传递的数据\r\n      type: Object,\r\n      value: {},\r\n      observer: function (newVal, oldVal) { }\r\n    }\r\n  },\r\n  data: {\r\n    haveBack: true, // 是否有返回按钮，true 有 false 没有 若从分享页进入则为 false\r\n    statusBarHeight: 0, // 状态栏高度\r\n    navbarHeight: 0, // 顶部导航栏高度\r\n    navbarBtn: { // 胶囊位置信息\r\n      height: 0,\r\n      width: 0,\r\n      top: 0,\r\n      bottom: 0,\r\n      right: 0\r\n    }\r\n  },\r\n  // 微信7.0.0支持wx.getMenuButtonBoundingClientRect()获得胶囊按钮高度\r\n  attached: function () {\r\n    let statusBarHeight = app.globalData.systeminfo.statusBarHeight // 状态栏高度\r\n    let headerPosi = app.globalData.headerBtnPosi // 胶囊位置信息\r\n    /**\r\n     * wx.getMenuButtonBoundingClientRect() 坐标信息以屏幕左上角为原点\r\n     * 菜单按键宽度： 87\r\n     * 菜单按键高度： 32\r\n     * 菜单按键左边界坐标： 278\r\n     * 菜单按键上边界坐标： 26\r\n     * 菜单按键右边界坐标： 365\r\n     * 菜单按键下边界坐标： 58\r\n     */\r\n    let btnPosi = { // 胶囊实际位置，坐标信息不是左上角原点\r\n      height: headerPosi.height,\r\n      width: headerPosi.width,\r\n      // 胶囊top - 状态栏高度\r\n      top: headerPosi.top - statusBarHeight,\r\n      // 胶囊bottom - 胶囊height - 状态栏height （现胶囊bottom 为距离导航栏底部的长度）\r\n      bottom: headerPosi.bottom - headerPosi.height - statusBarHeight,\r\n      // 屏幕宽度 - 胶囊right\r\n      right: app.globalData.systeminfo.screenWidth - headerPosi.right\r\n    }\r\n    let haveBack;\r\n    if (getCurrentPages().length === 1) { // 当只有一个页面时\r\n      haveBack = false;\r\n    } else {\r\n      haveBack = true;\r\n    }\r\n    this.setData({\r\n      haveBack: haveBack, // 获取是否是通过分享进入的小程序\r\n      statusBarHeight: statusBarHeight,\r\n      navbarHeight: headerPosi.bottom + btnPosi.bottom, // 原胶囊bottom + 现胶囊bottom\r\n      navbarBtn: btnPosi\r\n    })\r\n  },\r\n  methods: {\r\n    _goBack: function () {\r\n      wx.navigateBack({\r\n        delta: 1\r\n      });\r\n    },\r\n    _goHome: function () {\r\n      wx.switchTab({\r\n        url: '/pages/index/index',\r\n      });\r\n    }\r\n  }\r\n})\r\n复制代码通过 getCurrentPages() 来判断当前页面是否从分享页进入，因为如果从分享页进入页面栈中应该只有一条数据，在跳转到其他页面时页面栈的length则会增加，在其他页面就会显示出返回和首页按钮。 注意：微信7.0.0支持wx.getMenuButtonBoundingClientRect()，如果想兼容低版本的微信，只能把导航栏的高度写死，通过一些大佬的计算得出的高度：'iPhone': 64,'iPhone X': 88,'android': 68具体查看：https://developers.weixin.qq.com/community/develop/doc/0006c012dc8028f04b070dd0551004如果你使用wx.getMenuButtonBoundingClientRect()得到信息有小数，如下所示{height:\r\n24, width: 65.25, top: -0.5, bottom: -0.5, right: 101.25}那么你可能是把开发工具中的视图缩放了，还原成100%就正常了。headerNavbar.wxss.navbar-wrap {\r\n\tposition: fixed;\r\n\twidth: 100%;\r\n\ttop: 0;\r\n\tz-index: 9999999;\r\n\tbackground-color: #3281FF;\r\n\tbox-sizing: border-box;\r\n}\r\n\r\n.navbar-text {\r\n\ttext-align: center;\r\n\tfont-size: 36rpx;\r\n\tcolor: #fff;\r\n\tfont-weight: 600;\r\n}\r\n\r\n.navbar-icon {\r\n\tposition: fixed;\r\n\tdisplay: flex;\r\n\tborder-radius: 64rpx;\r\n\tborder: 0.5px solid rgba(255,255,255, 0.3);\r\n\tbox-sizing: border-box;\r\n}\r\n\r\n.navbar-icon image {\r\n\theight: 20px;\r\n\twidth: 20px;\r\n\tpadding: 5px 10px 10px;\r\n\tdisplay: inline-block;\r\n\toverflow: hidden;\r\n}\r\n\r\n.navbar-icon view {\r\n\theight: 18px;\r\n\tborder-left: 0.5px solid rgba(255,255,255, 0.3);\r\n\tmargin-top: 6px;\r\n}\r\n\r\n.navbar-loading {\r\n\tbackground: #fff;\r\n\ttext-align: center;\r\n}\r\n复制代码引用组件页面代码navigationStyle.json{\r\n    \"navigationStyle\": \"custom\", \r\n    \"enablePullDownRefresh\": true, \r\n    \"backgroundTextStyle\": \"light\", \r\n    \"usingComponents\": {\r\n        \"headerNavbar\": \"/components/headerNavbar/headerNavbar\"\r\n    }\r\n}\r\n复制代码先在需要使用自定义导航栏的页面json中添加navigationStyle:customenablePullDownRefresh:\r\ntrue         开启下拉刷新backgroundTextStyle: light是把loading的样式改成白色，这样就不会显示出来loading的三个点navigationStyle.wxml<headernavbar navbar-data=\"{{nvabarData}}\"></headernavbar> \r\n<view class=\"home-page\"> \r\n   <text>\r\n    上面是自定义导航栏↑↑↑\r\n   </text> \r\n   <text>\r\n    下面是主体内容↓↓↓\r\n   </text> \r\n   <navigator url=\"./testPage\">\r\n    跳转到测试页\r\n   </navigator> \r\n</view>\r\n复制代码navigationStyle.jsPage({\r\n    data: {\r\n        // 组件所需的参数\r\n        nvabarData: {\r\n            showCapsule: 1,\r\n            // 是否显示左上角胶囊按钮 1 显示 0 不显示\r\n            title: '组件列表' // 导航栏 中间的标题\r\n        }\r\n    },\r\n\r\n    onPullDownRefresh() {\r\n        setTimeout(() = >{\r\n            wx.stopPullDownRefresh(); // 停止下拉\r\n        },\r\n        2000);\r\n    },\r\n\r\n})\r\n复制代码注意：虽说这么做在小程序开发工具中看起来都是对的，得到的导航栏高度也是64px但是在真机上测试后，还是有偏差，在iphone8 plus上高度是60px。可以通过这张图明显看到差了几px，如果你是单独几个页面使用自定义导航，细心的用户可能会发现，但是基本不影响。如果是全局使用自定义导航，那就不存在这个问题了。项目代码：https://github.com/Shay0921/header-navbar.git"}
{"title": "小程序模板和组件的使用和区别 ", "author": "Rolan", "put_time": "2019-6-14 00:53", "content": "不得不说微信小程序的官方文档还是有很多坑啊(⊙﹏⊙)使用模板和组件的目的：实现代码复用template（模板）相对于component而言，template更加轻量级，它的功能有限，主要是用于展示。模板只有两个以.wxml 和.wxss结尾的文件定义模板新建一个与pages同级的文件夹 => templates,在templates下创建templateItem文件夹，然后在这个文件夹里创建同名的.wxml和.wxss的文件使用name属性，作为模板的名字，然后在<template/> 内定义代码片段，template必须要写templateItem.wxml :<template name=\"msgItem\">    \r\n    <view class=\"content\">我是模板的内容</view>\r\n</template>复制代码可以在templateItem.wxss中添加一些好看的样式.content {   \r\n    width: 100%;    \r\n    height: 400rpx;   \r\n    background-color: yellowgreen;    \r\n    display: flex;    \r\n    justify-content: center;    \r\n    align-items: center;\r\n}复制代码接下来就可以在页面中使用模板了使用模板要使用模板，首先得在要使用的页面引入模板，使用import标签导入，使用is属性，声明需要使用的模板，比如在index.wxml中使用：index.wxml :<!-- index.wxml -->\r\n<import src=\"../../templates/templateItem/templateItem.wxml\" />\r\n<view>    \r\n    <template is=\"msgItem\" />\r\n</view>复制代码注意： import标签不能省略  /,不然会报错现在，模板的内容可以显示在页面上了，但是模板的样式却没有生效。想要让样式生效，必须在index.wxss 中引入模板的样式文件：/** index.wxss **/\r\n/** 如果下面还有样式 这里的分号不能省略 **/\r\n@import \"../../templates/templateItem/templateItem.wxss\";复制代码现在，模板的颜色也出来啦~                            到这里，一个最简单的模板就完成了模板传值模板除了可以写代码片段外，is属性可以使用Mustache语法，来动态决定具体需要渲染哪个模板在index.js中的data中添加一些数据，// index.js​\r\n//获取应用实例\r\ncosnt app = getApp()​;\r\nPage({    \r\n    data: {    \r\n        hero: {  \r\n             name: '盖伦'，\r\n             profession： '战士',\r\n             skill: '得玛西亚正义' \r\n       }\r\n    }\r\n})复制代码修改一下模板：<template name=\"msgItem\">\r\n    <view class=\"content\">\r\n        <view class=\"content\">我是模板的内容</view>\r\n        <view>            \r\n            <text>{{ name }}</text>---            \r\n            <text>{{ professios }}</text>---            \r\n            <text>{{ skill }}</text>        \r\n         </view>   \r\n    </view>\r\n</template>复制代码在模板原理的样式基础上中增加：flex-direction: column;复制代码保存并运行，此时，就多了好多内容了(#^.^#)                                     模板的作用域模板拥有自己的作用域，只能使用data 传入的数据以及模板文件中定义的<wxs />模块component（组件）从小程序基础库版本 1.6.3 开始，小程序支持简洁的组件化编程。所有自定义组件相关特性都需要基础库版本 1.6.3 或更高。开发者可以将页面内的功能模块抽象成自定义组件，以便在不同的页面中重复使用；也可以将复杂的页面拆分成多个低耦合的模块，有助于代码维护。自定义组件在使用时与基础组件非常相似。自定义组件在pages的同级目录下创建components文件夹类似于页面，一个自定义组件由json wxml wxss js 4个文件组成。要编写一个自定义组件，首先需要在json文件中进行自定义组件声明（将component字段设为true)，使用微信开发者工具，创建component会自动生成。{    \"component\": true}复制代码在组件文件中编写一些看起来很厉害的代码<!-- 这是自定义组件内部的内容 -->\r\n<view class=\"herocontainer\">    \r\n    <view>姓名：{{ hero.name }}</view>    \r\n    <view>职业：{{ hero.profession }}</view>    \r\n    <view>技能：{{ hero.skill }}</view>\r\n</view>复制代码在自定义组件的js文件中，需要使用 Component 来注册组件，并提供组件的属性定义、内部数据和自定义方法// 这是自定义组件内部的js文件\r\nComponent({    \r\n    properties: {        \r\n        // hero收一个对象        \r\n        hero: Object    \r\n    },    \r\n    data: {   \r\n        //这里是一些组件内部数据   \r\n    },    \r\nmethods： {        \r\n    //这里是自定义方法    \r\n}})复制代码也给它添加一些看起来很厉害的样式/** 这是自定义组件内部的wxss文件 **/\r\n.herocontainer {    \r\n    width: 750rpx;    \r\n    height: 200rpx;    \r\n    background-color: yellow;    \r\n    color: hotpink;\r\n}复制代码注意：在组件wxss中不应该使用ID选择器、属性选择器和标签名选择器自定义组件中，写了wxss和 js，使用时无需在页面中导入，只需导入组件即可使用自定义组件使用自定义组件前，首先要在要使用的页面的json文件中进行引用声明，此时需要提供每个自定义组件的标签名和对应的自定义组件文件路径{    \r\n    \"usingComponents\": { \r\n      \"my-component\": \"../../components/mycomponent/mycomponent\"    \r\n    }\r\n}复制代码这样，在页面的wxml 中就可以像使用基础组件一样使用自定义组件啦，节点名就是自定义组件的标签名，节点属性就是自定义组件的属性值<view>    \r\n    <my-component hero=\"{{hero }}\" />\r\n</view>复制代码黄色部分为组件的内容：            自定义组件传值页面 ----->  组件\t组件中通过proprtties写上要接受的值\t页面通过属性名称和值的方式传递上面就是页面传值到组件组件 -----> 页面\t页面中写监听事件\t组件中写触发事件在自定义组件中添加一个事件<button bindtap=\"onTap\">点击按钮触发事件</button>复制代码在组件的js文件methods中添加方法,通过this.triggerEvent()给也面传值，在data中定义一个数据用来传给页面data: { \r\n    message: '欢迎来到英雄联盟'  \r\n},\r\nonTap(){    \r\n    const message = this.data.message    \r\n    this.triggerEvent('myevent',message)\r\n}复制代码在页面的js中，添加一个与data同级的方法，通过事件对象的e.detail拿到传过来的值Page({    \r\n    onMyEvent(e){ \r\n       console.log(e.detail)    \r\n    }\r\n})复制代码在页面中绑定事件<my-component hero=\"{{ hero }}\" bindmyevent=\"onMyEvent\" />复制代码点击按钮之后，控制台会输出组件传过来的值不出意外就是 ==>  欢迎来到英雄联盟 注意坑点因为wxml节点标签只能是小写字母、中划线和下划线组合，自定义组件也只能是这样自定义组件也是可以引用自定义组件的，引用方法类似于页面引用自定义组件的方式自定义组件和页面所在项目根目录名不能以wx-为前缀，否则会报错总结template 和 components 的共性： 不能单独呈现出来，必须依附显示在页面不同点：template比较轻量级，没有自己的逻辑处理能力，只能来着页面显示值组件要重量级一些，它有自己的逻辑处理能力"}
{"title": "一种让小程序支持JSX语法的新思路 ", "author": "Rolan", "put_time": "2019-6-17 00:01", "content": "React 社区一直在探寻使用 React 语法开发小程序的方式，其中比较著名的项目有 Taro ， nanachi 。而使用 React 语法开发小程序的难点主要就是在 JSX 语法上， JSX 本质上是 JS ，相比于小程序静态模版来说太灵活。本文所说的新思路就是在处理 JSX 语法上的新思路，这是一种更加动态的处理思路，相比于现有方案，基本上不会限制任何 JSX 的写法，让你以 真正的React方式 处理小程序，希望这个新思路可以给任何有志于用 React 开发小程序的人带来启发。现有思路的局限在介绍新的思路之前，我们先来看下 Taro（最新版1.3） ， nanachi 是怎么在小程序端处理 JSX 语法的。简单来说，主要是通过在 编译阶段 把 JSX 转化为等效的小程序 wxml 来把 React代码运行在小程序端的。举个例子，比如 React 逻辑表达式：xx && <Text>Hello</Text>将会被转化为等效的小程序wx:if指令：<Text wx:if=\"{{xx}}\">Hello</Text>这种方式把对 JSX 的处理，主要放在了 编译阶段 ，他依赖于 编译阶段 的 信息 收集，以上面为例，它必须识别出逻辑表达式，然后做对应的 wx:if 转换处理。那 编译阶段 有什么问题和局限呢？我们以下面的例子说明：class App extends React.Component {\r\n    render () {\r\n        const a = <Text>Hello</Text>\r\n        const b = a\r\n\r\n        return (\r\n            <View>\r\n                {b}\r\n            </View>\r\n        )\r\n    }\r\n}首先我们声明 const a = <Text>Hello</Text> ，然后把 a 赋值给了 b ，我们看下最新版本 Taro 1.3 的转换，如下图：这个例子不是特别复杂，却报错了。要想理解上面的代码为什么报错，我们首先要理解 编译阶段 。本质上来说在编译阶段，代码其实就是‘字符串’，而 编译阶段 处理方案，就需要从这个‘字符串’中分析出必要的信息（通过 AST，正则等方式）然后做对应的等效转换处理。而对于上面的例子，需要做什么等效处理呢？需要我们在 编译阶段 分析出 b 是 JSX 片段： b = a = <Text>Hello</Text> ，然后把 <View>{b}</View> 中的 {b} 等效替换为 <Text>Hello</Text> 。然而在 编译阶段 要想确定 b 的值是很困难的，有人说可以往前追溯来确定b的值，也不是不可以，但是考虑一下 由于 b = a ，那么就先要确定 a 的值，这个 a 的值怎么确定呢？需要在 b 可以访问到的作用域链中确定 a ，然而 a 可能又是由其他变量赋值而来，循环往复，期间一旦出现不是简单赋值的情况，比如函数调用，三元判断等运行时信息，追溯就宣告失败，要是 a 本身就是挂在全局对象上的变量，追溯就更加无从谈起。所以在 编译阶段 是无法简单确定 b 的值的。我们再仔细看下上图的报错信息： a is not defined 。为什么说 a 未定义呢？这是涉及到另外一个问题，我们知道 <Text>Hello</Text> ，其实等效于 React.createElement(Text, null, 'Hello') ，而 React.createElement 方法的返回值就是一个普通 JS 对象，形如// ReactElement对象\r\n{\r\n   tag: Text,\r\n   props: null,\r\n   children: 'Hello'\r\n   ...\r\n}所以上面那一段代码在 JS 环境真正运行的时候，大概等效如下：class App extends React.Component {\r\n    render () {\r\n        const a = {\r\n            tag: Text,\r\n            props: null,\r\n            children: 'Hello'\r\n            ...\r\n        }\r\n        const b = a\r\n\r\n        return {\r\n            tag: View,\r\n            props: null,\r\n            children: b\r\n            ...\r\n        }\r\n    }\r\n}但是，我们刚说了编译阶段需要对 JSX 做等效处理，需要把 JSX 转换为 wxml ，所以 <Text>Hello</Text> 这个 JSX 片段被特殊处理了， a 不再是一个普通 js 对象，这里我们看到 a 变量甚至丢失了，这里暴露了一个很严重的问题： 代码语义被破坏了 ，也就是说由于编译时方案对 JSX 的特殊处理，真正运行在小程序上的代码语义并不是你的预期。这个是比较头疼。新的思路正因为 编译时 方案，有如上的限制，在使用的时候常常让你有“我还是在写 React 吗？”这种感觉。下面我们介绍一种全新的处理思路，这种思路在小程序运行期间和真正的 React 几无区别，不会改变任何代码语义， JSX 表达式只会被处理为 React.createElement 方法调用，实际运行的时候就是普通 js 对象，最终通过其他方式渲染出小程序视图。下面我们仔细说明一下这个思路的具体内容。第一步：给每个独立的 JSX 片段打上唯一标识 uuid ，假定我们有如下代码：const a = <Text uuid=\"000001\">Hello</Text>\r\n\r\nconst y = <View uuid=\"000002\">\r\n    <Image/>\r\n    <Text/>\r\n</View>我们给 a 片段， y 片段 添加了 uuid 属性第二步：把 React 代码通过 babel 转义为小程序可以识别的代码，例如 JSX 片段用等效的 React.createElement 替换等const a = React.createElement(Text, {\r\n  uuid: \"000001\"\r\n}, \"Hello\");第三步：提取每个独立的 JSX 片段，用小程序 template 包裹，生成 wxml 文件<template name=\"000001\">\r\n    <Text>Hello</Text>\r\n</template>\r\n\r\n<template name=\"000002\">\r\n    <View uuid=\"000002\">\r\n        <Image/>\r\n        <Text/>\r\n    </View>\r\n</template>\r\n\r\n\r\n<!--占位template-->\r\n<template is=\"{{uiDes.name}}\" data=\"{{...uiDes}}\"/>注意这里每一个 template 的 name 标识和 JSX 片段的唯一标识 uuid 是一样的。最后，需要在结尾生成一个占位模版： <template is=\"{{uiDes.name}}\" data=\"{{...uiDes}}\"/> 。第四步：修改 ReactDOM.render 的递归（ React 16.x 之后，不在是递归的方式）过程，递归执行阶段，聚合 JSX 片段的 uuid 属性，生成并返回 uiDes 数据结构。第五步：把第四步生成的 uiDes ，传递给小程序环境，小程序把 uiDes 设置给占位模版 <template is=\"{{uiDes.name}}\" data=\"{{...uiDes}}\"/> ，渲染出最终的视图。我们以上面的 App 组件的例子来说明整个过程，首先 js 代码会被转义为：class App extends React.Component {\r\n    render () {\r\n        const a = React.createElement(Text, {uuid: \"000001\"}, \"Hello\");\r\n        const b = a\r\n        \r\n        return (\r\n          React.createElement(View, {uuid: \"000002\"} , b);\r\n        )\r\n      }\r\n}同时生成 wxml 文件：<template name=\"000001\">\r\n    <Text>Hello</Text>\r\n</template>\r\n\r\n<template name=\"000002\">\r\n    <View>\r\n        <template is=\"{{child0001.name}}\" data=\"{{...child0001}}\"/>\r\n    </View>\r\n</template>\r\n\r\n<!--占位template-->\r\n<template is=\"{{uiDes.name}}\" data=\"{{...uiDes}}\"/>使用我们定制之后 render 执行 ReactDOM.render(<App/>, parent) 。在 render 的递归过程中，除了会执行常规的创建组件实例，执行生命周期之外，还会额外的收集执行过程中组件的 uuid 标识，最终生成 uiDes 对象const uiDes = {\r\n    name: \"000002\",\r\n    \r\n    child0001: {\r\n           name: 000001,\r\n           ...\r\n   }\r\n   \r\n   ...\r\n}小程序获取到这个 uiDes ，设置给占位模版 <template is=\"{{uiDes.name}}\" data=\"{{...uiDes}}\"/> 。 最终渲染出小程序视图。在这整个过程中，你的所有 JS 代码都是运行在 React过程 中的， 语义完全一致 ， JSX 片段也不会被任何特殊处理，只是简单的 React.createElement 调用，另外由于这里的 React过程 只是纯 js 运算，执行是非常迅速的，通常只有几ms。最终会输出一个 uiDes 数据到小程序，小程序通过这个 uiDes 渲染出视图。现在我们在看之前的赋值 const b = a ，就不会有任何问题了，因为 a 不过是普通对象。另外对于常见的 编译时方案的限制 ，比如任意函数返回 JSX 片段，动态生成 JSX 片段， for 循环使用 JSX 片段等等，都可以完全解除了，因为 JSX 片段只是 js 对象，你可以做任何操作，最终 ReactDOM.render 会搜集所有 执行结果的片段 的 uuid 标识，生成 uiDes ，而小程序会根据这个 uiDes 数据结构渲染出最终视图。可以看出这种新的思路和以前 编译时 方案还是有很大的区别的，对 JSX 片段的处理是动态的，你可以在任何地方，任何函数出现任何 JSX 片段, 最终执行结果会确定渲染哪一个片段，只有执行结果的片段的 uuid 会被写入 uiDes 。这和 编译时 方案的静态识别有着本质的区别。结语\"Talk is cheap. Show me your code！\" 这仅仅是一个思路？还是已经有落地完整的实现呢？是有完整的实现的， alita 项目在处理 JSX 语法的时候，采用的就是这个思路，这也是 alita 基本不限制写法却可以转化整个React Native项目的原因，另外 alita 在这个思路上做了很多优化。如果对这个思路的具体实现有兴趣，可以去研读一下 alita 源码，它完全是开源的 https://github.com/areslabs/alita 。当然，你也可以基于这个思路，构造出自己的 React小程序开发方案 。"}
{"title": "微信小程序常用样式汇总 ", "author": "Rolan", "put_time": "2019-6-17 00:13", "content": "小程序特点：用完即走、低频使用、性能要求低，不支持webview；以iphone6尺寸（750*1334）为视觉稿进行设计；iphone6下1px=1rpx=0.5pt     iphone6 plux下1px=0.6rpx；使用rpx，小程序会自动在不同的分辨率下进行转换，而使用px为单位不会；1.设置全局字体样式app.wxss：text{\r\nfont-family:MicroSoft yahei;\r\n}2.设置弹性盒子模型：.container{\r\n/*弹性模型*/\r\ndisplay:flex;\r\n/*垂直方向 列方向 排布*/\r\nflex-direction:column;\r\n/*居中*/\r\nalign-items:center;\r\n/*要从整体解决排布的问题是最好的方案*/\r\n}3.设置页面全屏样式及背景色：page{\r\nheight:100%;\r\nbackground:#b3d4db;\r\n}4.全局设置导航条颜色app.json：\"window\": {\r\n\"navigationBarBackgroundColor\": \"#405f80\"\r\n}5.页面设置导航条颜色和标题*.json:{\r\n\"navigationBarBackgroundColor\": \"#405f80\",\r\n\"navigationBarTitleText\":\"文与字\"\r\n}6.设置字体属性：.user-name{\r\nfont-size:32rpx;\r\nfont-weight:bold;\r\n}7.创建圆角矩形边框：.moto-container{\r\nborder:1px solid #405f80;\r\nwidth:200rpx;\r\nheight:80rpx;\r\nborder-radius:5rpx;\r\ntext-align:center;\r\n}8.外边距设置：margin-top:20rpx;\r\nmargin-bottom:40rpx;9.内边距设置：padding-bottom:20rpx;10.上、下边线设置：border-bottom:1px solid #ededed;\r\nborder-top:1px solid #ededed;11.文字间距设置：letter-spacing:2rpx;12.垂直居中（此元素放置在父元素的中部）：vertical-align: middle; 13.设置子元素Image样式：.circle-img image{\r\n    width:90rpx;\r\n    height: 90rpx\r\n}14.最底层垂直居中横线样式：.horizon{\r\n    width:660rpx;\r\n    height: 2rpx;\r\n    background-color: #e5e5e5;\r\n    vertical-align: middle;\r\n    position:relative;\r\n    top:46rpx;\r\n    margin: 0 auto;\r\n    z-index: -99\r\n}15.图片居中覆盖:.audio{\r\n    width:102rpx;\r\n    height:110rpx;\r\n    position: absolute;\r\n    left: 50%;\r\n    margin-left: -51rpx;//经典水平居中方式\r\n    top:180rpx;\r\n    margin-top: 20rpx;\r\n    opacity:0.6;//透明度\r\n}"}
{"title": "小程序多图上传并压缩,带预览删除功能 ", "author": "Rolan", "put_time": "2019-6-17 00:42", "content": "<view class=\"upload_view\">　　<block wx:for=\"{{pics}}\" wx:key=\"*this\">\r\n　　　　<view class=\"q_image_wrap\">\r\n　　　　　　<!-- 图片缩略图  -->\r\n　　　　　　<image class=\"q_image\" src=\"{{item}}\" mode=\"aspectFill\" data-idx=\"{{index}}\" bindtap=\"handleImagePreview\"></image>\r\n　　　　　　<!-- 移除图片的按钮  -->\r\n　　　　　　<view class=\"q_image_remover\" data-idx=\"{{index}}\" bindtap=\"removeImage\">\r\n　　　　　　　　<i-icon type=\"close\" size=\"14\" class=\"icon\" />\r\n　　　　　　</view>\r\n　　　　</view>　　</block>\r\n　　<view class='uploadImg_btn' bindtap=\"chooseImage\" wx:if=\"{{pics.length < 9}}\">\r\n　　　　<image src=\"../../img/upload.png\"></image>\r\n　　</view>\r\n</view> //选择图片\r\n    chooseImage(e) {\r\n        console.log(e)\r\n        var that = this;\r\n        var pics = this.data.pics;\r\n        //---------------------多张上传----------------------------------------------------------------------------------------\r\n        wx.chooseImage({\r\n            count: 9 - pics.length, // 最多可以选择的图片张数，默认9\r\n            sizeType: ['original', 'compressed'], // original 原图，compressed 压缩图，默认二者都有\r\n            sourceType: ['album', 'camera'], // album 从相册选图，camera 使用相机，默认二者都有\r\n            success: function (photo) {\r\n                //图片大小，限制10M以内\r\n                for (var i = 0; i < photo.tempFiles.length; i++) {\r\n                    if (photo.tempFiles[i].size >= 10 * 1024 * 1024) {\r\n                        console.log('请上传10M以内的图片');\r\n                        return;\r\n                    }\r\n                }\r\n                var imgsrc = photo.tempFilePaths;\r\n                //页面上展示的是原图片========pics数组\r\n                pics = pics.concat(imgsrc);\r\n                that.setData({\r\n                    pics: pics\r\n                });\r\n                console.log(that.data.pics)\r\n                that.getCanvasImg(0, 0, photo.tempFilePaths);  //进行压缩\r\n            },\r\n            fail: function () {\r\n                // fail\r\n            },\r\n            complete: function () {\r\n                // complete\r\n            }\r\n        })\r\n    }, //压缩并获取图片，这里用了递归的方法来解决canvas的draw方法延时的问题\r\n    getCanvasImg: function (index, failNum, tempFilePaths) {\r\n        var that = this;\r\n        let imagesPress = that.data.imagesPress;\r\n        if (index < tempFilePaths.length) {\r\n            wx.getImageInfo({\r\n                src: tempFilePaths[index],\r\n                success: function (res) {\r\n                    //---------利用canvas压缩图片--------------\r\n                    var ratio = 2;\r\n                    var canvasWidth = res.width //图片原始长宽\r\n                    var canvasHeight = res.height\r\n                    while (canvasWidth > 400 || canvasHeight > 400) {// 保证宽高在400以内\r\n                        canvasWidth = Math.trunc(res.width / ratio)\r\n                        canvasHeight = Math.trunc(res.height / ratio)\r\n                        ratio++;\r\n                    }\r\n                    that.setData({\r\n                        canvasWidth: canvasWidth,\r\n                        canvasHeight: canvasHeight,\r\n                    })\r\n                    const ctx = wx.createCanvasContext('photo_canvas');\r\n                    ctx.drawImage(tempFilePaths[index], 0, 0, canvasWidth, canvasHeight);\r\n                    ctx.draw(false, function () {\r\n                        index = index + 1;//上传成功的数量，上传成功则加1\r\n                        wx.canvasToTempFilePath({\r\n                            canvasId: 'photo_canvas',\r\n                            success: function success(res) {\r\n                                console.log('最终图片路径' + res.tempFilePath)//最终图片路径\r\n                                imagesPress.push(res.tempFilePath);\r\n                                console.log(that.data.imagesPress)\r\n                                that.setData({\r\n                                    imagesPress: imagesPress\r\n                                })\r\n                                that.uploadCanvasImg(res.tempFilePath);\r\n                                that.getCanvasImg(index, failNum, tempFilePaths);\r\n                            }, fail: function (e) {\r\n                                failNum += 1;//失败数量，可以用来提示用户\r\n                                that.getCanvasImg(inedx, failNum, tempFilePaths);\r\n                            }\r\n                        });\r\n                    });\r\n                }\r\n            })\r\n\r\n        }\r\n    },//上传图片\r\n    uploadCanvasImg: function (canvasImg) {\r\n        const {$Toast} = require('../../dist/base/index');\r\n        var that = this;\r\n        let attachmentId = that.data.attachmentId\r\n        var tempImg = canvasImg;\r\n        wx.showLoading({\r\n            title: '上传中...',\r\n        });\r\n        wx.uploadFile({\r\n            url: app.globalData.baseUrl + '/api/upload',//文件服务器的地址\r\n            filePath: tempImg,\r\n            header: {\r\n                'Content-type': 'multipart/form-data',\r\n                'token': wx.getStorageSync('token')\r\n            },\r\n            // formData: {\r\n            // },\r\n            name: 'file',\r\n            success: function (res) {\r\n                wx.hideLoading()\r\n                $Toast({\r\n                    content: '上传成功！'\r\n                });\r\n                console.log(res)\r\n            }\r\n        })\r\n    },//删除图片\r\n    removeImage(e) {\r\n        var that = this;\r\n        var pics = that.data.pics;\r\n        var imagesPress = that.data.imagesPress;\r\n        // 获取要删除的第几张图片的下标\r\n        const idx = e.currentTarget.dataset.idx\r\n        // splice  第一个参数是下表值  第二个参数是删除的数量\r\n        pics.splice(idx, 1)\r\n        imagesPress.splice(idx, 1)\r\n        this.setData({\r\n            pics: pics,\r\n            imagesPress: imagesPress\r\n        })\r\n        console.log(that.data.imagesPress)\r\n    },\r\n    //预览图片\r\n    handleImagePreview(e) {\r\n        const idx = e.target.dataset.idx\r\n        const pics = this.data.pics\r\n        wx.previewImage({\r\n            current: pics[idx],  //当前预览的图片\r\n            urls: pics,  //所有要预览的图片\r\n        })\r\n    },"}
{"title": "页面可见与不可见的事件——visibilitychange ", "author": "Rolan", "put_time": "2019-7-15 00:23", "content": "需求背景在最近的项目中，使用了transition和定时器实现了随机走动物体的功能，走动的物体还会有animation的动画。我发现在手机中，按home键或者切换应用，使页面不在屏幕中，也就是页面不可见，过一段时间切回来，会出现物体移动但是没有播放animaiton的动画的情况。我就想到了visibilitychange。结合react使用，添加类似onShow/onHide生命周期额外生命周期浏览器document有个visibilitychange的事件，由于存在兼容性问题，所以代码里也做了兼容处理。该事件会在document.visibilityState发生变化时触发，visibilityState有两个状态值——visible和hidden，表示页面是否在屏幕当中。let changeState;\r\nlet visibilityChange;\r\n\r\nif (typeof document.hidden !== 'undefined') {\r\n    visibilityChange = 'visibilitychange';\r\n    changeState = 'visibilityState';\r\n} else if (typeof document.mozHidden !== 'undefined') {\r\n    visibilityChange = 'mozvisibilitychange';\r\n    changeState = 'mozVisibilityState';\r\n} else if (typeof document.msHidden !== 'undefined') {\r\n    visibilityChange = 'msvisibilitychange';\r\n    changeState = 'msVisibilityState';\r\n} else if (typeof document.webkitHidden !== 'undefined') {\r\n    visibilityChange = 'webkitvisibilitychange';\r\n    changeState = 'webkitVisibilityState';\r\n}知道了当前浏览器的状态属性和事件名称后，就可以添加时间监听了。const visibleCallbackList = [];\r\nconst hiddenCallbackList = [];\r\n\r\ndocument.addEventListener(\r\n    visibilityChange,\r\n    () => {\r\n        if (document[changeState] === 'visible') {\r\n            for (let i = 0; i < visibleCallbackList.length; i++) {\r\n                if (typeof visibleCallbackList[i] === 'function') {\r\n                    visibleCallbackList[i]();\r\n                }\r\n            }\r\n        } else if (document[changeState] === 'hidden') {\r\n            for (let i = 0; i < hiddenCallbackList.length; i++) {\r\n                if (typeof hiddenCallbackList[i] === 'function') {\r\n                    hiddenCallbackList[i]();\r\n                }\r\n            }\r\n        }\r\n    },\r\n    false\r\n);上述代码中，维护了两个数组，分别代表页面进入可见状态时需要执行的回调列表和进入不可见状态时需要执行的回调列表。这两个列表在下面会讲到。因为我们是使用react开发，所以想在组件级别做到该组件是否能使用该功能，所以想到让组件具有类似小程序的onShow和onHide的生命周期，在这个生命周期中执行组件内部的逻辑。export const h5OnShow = callback => {\r\n    visibleCallbackList.push(callback);\r\n};\r\n\r\nexport const h5OnHide = callback => {\r\n    hiddenCallbackList.push(callback);\r\n};\r\n\r\n/**\r\n *\r\n * @param {Object}\r\n *   {Function} h5OnShowCallback h5需要注销的显示回调\r\n *   {Function} h5OnHideCallback h5需要注销的隐藏回调\r\n */\r\nexport const h5ExtraLifecycleWillUnmount = ({ h5OnShowCallback, h5OnHideCallback }) => {\r\n    if (h5OnShowCallback) {\r\n        visibleCallbackList.splice(visibleCallbackList.indexOf(h5OnShowCallback), 1);\r\n    }\r\n    if (h5OnHideCallback) {\r\n        hiddenCallbackList.splice(hiddenCallbackList.indexOf(h5OnHideCallback), 1);\r\n    }\r\n\r\n};如上述代码中，h5OnShow方法中将传入的callback push至visibleCallbackList数组，h5OnHide方法将callback push到hiddenCallbackList。h5ExtraLifecycleWillUnmount是在组件即将要卸载的时候调用，将回调列表里的方法删除。额外生命周期的使用componentDidMount() {\r\n        h5OnShow(this.pageShow);\r\n        h5OnHide(this.pageHide);\r\n    }\r\n    componentWillUnmount() {\r\n        h5ExtraLifecycleWillUnmount({\r\n            h5OnShowCallback: this.pageShow,\r\n            h5OnHideCallback: this.pageHide\r\n        });\r\n    }\r\n    pageShow = () => {\r\n        // 开启随机走动定时器\r\n    }\r\n    pageHide = () => {\r\n        // 关闭随机走动定时器\r\n    }在组件里，注册onSHow和onHide，在页面显示时开启定时器，在页面隐藏时关闭定时器并把transition设置为none，这样在页面不可见时不会做无用的逻辑处理，这也是符合用户的预期，因为页面隐藏时并不关心在这期间做了生命动画变更。可优化点：1.visibleCallbackList和hiddenCallbackList使用WeakSet更好，保证了不会出现内存泄漏。2.如果组件实例化多次，pageShow和pageHide使用箭头函数并不友好，可使用修饰器模式改变原型上的方法的this指向。"}
{"title": "小程序如何在其他页面监听globalData中值的变化？ ", "author": "Rolan", "put_time": "2019-7-15 00:45", "content": "前言这几天去面试，多次碰到同一个知识点。而且有一次面试挺有趣的，是关于小程序的。共有3个问题。1、小程序中Page.watch()方法是做什么用的？2、小程序中如何在其他页面中监听到globalData中值的变化？3、如果在app.js执行登录部分的代码，由于时序问题，如何处理其他页面请求时未获取到身份识别标记的情况。（session，userid等）。（大意是：怎么能够保证其他页面请求是在登录之后？）知识点有经验的同学可能一下子就看出来了，这其实说的是同一个东西，那就是Object.defineproperty()这个方法。下面我来尝试回答一下：第一题：小程序中并没有Page.watch()方法，但其实这里面试官的要问的东西就是第二题的题目，也就是属性监听器。第二题：由于要监听到globalData中的值的变化，所以一般要在globalData改变时回调一个方法。例如我们监听一个name属性，大致代码如下：// app.js中//app.jsApp({  onLaunch: function () {    let that = this    // 在这里用定时器模拟网络请求的过程    setTimeout(function(){      that.globalData.name = 'pxh'    },3000)   }, // 这里这么写，是要在其他界面监听，而不是在app.js中监听，而且这个监听方法，需要一个回调方法。  watch:function(method){    var obj = this.globalData;    Object.defineProperty(obj,\"name\", {      configurable: true,      enumerable: true,      set: function (value) {        this._name = value;        console.log('是否会被执行2')        method(value);      },      get:function(){      // 可以在这里打印一些东西，然后在其他界面调用getApp().globalData.name的时候，这里就会执行。        return this._name      }    })  },  globalData: {    userInfo: null,    _name:'msr'  }})  // 然后在index.js中的声明周期中实现onLoad: function (options) {    let that = this;    getApp().watch(that.watchBack)  },  watchBack: function (name){    console.log(22222);    console.log('this.name==' + name)  }看看执行效果（可以看到，我们在其他界面完美实现了监听到globalData的变化）image.png第三题：emmm。第二题的答案就是第三题的答案啦。我们可以在index.js中的回调方法中再进行网络请求，请求需要识别身份的资源。"}
{"title": "微信小程序全局变量改变监听 ", "author": "Rolan", "put_time": "2019-7-15 00:58", "content": "问题来源最近工作需要写小程序页面，其中有个页面情况为：父页面中包含了一个组件页面，组件页面中又包含了另外一个组件页面。需求为：点击最后一个组件页面中的一个view，需要显示最外层父页面中的一个弹出层，并且动态的展示值，这个值的来源就是最后一个组件页面中的内容。处理办法当时想到的就是使用全局变量，在 app.js 中定义好全局变量，点击组件页面时就修改全局变量的值，父页面同样使用全局变量的值，这样一来就可以动态打开/关闭弹出层且传递值了。下面先看看 app.js 中怎么定义的：globalData: {\r\n    openid: '',\r\n    userInfo: null,\r\n    _showPictureDetail: false,\r\n    _pictureTime: '',\r\n    _pictureAddress: '',\r\n    //改变量用户存放全局变量修改过程中的值传递, 传递对象\r\n    data: {}\r\n  }在其他页面就使用 getApp().globalData.参数名 = 值 的形式来改变参数值， 使用 getApp().globalData.参数名 的形式来获取值。这样能正常赋值，但是由于都是在同一个界面展示，我需要更新值后，马上得到最新的值。上面简单的设置获取就不起作用了。那么，就需要监听 globalData 中的属性了。首先是 app.js：//app 全局属性监听\r\n  watch: function (method) {\r\n    var obj = this.globalData;\r\n    Object.defineProperty(obj, \"data\", {  //这里的 data 对应 上面 globalData 中的 data\r\n      configurable: true,\r\n      enumerable: true,\r\n      set: function (value) {  //动态赋值，传递对象，为 globalData 中对应变量赋值\r\n        this._showPictureDetail = value.showPictureDetail;\r\n        this._pictureTime = value.pictureTime;\r\n        this._pictureAddress = value.pictureAddress;\r\n        method(value);\r\n      },\r\n      get: function () {  //获取全局变量值，直接返回全部\r\n        return this.globalData;\r\n      }\r\n    })\r\n  },接下来就是在组件页面事件中动态赋值：//图片拍摄详情查看\r\n    viewPictureDetailInfo: function (e) {\r\n      // 修改 app 全局属性值， 由于 globalData.data 是个对象，因为涉及到修改多个参数，所以需要传递对象\r\n      app.globalData.data = {\r\n        '_showPictureDetail': true,\r\n        '_pictureTime': e.currentTarget.dataset.phototime,\r\n        '_pictureAddress': e.currentTarget.dataset.address\r\n      }\r\n    },最后就是在最外层父页面添加 app.js 监听回调，动态修改变量值，以达到动态打开/关闭弹出层和展示内容了：// 首先需要在父页面 onLoad() 方法中添加监听以及指定监听回调方法\r\n// 设置 App 监听回调\r\n// 如果其他页面修改了 app.js 中的 showPictureDetail 值, 就会触发回调\r\ngetApp().watch(self.watchBack)\r\n\r\n//定义监听回调方法\r\n//app 监听回调方法\r\n  watchBack: function (value) {  //这里的value 就是 app.js 中 watch 方法中的 set, 返回整个 globalData\r\n    this.setData({\r\n      showPictureDetail: value._showPictureDetail,\r\n      pictureTime: value._pictureTime,\r\n      pictureAddress: value._pictureAddress\r\n    });\r\n  },这样，在父页面中使用 showPictureDetail..这几个变量就可以动态展示了。PS：我这边的业务需求涉及到多个变量的监听，如果你只有一个变量的监听，那么只需要修改 app.js 中 watch 方法的 Object.defineProperty 内容由对象传递变为单个值传递即可。在更新值和获取值时传递就是一个值，而不是对象。"}
{"title": "微信小程序支付功能全流程实践 ", "author": "Rolan", "put_time": "2019-7-16 00:31", "content": "前言微信小程序为电商类小程序，提供了非常完善、优秀、安全的支付功能。在小程序内可调用微信的API完成支付功能，方便、快捷。小程序开发者在开发小程序时，支付流程是必然要接触到，今天胡哥就小程序支付的全流程为大家一一细说，让小伙伴能快速得掌握小程序支付能力，避免踩坑！知己知彼，方能百战不殆 - 小程序支付流程图举个栗子:chestnut:：某用户小明在某电商小程序上购买一块肥皂，从浏览、下单到支付经历了什么样的过程呢？打开电商小程序，搜索浏览到某雕肥皂，点击查看详情后，发现大小、丝滑程度都很合适，点击直接下单wx.login获取用户临时登录凭证code，发送到后端服务器换取openId在下单时，小程序需要将小明购买的商品Id，商品数量，以及小明这个用户的openId传送到服务器服务器在接收到商品Id、商品数量、openId后，生成服务期订单数据，同时经过一定的签名算法，向微信支付发送请求，获取预付单信息(prepay_id)，同时将获取的数据再次进行相应规则的签名，向小程序端响应必要的信息(必须字段信息将在下文进行详细说明)小程序端在获取对应的参数后，调用wx.requestPayment()发起微信支付，唤醒支付工作台，进行支付小结进行微信支付，在小程序端我们主要做三件事：注：服务端调用统一下单API、签名算法不再本次分享讨论范围内，请期待胡哥的另外一次分享。使用 wx.login 获取临时登录凭证code,发送到后端获取openIdwx.login({\r\n  success (res) {\r\n    if (res.code) {\r\n      // 发起请求，换取openId\r\n      wx.request({\r\n        url: '',\r\n        data: {\r\n          code: res.code\r\n        }\r\n      })\r\n    }\r\n  }\r\n})将 openId 以及相应需要的商品信息发送到后端，换取服务端进行的签名等信息wx.request({\r\n  url: '',\r\n  data: {\r\n    openId: '',\r\n    num: 1,\r\n    id: '111'\r\n  }\r\n})接收返回的信息（必须要包含发起微信支付 wx.requestPayment的参数 ），发起微信支付wx.requestPayment({\r\n  // 时间戳\r\n  timeStamp: '',\r\n  // 随机字符串\r\n  nonceStr: '',\r\n  // 统一下单接口返回的 prepay_id 参数值\r\n  package: '',\r\n  // 签名类型\r\n  signType: '',\r\n  // 签名\r\n  paySign: '',\r\n  // 调用成功回调\r\n  success () {},\r\n  // 失败回调\r\n  fail () {},\r\n  // 接口调用结束回调\r\n  complete () {}\r\n})注意：以上信息中 timeStamp 、 nonceStr 、 prepay_id 、 signType 、 paySign 各参数均建议必须都由服务端返回（这样会尽最大可能性保证签名数据一致性），小程序端不做任何处理基于Taro的微信支付实例import Taro, { Component } from '@tarojs/taro'\r\nimport { View, Text, Button } from '@tarojs/components'\r\nimport './index.scss'\r\n\r\nexport default class Index extends Component {\r\n\r\n  config = {\r\n    navigationBarTitleText: '首页'\r\n  }\r\n\r\n  componentWillMount () { }\r\n\r\n  async componentDidMount () { \r\n  }\r\n\r\n  componentWillUnmount () { }\r\n\r\n  componentDidShow () { }\r\n\r\n  componentDidHide () { }\r\n\r\n  /**\r\n   * sendOrderInfo()\r\n   * @description 提交订单信息，获取支付凭证，唤起支付\r\n   */\r\n  async sendOrderInfo () {\r\n    // 获取临时登录凭证code\r\n    let codeData = await Taro.login()\r\n    // 换取openId\r\n    let openId = ''\r\n    if (codeData.code) {\r\n      let res = await Taro.request({\r\n        // 定义的后端换取openId的接口\r\n        url: 'https://www.justbecoder.com/getLogin',\r\n        data: {\r\n          code: codeData.code\r\n        }\r\n      })\r\n      if (res && res.code === 0) {\r\n        openId = res.openId\r\n      }\r\n    }\r\n    // 发送openId以及对应的商品信息\r\n    let data = await Taro.requrest({\r\n      url: 'https://www.justbecoder.com/createdOrder',\r\n      data: {\r\n        openId,\r\n        // 实际情况的商品数量\r\n        num: 1,\r\n        // 实际情况的商品Id\r\n        id: 111,\r\n      }\r\n    })\r\n    // code === 0 表示提交订单成功，返回需要的签名信息等\r\n    if (data && data.code === 0) {\r\n      let {\r\n        timeStamp,\r\n        nonceStr,\r\n        prepay_id,\r\n        signType,\r\n        paySign\r\n      } = data.payInfo\r\n      // 唤起支付，按小程序要求格式发送参数\r\n      let payData = await Taro.requestPayment({\r\n        timeStamp,\r\n        nonceStr,\r\n        package: 'prepay_id=' + prepay_id,\r\n        signType,\r\n        paySign\r\n      })\r\n      if (payData && payData.errMsg === 'requestPayment:ok') {\r\n        Taro.showModal({\r\n          title: '操作提示',\r\n          content: '支付成功',\r\n          showCancel: false,\r\n          confirmText: '确定'\r\n        })\r\n      } else {\r\n        Taro.showModal({\r\n          title: '操作提示',\r\n          content: '支付失败，请重新尝试',\r\n          showCancel: false,\r\n          confirmText: '确定'\r\n        })\r\n      }\r\n    }\r\n  }\r\n\r\n  render () {\r\n    return (\r\n      <View className='index'>\r\n        <Button onClick={this.sendOrderInfo}>立即下单</Button>\r\n      </View>\r\n    )\r\n  }\r\n}效果图结语在实际项目操作中，大家把接口换成自己的可用接口即可。后记以上就是胡哥今天给大家分享的内容，喜欢的小伙伴记得 收藏 、 转发 、点击右下角按钮 在看 ，推荐给更多小伙伴呦，欢迎多多留言交流...胡哥有话说，一个有技术，有情怀的胡哥！京东开放平台首席前端攻城狮。与你一起聊聊大前端，分享前端系统架构，框架实现原理，最新最高效的技术实践！"}
{"title": "小程序使用canvas二维码保存至手机相册 ", "author": "Rolan", "put_time": "2019-7-16 00:45", "content": "在使用canvas绘制海报的过程中不建议使用原生来进行画图，因为默认是不支持rpx像素的，px不会做到自适应。\r\n推荐使用插件 Painter\r\ngithub地址\r\ngithub.com/Kujiale-Mob…\r\n配置很简单，也容易上手，无论是画矩形，还是将图片合成canvas；还是自己定义文字；都是很方便的。\r\n附上一个简单的例子吧\r\n\r\n <painter :customStyle=\"customStyle\" :palette=\"imgDraw\" />\r\n复制代码//\r\n  const _this=this;\r\n      wx.getSystemInfo({\r\n        success (res) {\r\n          _this.drawCanvas(res.windowHeight);\r\n        }\r\n      })\r\n\t  \r\ndrawCanvas(height) {\r\n//这里的canvas的高是动态获取设备的高度，做到自适应\r\n       const that = this;\r\n      let heightVal=height*2+'rpx';\r\n      this.imgDraw = {\r\n        width: '750rpx',\r\n        height: heightVal,\r\n        background: '#fff',\r\n        views: [\r\n          {\r\n            type: \"rect\",\r\n            css: {\r\n              top: '20rpx',\r\n              left: '130rpx',\r\n              color: '#1A1A1A',\r\n              width: '660rpx',\r\n              height: '220rpx',\r\n              borderRadius: '32rpx'\r\n            }\r\n          },\r\n          {\r\n            type: 'image',\r\n            url: './a.jpg',\r\n            css: {\r\n              top: '36rpx',\r\n              left: '16rpx',\r\n              width: '188rpx',\r\n              height: '188rpx'\r\n            }\r\n          },\r\n          {\r\n            type: 'text',\r\n            text: '',\r\n            css: {\r\n              top: '54rpx',\r\n              left: '260rpx',\r\n              fontSize: '48rpx',\r\n              color: \"#fff\"\r\n            }\r\n          },\r\n          {\r\n            type: 'text',\r\n            text: '文字部分',\r\n            css: {\r\n              top: '134rpx',\r\n              left: '260rpx',\r\n              fontSize: '30rpx',\r\n              color: \"#d1d1d1\"\r\n            }\r\n          },\r\n          {\r\n            type: 'text',\r\n            text: '1333333333',\r\n            css: {\r\n              top: '196rpx',\r\n              left: '260rpx',\r\n              fontSize: '26rpx',\r\n              color: \"#d1d1d1\"\r\n            }\r\n          },\r\n          {\r\n            type: 'text',\r\n            text: '李四',\r\n            css: {\r\n              top: '304rpx',\r\n              left: '302rpx',\r\n              fontSize: '24rpx',\r\n              color: \"#767676\"\r\n            }\r\n          },\r\n          {\r\n            type: 'image',\r\n            url: '/icon-localtion.png',\r\n            css: {\r\n              top: '275rpx',\r\n              left: '260rpx',\r\n              width: '26rpx',\r\n              height: '168rpx'\r\n            }\r\n          },\r\n          {\r\n            type: 'image',\r\n            url: '二维码.png',\r\n            css: {\r\n              top: '646rpx',\r\n              left: '236rpx',\r\n              width: '278rpx',\r\n              height: '278rpx'\r\n            }\r\n          }\r\n        ]\r\n      }\r\n\r\n    \r\n      let { path: __path } = mpvue.getStorageSync('createImagePath')\r\n      mpvue.saveImageToPhotosAlbum({\r\n        filePath: __path,\r\n        success(res) {\r\n          // mpvue.showToast({\r\n          //   title: '保存成功',\r\n          //   icon: 'success',\r\n          //   duration: 800,\r\n          //   mask: true\r\n          // });\r\n      \r\n        },\r\n        fail(res) {\r\n          // mpvue.showToast({\r\n          //   title: '保存失败',\r\n          //   icon: 'fail',\r\n          //   duration: 800,\r\n          //   mask: true\r\n          // });\r\n        }\r\n      });\r\n    },\r\n\t\r\n复制代码这里涉及到画二维码， 如果你的二维码图片不是一个线上的链接的话，这时需要做一些小操作。\r\n我的项目中二维码的图片传过来是一个流，所以用img的src默认发送get请求，就能拿到这个图片了。\r\n所以url会直接发送get请求拿到图片。\r\ncanvas的层级\r\ncanvas的层级是最高的，底部的分享块会被遮住，这时你需要用两套方案，一个是纯展示用的，用正常的html来写，给用户看这个名片。\r\n下载或分享的时候再y用canvas生产你想要图片，接着调用微信的保存api，将图片下载或分享。\r\nlet { path: __path } = mpvue.getStorageSync('createImagePath')\r\nmpvue.saveImageToPhotosAlbum({\r\n  filePath: __path,\r\n  success(res) {\r\n    // mpvue.showToast({\r\n    //   title: '保存成功',\r\n    //   icon: 'success',\r\n    //   duration: 800,\r\n    //   mask: true\r\n    // });\r\n\r\n  },\r\n  fail(res) {\r\n    // mpvue.showToast({\r\n    //   title: '保存失败',\r\n    //   icon: 'fail',\r\n    //   duration: 800,\r\n    //   mask: true\r\n    // });\r\n  }\r\n});\r\n复制代码此时就能顺利完成保存名片的功能了。"}
{"title": "微信小程序数据字段大小写问题 ", "author": "Rolan", "put_time": "2019-7-17 00:46", "content": "这两天在开发微信小程序登录以及加解密的时候，因为数据大小写的问题被坑了一把。场景小程序调用\twx.login 时会获得\tcode ，传输给服务端可以得到\topenid ,\tunionid(绑定了开放平台) ,\tsession_key小程序调用\tgetUserInfo 会获得\tencrypted_data ,\tiv ,解密后得到\tunionId ,\topenIdunionid 和\topenid 这两个场景\t键名大小写是不同的例子服务端根据\tcode获取session_key 返回结果如下：{\r\n    \"session_key\": \"我是session_key\",\r\n    \"openid\": \"我是openid\",\r\n    \"unionid\": \"我是unionid\"\r\n}\r\n服务端根据\tsession_key解密encrypted_data和iv 返回结果如下：{\r\n    \"openId\": \"OPENID\",\r\n    \"nickName\": \"NICKNAME\",\r\n    \"gender\": GENDER,\r\n    \"city\": \"CITY\",\r\n    \"province\": \"PROVINCE\",\r\n    \"country\": \"COUNTRY\",\r\n    \"avatarUrl\": \"AVATARURL\",\r\n    \"unionId\": \"UNIONID\",\r\n    \"watermark\":\r\n    {\r\n        \"appid\":\"APPID\",\r\n        \"timestamp\":TIMESTAMP\r\n    }\r\n}\r\n可以看到两次同样的字段\topenid 和\tunionid 大小写是不同的，此处容易踩坑。结论服务端根据\tcode换session_key/openid/unionid 是\t小写服务端根据\tencrypted_data和iv 解密得到的\topenId/unionId 是\t大写最后，祝大家在开发过程中少踩坑。"}
{"title": "publish一个微信小程序的日历组件 ", "author": "Rolan", "put_time": "2019-7-17 00:52", "content": "公司下一个小程序项目会用到日历组件，所以准备自己先写一个。由于小程序支持了npm，可以开发和使用第三方自定义组件包，索性就尝试下发布一个日历组件。在设计稿没出来前，样式就先这样了（有没有一丝熟悉感）使用地址1.安装npm install --save miniprogram-simple-calendar\r\n复制代码2.在需要使用 calendar 的页面 page.json 中添加 calendar 自定义组件配置{\r\n  \"usingComponents\": {\r\n    \"simple-calendar\": \"miniprogram-simple-calendar\"\r\n  }\r\n}\r\n复制代码在wxml中使用<simple-calendar bindselect=\"select\"></simple-calendar>\r\n复制代码注意：使用npm前，先在根目录 npm init ，然后执行安装命令，再点击开发者工具中的菜单栏：工具 --> 构建 npm ，再勾选“使用 npm 模块”选项，具体查看文档。开发小程序组件怎么开发并发布一个小程序插件，官方文档在这里：开发第三方自定义组件根据介绍下载官方的项目模板，结构如下：|--miniprogram_dev // 开发环境构建目录\r\n|--miniprogram_dist // 生产环境构建目录\r\n|--src // 源码\r\n|   |--components // 通用自定义组件\r\n|   |--images // 图片资源\r\n|   |\r\n|   |--xxx.js/xxx.wxml/xxx.json/xxx.wxss // 暴露的 js 模块/自定义组件入口文件\r\n|\r\n|--test // 测试用例\r\n|--tools // 构建相关代码\r\n|   |--demo // demo 小程序目录，开发环境下会被拷贝生成到 miniprogram_dev 目录中\r\n|   |--config.js // 构建相关配置文件\r\n|\r\n|--gulpfile.js\r\n复制代码miniprogram_dev： npm run dev 或 npm run watch 都会生成小程序代码到此目录，在开发者工具中打开此目录就可以预览miniprogram_dist： npm run build 打包出的文件src：源码目录，我们需在此开发组件，源代码会被构建并生成到 miniprogram_dev/components 目录下使用less项目支持配置 less 开发，但是需要改几处地方：tools/config.js 中wxss: {\r\n  less: true, // 使用 less 来编写 wxss\r\n  // ...\r\n}\r\n复制代码tools/checkcomponents.js 中componentListMap.wxssFileList.push(`${fileBase}.less`) // 后缀改为less\r\n复制代码tools/build.js 中/**\r\n  * 监听 wxss 变化\r\n  */\r\n gulp.task(`${id}-watch-wxss`, () => {\r\n   this.cachedComponentListMap.wxssFileList = null\r\n   return gulp.watch(\r\n     '**/*.less',   // 将这里改为.less\r\n     {cwd: srcPath, base: srcPath},\r\n     gulp.series(`${id}-component-wxss`)\r\n   )\r\n })\r\n复制代码获取每月天数关于开发日历的原理，随便一搜都能看到很多，我就不多说了，不过有一点我想提一下，那就是每个月天数的获取。不少教程都是把月份的天数存为一个数组，然后根据闰平年计算二月的天数，这样也很容易实现，而我用的是另外一个方法，也有不少教程说到，那就是获取每个月的最后一天是几号，最后一天是几号那这个月就多少天了。在JavaScript中，要获取指定日期，比如获取 2019-02-01 的日期，我们可以这样：new Date(2019,1,1)\r\n复制代码正式因为我明确知道要获取几月几号的日期，所以才可以这么写，那如果要获取最后一天的日期呢？其实可以这么写：new Date(2019,2,0) // 获取2月的最后一天日期\r\n复制代码初看觉得很奇怪，很容易以为是获取 2 月的的第一天，但这里需要注意的是，月份是从 0 开始的，所以这里的 2 表示的是 3 月，而 0 其实就表示往 1 号前退一天，那就是 2 月的最后一天了，再使用 getDate() 就可以拿到本月天数了"}
{"title": "你知道如何在小程序中推送模板消息？ ", "author": "Rolan", "put_time": "2019-7-17 00:56", "content": "前段时间剁手了 PS4,在浏览商店时，发现官方商店真的不好用，主要是网络原因，次要是页面设计。所以就想自己做一个游戏查询的小程序，可以关注某个游戏，然后在这个游戏打折的时候发送通知给用户。最后发现有个很大的问题是：小程序没法直接给用户推送消息（当时还不知道模板消息），服务号才能。然后就用邮箱实现了通知功能，但是邮箱的局限实在是太大了（各大免费邮箱每天的发件数都很小，自己搭建的邮件服务器虽然没有发件限制，但是大概率会被放到垃圾箱）。\r\n然后某天在微信小程序的管理后台发现了模板消息这个东西，查了会资料发现可以通过这个来实现消息推送。要给用户发送模板消息需要formId/prepay_id这样一个东西，这个东西是怎么来的呢？\r\n\r\n\r\nformId:这个可以通过表单的提交来获取，需要在组件中设置属性report-submit=\"true\",这样每次对这个表单的提交一次就会产生一个 formId.\r\nprepay_id:这个是支付动作产生的，具体的我也不太清楚，毕竟个人小程序并不能支付.\r\n\r\n下面具体来讲讲前后台的实现，前台使用 mpvue，后台使用 java\r\n前台获取 formId\r\n既然可以通过 form 的 submit 操作来获取到 formId,那我们稍微拓展一下，将我们的小程序页面中所有用户能点击的部分都用 form,button 来包裹一下，这样用户感知不到有表单提交操作，我们也能获取大量的 formId。\r\n注意不能用叠加的方式来一次点击获取多个 formId,这样方法已经不行了，获取到的都会是一样的。\r\n获取一个模板\r\n要发送模板消息，首先要在小程序的管理后台上添加模板，步骤如下：\r\n1.在模板库中选择一个模板\r\n2.选择显示参数\r\n选择要显示在消息中的参数，这里选择如下两个参数：\r\n这样就有了一个模板可以用来发消息了，在我的模板中可以看到模板 id，和字段 id\r\n获取 formId\r\nformId 是通过表单提交来获取到了，为了获取足够多的 formId,可以将能够点击的组件（比如按钮，列表单元..）包裹在 form 中，这样用户在日常使用中就能够收集到足够多的 formId。下面以包裹一个有赞的按钮为例。因为小程序的限制，设置form-type属性的按钮必须为 form 组件的直接子节点，所以并不能够在 form 中使用自定义组件，并将form-type='submit'设置到自定义组件中。\r\ntemplate 部分如下：\r\n<!-- 要获取formId，需要给form设置report-submit=\"true\"的属性，然后在form-type=\"submit\"的按钮上产生点击动作，才会触发表单提交的事件--formSubmit,进而获取到formId -->\r\n<form @submit=\"formSubmit\" report-submit=\"true\" class=\"bottom\">\r\n  <button style=\"border:0;display:inline-block\" plain=\"true\" form-type=\"submit\" @click=\"back\">\r\n    <van-button round type=\"primary\" size=\"small\" @click=\"back\">返回</van-button>\r\n  </button>\r\n  <button style=\"border:0;display:inline-block\" plain=\"true\" form-type=\"submit\" @click=\"watchGame\">\r\n    <van-button round type=\"danger\" size=\"small\">{{watchText}}</van-button>\r\n  </button>\r\n  <button style=\"border:0;display:inline-block\" plain=\"true\" form-type=\"submit\" open-type=\"share\">\r\n    <van-button round type=\"info\" size=\"small\">分享</van-button>\r\n  </button>\r\n</form>\r\n复制代码style 目的为了去除原生 button 的背景，边框啥的，把 button 当一个 div 来使用，然后在 button 中设置 form-type 和 click 属性,这样既不影响 formId 的属性，也对原有逻辑不产生任何影响。之所以将 click 放在 button 上是因为 button 内部的组件没法获取到点击事件。\r\nformSubmit 代码如下：\r\nformSubmit(e) {\r\n  let item = {\r\n    value: e.mp.detail.formId,\r\n    expireTime: Date.now() + 7 * 24 * 60 * 60 * 1000\r\n  };\r\n  this.globalData.formIdList.push(item);\r\n},\r\n复制代码该函数是在表单提交时触发，用于获取 formId,将 formId 和这个 formId 的过期时间一起存到 globalData 全局数据中。然后找一个时机将这些 formId 发送给服务器保存起来就行了。\r\n这里放上我的做法以供参考。\r\n我是在每次发送 http 请求前检查是不是有 formId 需要发送到服务器，如果有就将这些数据 JSON 序列化后放到一个自定义 header 中，发送出去，具体代码如下(http 请求工具为：flyio)：\r\nvar Fly = require(\"flyio/dist/npm/wx\");\r\nvar fly = new Fly();\r\n//在请求预处理中\r\nfly.interceptors.request.use(request => {\r\n  request.headers[\"jwt-token\"] = wxUtil.getGlobalData(\"jwt-token\");\r\n  //如果有formId就放到header里送过去\r\n  let formIdList = getApp().globalData.formIdList;\r\n  if (formIdList.length > 0) {\r\n    request.headers[\"formIdList\"] = JSON.stringify(formIdList);\r\n    getApp().globalData.formIdList = [];\r\n  }\r\n  if (request.method == \"GET\") {\r\n    request.params[\"_t\"] = new Date().getTime();\r\n  }\r\n  return request;\r\n});\r\n复制代码下面将后台的实现，基于 Spring Boot.\r\n后台处理\r\n搜集 formId\r\n首先需要把 formId 收集起来存到数据库，那么就需要检查每个请求，看 header 中有没有携带 formId,如果有就存到数据库中，注意要和用户对应起来，某个用户点击产生的 formId 只能用于给这个用户推送消息。\r\n因为要将 formId 和用户绑定起来，因此我是在身份认证过滤器中进行的 formId 处理，身份认证成功后，处理 formId。代码如下：\r\n/**\r\n * Description: 从请求头中获取formIdList,并插入数据库\r\n *\r\n * @param request 请求头\r\n * @return void\r\n * @author fanxb\r\n * @date 2019/5/6 16:39\r\n */\r\nprivate void checkFormId(HttpServletRequest request) {\r\n    String str = request.getHeader(Constant.HEADER_FORM_ID);\r\n    if (StringUtil.isEmpty(str)) {\r\n        return;\r\n    }\r\n    List<FormKey> formKeyList = JSON.parseArray(str, FormKey.class);\r\n    //UserContextHolder用户将当前线程和用户绑定起来，方便后面获取用户信息\r\n    int userId = UserContextHolder.get().getUser().getUserId();\r\n    formKeyList.forEach(item -> item.setUserId(userId));\r\n    this.formKeyDao.insertMany(formKeyList);\r\n}\r\n复制代码发送微信提醒\r\n通过官方文档可以知道发送消息的流程如下：\r\n1 获取 accessToken,调用微信的大多数接口都需要这个东西，这个通过 appId 和 secret 来获取。详情参见：developers.weixin.qq.com/miniprogram…\r\n2 调用微信发送服务通知的接口.这个接口文档在:点击跳转\r\n最终发送的 http 请求是这样的：\r\nurl: https://api.weixin.qq.com/cgi-bin/message/wxopen/template/send?access_token=上面获取的accessToken\r\nmethod: post\r\n\r\n请求体格式为：application/json; charset=utf-8\r\n\r\nbody:{\r\n  \"touser\": \"用户的openId\",\r\n  \"template_id\": \"模板id\",\r\n  \"page\": \"点击跳转的小程序url路径\",\r\n  \"form_id\": \"收集到的formId\",\r\n  \"data\": {\r\n    \"keyword1\": {\r\n      \"value\": \"您有一个信息的提示消息\"\r\n    },\r\n    \"keyword2\": {\r\n      \"value\": \"这是消息内容\"\r\n    }\r\n  },\r\n  \"emphasis_keyword\": \"keyword1.DATA\"\r\n}\r\n复制代码data 中的数据的按照顺序 keyword1,keyword2 对应于模板中字段的顺序。\r\n结束\r\n工程全部源码在这里：github"}
{"title": "微信小程序之楼层效果 ", "author": "Rolan", "put_time": "2019-7-18 00:29", "content": "今天做了一个小程序实现一个楼层效果  带大家分享下经验和api的使用吧 如图 将左边和右边各分了一个组件  目录如下 　　　其中list页面是这个楼层效果的页面  　　　components是组成这个页面的两个组件　　　list为列表组件   title为右边字母固定的组件list主页面的代码如下　　<!--pages/list/list.wxml-->\r\n<view class='container'>\r\n  <view class='box'>\r\n    <view class='left' wx:if=\"{{contentList.length}}\">\r\n      <list contentList=\"{{contentList}}\" class=\"listComponent\" currentKey=\"{{currentKey}}\" bind:ChangeId=\"changeId\"></list>\r\n    </view>\r\n  </view>\r\n  <view class='right'>\r\n    <title wx:for=\"{{titleList}}\" wx:key=\"{{index}}\" title=\"{{item}}\" class=\"{{titleIndex===index?'titleActive':''}}\" index=\"{{index}}\" bind:ChangeId=\"changeId\" bind:Changekey='changekey'></title>\r\n  </view>\r\n</view>上述代码用到的api 有如下几点1、组件的调用  需要我们在下list.json先配置下  然后直接当成标签使用 2、组件的传值  如上述代码  contentList=\"{{contentList}}\"  这种写法就是组件间的传值在list组件的接收这个参数的写法　　properties: {　　　　contentList: Array,　　　　currentKey: String　　},接收后使用的话直接当做data的参数使用就可以喽  3、父组件向子组件传个函数  让子组件调用然后改变父组件某个参数bind:ChangeId=\"changeId\"    这样是传发   bind是必须的 用来区分是函数还是变量  bind后面的是让子组件调用使用的引号里面为父组件真正定义的函数   注意这里直接  引号 不要加{{}}  子组件接受这个函数并且调用　　　　this.triggerEvent('ChangeId', {　　　　id: index　　})  4、自己定义的函数然后写在哪里  父组件的话直接找个地方写函数名就行了 但是子组件需要写在methods里面  5、加入我们定义的函数需要传参数怎么办第二行就是传参  通过data-传一个叫做id的参数    这里提一下  循坏的时候如果我们不去指定变量的话会是item代表每一项 index代表下标     如果指定的话可以   wx:for-index=\"i\"  指定下标    wx:for-item=\"myItem\" 制定每一项 然后接受都在e里面 如下   e.currentTarget.dataset 6、wx:if=\"{{contentList.length}}\"  判断是否要渲染下面的元素条件  注意这里的条件要放在括号里面去这个条件需要注意下 因为第一次没加这个东西出现了bug 7、class名的添加     class=\"{{titleIndex===index?'titleActive':''}}\"     基本类似Vue   但是这里加括号 以上为主页面的知识点介绍  下面介绍的list页面的知识点    title页面没有什么可说的  基本上就是点击事件控制父组件的变量得到颜色的切换  以及右边连带滚动  list组件代码<scroll-view\r\n  scroll-y \r\n  scroll-into-view=\"{{currentKey}}\" \r\n  scroll-with-animation \r\n  bindscroll=\"handleScroll\"\r\n  class='scroll'\r\n>\r\n  <view wx:for=\"{{contentList}}\" wx:key=\"{{index}}\" id=\"{{item.key}}\" class='content'>\r\n    <text class='title'>{{item.key}}</text>\r\n\r\n    <view class='item' wx:for=\"{{item.row}}\" wx:key=\"{{index}}\">\r\n      <image src='{{item.img}}' class='img'></image>\r\n      <text class='item-text'>{{item.name}}</text>\r\n    </view>\r\n  </view>\r\n</scroll-view> 1、首先  我们这个页面需要做一个滚动列表  然后调用了下人家封装好的 scroll-view这个组件  对于这个组件简单的介绍下a、首先 想要得到滚动效果 并且触发组件封装的函数必须让其高度小于内容的高度在上述代码中也就是 scroll这个元素小于  content这个元素不然触发不了b、scroll-y   设置滚动方向　 scroll-into-view=\"{{currentKey}}\"   这个变量绑顶右边字母的 id   在点击id的时候就会直接让右边对应的内容滚到顶部   　先给这个currtKey默认右边第一个元素的id  之后点击的时候动态改变     scroll-with-animation   添加动画效果　bindscroll=\"handleScroll\"    在页面滚动的时候会触发这个  然后打印事件对象e会得到你想要的在这里我们需要e.detail.scrollTop;  获取滚到高度就可以喽c、 然后此时这个题到这里基本上就完成了一大半了   剩下的就是我们获取 ABC所有元素距离顶部的距离  然后将这些数字储存起来然后这个函数中循坏比较改变右边class的类名就可以了   此时碰见的bug就是在子组件如何获取到某一个class类名的所有元素距离顶部高度  通过官网api查看    下面这个方法就可以获取到this.createSelectorQuery().selectAll(\".content\").boundingClientRect((rect) => { rect.forEach(item => {arr.push(item.top)}).exec((res) => {}) 注意在子组件中是this.createSelectorQuery()   在父组件中是ws.createSelectorQuery() 此时我们在子组件的生命周期  ready第一次获取没有获取到 就是因为上面的那个判断条件没有写 我们的数据是通过请求传过来的  第一次向这个子组件传了个空数组 页面什么也没有渲染  而这个周期执行了一遍所以导致我们什么都没有获取到  找了半天才发现   简直到了怀疑人生的地步 唉~~~   下面顺带介绍下生命周期吧 页面生命周期小程序注册完成后，加载页面，触发onLoad方法。页面载入后触发onShow方法，显示页面。首次显示页面，会触发onReady方法，渲染页面元素和样式，一个页面只会调用一次。当小程序后台运行或跳转到其他页面时，触发onHide方法。当小程序有后台进入到前台运行或重新进入页面时，触发onShow方法。当使用重定向方法wx.redirectTo(OBJECT)或关闭当前页返回上一页wx.navigateBack()，触发onUnload 组件的生命周期created 组件实例化，但节点树还未导入，因此这时不能用setDataattached 节点树完成，可以用setData渲染节点，但无法操作节点ready 组件布局完成，这时可以获取节点信息，也可以操作节点moved 组件实例被移动到树的另一个位置detached 组件实例从节点树中移除  组件生命周期不带on  页面的带on 最后介绍下下面地步的配置通过全局配置 tabBar在app.json配置如下 \"tabBar\": {\r\n    \"color\": \"#333333\",  //字体颜色\r\n    \"selectedColor\": \"#f00\",  //选中颜色\r\n    \"backgroundColor\": \"#ffffff\",  //底部导航颜色\r\n    \"borderStyle\": \"black\", //边框色\r\n    \"position\": \"bottom\",   //设置是在底部还是顶部\r\n    \"list\": [\r\n      {\r\n        \"text\": \"首页\",  //文字内容\r\n        \"selectedIconPath\": \"./static/index-active.png\",  //选中的时候图片展示\r\n        \"iconPath\": \"./static/index.png\",  //平常状态下的图片样式\r\n        \"pagePath\": \"pages/index/index\"   //点击要跳转的位置\r\n      },\r\n      {\r\n        \"text\": \"通讯录\",\r\n        \"selectedIconPath\": \"./static/find-active.png\",\r\n        \"iconPath\": \"./static/find.png\",\r\n        \"pagePath\": \"pages/list/list\"\r\n      },\r\n      {\r\n        \"text\": \"购物车\",\r\n        \"selectedIconPath\": \"./static/cart-active.png\",\r\n        \"iconPath\": \"./static/cart.png\",\r\n        \"pagePath\": \"pages/cart/cart\"\r\n      },\r\n      {\r\n        \"text\": \"我的\",\r\n        \"selectedIconPath\": \"./static/me-active.png\",\r\n        \"iconPath\": \"./static/me.png\",\r\n        \"pagePath\": \"pages/my/my\"\r\n      }\r\n    ]\r\n  },     本文GitHup的地址   https://github.com/qiang-chen/weixin-project"}
{"title": "小程序分页实践：编写可复用分页组件 ", "author": "Rolan", "put_time": "2019-7-18 00:44", "content": "项目中遇到 tab切换列表，每个tab都需要分页的需求，分页流程具有相似性，于是想将分页封装为组件，方便应用。\r\n组件的应用已写成一个小demo，效果如下图所示（数据用mock模拟）：\r\n源码可以查看：wxapp-pagination\r\n\r\n项目需求\r\n具体项目需求：\r\n\r\n查看自己相关的会议（页面命名为 meetings）\r\ntab切换，分为：\r\n\r\n“我的会议”（我参加的会议，后面会以 \"join\" 为 key区分）\r\n“我的预约”（我预约的会议，后面会以 \"book\" 为 key区分）\r\n\r\n\r\n一次加载10条（size=10），拉到底部后，加载下一页（page = page +1）\r\n\r\n当然，作为前端，要考虑性能方面的需求：\r\n\r\n首次只加载默认tab页的首页，其他tab等到点击到对应tab才开始加载。\r\n回到已加载过的tab页，保留原数据不重新加载。\r\n\r\n所以原型图大概就长这样：\r\n\r\n逻辑实现\r\n与分页逻辑相关的项目结构如下：\r\n├── components\r\n│\t\t├── meeting-item\t  # 列表item\r\n│\t\t└── pagination\t          # 分页组件\r\n├── model\r\n│   └── user.js\t\t\t\t  # 我的相关 model\r\n└── pages\r\n│\t   └── user\t                  # 我的相关页面\r\n│       ├── meetings\t\t          # 我的会议（就是tab要分页的页面啦）\r\n│       └── ...\r\n│\r\n└── vant-weapp\r\n复制代码还是用图理一下他们之间的关系吧：\r\n在组件内监听触发分页事件\r\n触发分页的事件是滚动到页面的底部，小程序中，触发该事件是Page页面的onReachBottom事件，但是这个事件只能在Page中触发，所以要将这个触发时机传递给pagination组件。\r\n解决思路是：组件 pagination 内，设置key属性，每当onReachBottom事件触发之后，设置组件属性 key  为一个随机字符串，当组件 pagination 监听到key的变化的时候，做出分页操作。\r\n// components/pagination/index.js\r\nComponent({\r\n  properties: {\r\n    key: {\r\n      type: String,\r\n      observer: '_loadMoreData'  // _loadMoreData 为分页操作\r\n    }\r\n  }\r\n})\r\n复制代码<!-- pages/user/meetings/index.wxml -->\r\n<tabs active=\"{{currentTab}}\" bind:change=\"onChange\">\r\n    <tab title=\"我的会议\" data-key=\"{{type['JOIN']}}\">\r\n      <view class=\"meeting-list\">\r\n          <pagination \r\n            name=\"JOIN\"\r\n            key=\"{{joinKey}}\" \r\n          >\r\n          </pagination>\r\n      </view>\r\n    </tab>\r\n\r\n    <tab title=\"我的预约\">\r\n      <view class=\"meeting-list\">\r\n        <pagination \r\n          name=\"BOOK\"\r\n          key=\"{{bookKey}}\"\r\n        >\r\n        </pagination>\r\n      </view>\r\n    </tab>\r\n</tabs>\r\n复制代码Page({\r\n  onReachBottom(){\r\n    const key = scene[+this.data.currentTab].key // 对应tab对应key\r\n    this.setData({\r\n      [key]: random(16)\r\n    })\r\n  }\r\n})\r\n复制代码\r\n分页组件的实现逻辑\r\n触发到达底部之后，需要加载数据。但再加载之前，先满足加载的条件：\r\n\r\n上一页还未加载完成（loading = true），不重复加载\r\n当前页面全部加载完（ended = true），不继续加载\r\n\r\n具体加载流程为：\r\n\r\n**page：**触发 onReachBottom 事件，修改 pagination组件 key 值\r\ncomponent： key值监听到变化，触发加载事件_loadMoreData\r\ncomponent：_loadMoreData中判断满足条件后，触发加载列表函数 this.triggerEvent('getList')，并传入页面参数page 和 size。\r\n**page：**向model层获取数据。\r\n**page：**获取数据后，传递给 pagination组件list和total 值。\r\ncomponent：list 监听到变化，判断是否加载完成。\r\n\r\n\r\ncomponent\r\n// components/pagination/index.js\r\nComponent({\r\n  properties: {\r\n    name: String,\r\n    key: {\r\n      type: String,\r\n      observer: '_loadMoreData'  // _loadMoreData 为分页操作\r\n    },\r\n    size: {  // 每次加载条目数\r\n      type: Number,\r\n      value: 10\r\n    },\r\n    total: Number, // 页面总数\r\n    list: {\t\t\t\t // 已加载条目\r\n      type: Array,\r\n      observer: '_endState'     // 每次加载完新数据，判断数据是否全部加载完成\r\n    }\r\n  },\r\n\r\n  data: {\r\n    page: 0,\t\t\t\t// 当前第几页\r\n    loading: false, // 是否正在加载\r\n    ended: false    // 数据是否已全部加载完成\r\n  },\r\n  \r\n  methods: {\r\n    _loadMoreData(){\r\n      const { loading, ended, size } = this.data\r\n      if (loading) return  // 上一页还未加载完成，不加载\r\n      if (ended) return    // 当前页面全部加载完，不加载\r\n      const page = this.data.page + 1\r\n\r\n      this.setData({\r\n        loading: true,  // 开始加载新页面loading设置为true\r\n        page\r\n      })\r\n      // 触发加载下一页，并传入参数\r\n      this.triggerEvent('getList', {\r\n        page,\r\n        size\r\n      })\r\n    },\r\n    _endState(val, oldVal) {\r\n      const { total, list } = this.properties\r\n      let ended = false\r\n      // 判断数据是否全部加载完成\r\n      if (list.length >= total) {\r\n        ended = true\r\n      }\r\n      this.setData({\r\n        loading: false, // 当前页面加载完成，loading设置为false\r\n        ended\r\n      })\r\n    }\r\n  }\r\n})\r\n复制代码\r\npage\r\n<!-- pages/user/meetings/index.wxml -->\r\n<pagination \r\n  name=\"BOOK\"\r\n  key=\"{{bookKey}}\"\r\n  bind:getList=\"getBookMeetings\"\r\n  list=\"{{bookMeetings}}\"\r\n  total=\"{{bookTotal}}\"\r\n>\r\n</pagination>\r\n复制代码\r\n循环列表item\r\npagination组件获取了可循环的列表，初始想法是循环slot，但是在slot中却获取不到 item 对象：\r\n<view wx:for=\"{{list}}\" wx:for-item=\"item\" wx:key=\"index\">\r\n  <slot></slot>\r\n</view>\r\n复制代码解决的办法是将每个列表项封装为组件，循环抽象节点，这样对其他页面的分页具有可拓展性。\r\ncomponentGenerics 字段中声明：\r\n// components/pagination/index.json\r\n{\r\n  \"componentGenerics\": {\r\n    \"selectable\": true\r\n  },\r\n  // ...\r\n}\r\n复制代码使用抽象节点：\r\n<!-- components/pagination/index.wxml -->\r\n<view wx:for=\"{{list}}\" wx:for-item=\"item\" wx:key=\"index\">\r\n    <selectable item=\"{{item}}\"></selectable>\r\n</view>\r\n复制代码指定“selectable”具体是哪个组件：\r\n<!-- pages/user/meetings/index.wxml -->\r\n<pagination \r\n  generic:selectable=\"meeting-item\"\r\n\t// ... 其他属性\r\n>\r\n</pagination>\r\n复制代码对应 json 文件定义对应 usingComponents ：\r\n// pages/user/meetings/index.json\r\n{\r\n  \"usingComponents\": {\r\n    \"pagination\":\"/components/pagination/index\",\r\n    \"meeting-item\":\"/components/meeting-item/index\"\r\n  }\r\n}\r\n复制代码meeting-item 组件接收一个属性 item，这样在 meeting-item 组件中，就可以获取到循环列表的item值，并正常绘制页面。\r\n\r\n实现切换懒加载\r\n给pagination添加initImmediately属性，当initImmediately为true时，首次加载页面，并用变量 initState标记是否已经初始化页面过。\r\n// components/pagination/index.js\r\nComponent({\r\n  properties: {\r\n    initImmediately: {\r\n      type: Boolean,\r\n      value: true,\r\n      observer: function(val){\r\n        if (val && !this.data.initState) {\r\n          this.initData()\r\n        }\r\n      }\r\n    },\r\n    // ...\r\n  },\r\n  data: {\r\n     initState: false, // 是否已经加载过\r\n     // ...\r\n  },\r\n  lifetimes: {\r\n    attached: function () {\r\n      if (this.data.initImmediately){\r\n        this.initData()\r\n      }\r\n    },\r\n  },\r\n  methods: {\r\n    initData(){\r\n      console.info(`${this.data.name}:start init data`)\r\n      this._loadMoreData()\r\n      this.setData({\r\n        initState: true\r\n      })   \r\n  \t},\r\n    // ... \r\n  \t_endState(val, oldVal) {\r\n      if (!this.data.initState) return \r\n      // ...\r\n  \t},\r\n  }\r\n})\r\n复制代码当currentTab为当前类型的时候，initImmediately 设置为 true。\r\n<!-- pages/user/meetings/index.wxml -->\r\n<pagination \r\n    name=\"JOIN\"\r\n    init-immediately=\"{{currentTab==type['JOIN']}}\"\r\n    // ...\r\n>\r\n</pagination>\r\n\r\n<pagination \r\n    name=\"BOOK\"\r\n    init-immediately=\"{{currentTab==type['BOOK']}}\"\r\n    // ...\r\n>\r\n</pagination>\r\n复制代码\r\n组件的复用\r\n完成了以上组件，在对其他分页的页面，可以直接复用。比如，实现一个获取全部用户列表的分页，只需要新增一个user-item的组件，像这样调用：\r\n<pagination \r\n  name=\"USER\"\r\n  key=\"{{key}}\" \r\n  bind:getList=\"getUserList\" \r\n  list=\"{{userList}}\" \r\n  total=\"{{userTotal}}\"\r\n  generic:selectable=\"user-item\"\r\n>\r\n</pagination>\r\n复制代码具体应用可以查看我写的小demo：wxapp-pagination。"}
{"title": "小程序分享海报的坑 ", "author": "Rolan", "put_time": "2019-7-18 00:50", "content": "UI小哥给了一张UI图，让我实现小程序的分享海报\r\n\r\n\r\n踩坑如下：\r\n\r\ncanvas绘制文字自动换行\r\ncanvas绘制文字，首行缩进\r\ncanvas剪切圆形头像\r\n\r\n一、canvas 绘制文字，自动换行\r\n因为canvas.fillText绘制文字是没用自动换行的功能的，所以需要自己封装个函数来实现。\r\ncanvas有个APIctx.measureText(string str).width可以获取字符串的像素长度\r\n当一行文字的像素长度超过画布的长度时，就可以另起一行重新绘制文字\r\n/*\r\n\tlineWidth:一行文字的总长度\r\n\tstr:是要写入的字符串\r\n\tinitX:初始时，文字距离画布边缘的距离\r\n\tcanvasWidth:画布的宽度\r\n\tlineHeight:是行高\r\n*/\r\nlet lineWidth = 0;\r\nfor(let i=0;i<str.length;i++){\r\n    lineWidth += ctx.measureText(str[i]).width;//每次增加一个字符的像素长度\r\n    if(lineWidth>canvasWidth-2*initX){\r\n        //减去两个initX是想在文字两边都有相同距离的空白\r\n        ctx,fillText(str.substr(0,i),initX,initY);\r\n        initY+=lineHeight;\r\n        str = str.str.substr(i);\r\n        i = -i;\r\n        lineWidth;\r\n\t}\r\n    //如果绘制到字符串的末尾了，还没超过画布的宽度\r\n    if(i==str.length-1){\r\n        ctx.fillText(str.substr(0,i+1),initX,initY);\r\n    }\r\n}\r\n复制代码二、canvas首行缩进\r\n因为canvas没有首行缩进的属性，只能是，绘制的时候，向右偏移两个字符的长度\r\n/*\r\n\tindent:布尔值，是否缩进\r\n\tindentWidth:缩进的像素宽度\r\n*/\r\nlet indent = true;\r\nlet indentWidth = 0;\r\nfor(let i=0;i<str.length;i++){\r\n    lineWidth += ctx.measureText(str[i]).width;\r\n    if(indent && i==1){\r\n        indentWidth = lineWidth;\r\n    }\r\n    if(indent && lineWidth>canvasWidth-2*initX-indentWidth){\r\n        ctx.fillText(str.substr(0,i),initX+indentWidth,initY);\r\n        initY+=lineHeight;\r\n        lineWidth=0;\r\n        indent = false;\r\n        str = str.substr(i);\r\n        i =-1;\r\n    }\r\n}\r\n复制代码小总结，将自动换行和首行缩进，封装成函数如下\r\n/*\r\n\tctx：wx.createCanvasContext获取的画布上下文\r\n\tinitX:距离画布左边缘的距离\r\n\tinitY:距离画布上部的距离\r\n\tstr:要绘制的字符串\r\n\tlineHeight:行高\r\n\tindent:布尔值，是否要首行缩进\r\n*/\r\ncanvasTextAutoLine(ctx,canvasWidth,str,initX,initY,lineHeight,indent=false){\r\n    let lineWidth =  0;\r\n    let indentWidth=0;\r\n    for(let i=0;i<str.length;i++){\r\n        lineWidth += ctx.measureText(str[i]).width;\r\n        if(indent && i==1){\r\n            indentWidth = lineWidth;\r\n        }\r\n        if(indent && lineWidth>canvasWidth-2*initX-indentWidth){\r\n            ctx.fillText(str.substr(0,i),initX+indentWidth,initY);\r\n            initY+=lineHeight;\r\n            lineWidth=0;\r\n            indent = false;\r\n            str = str.substr(i);\r\n            i =-1; //下次循环i会加1,所以下次循环就是1\r\n        }\r\n        if(lineWidth>canvasWidth-2*initX){\r\n            ctx.fillText(str.substr(0,i),initX,initY);\r\n            initY+=lineHeight;\r\n            str=str.substr(i);\r\n            i=-1;\r\n            lineWidth=0; \r\n        }\r\n        if(i==str.length-1){\r\n            ctx.fillText(str.substr(0,i+1),initX,initY);\r\n        }\r\n    }\r\n    return initY;\r\n}\r\n复制代码三、canvas剪切出圆形的头像\r\ncanvas的APIctx.clip()可以剪切图形，使用如下\r\n//1. 在使用clip()要先将之前绘制的图形保存\r\nctx.save();\r\n//2. 绘制你要剪切的图形\r\nctx.arc(25,25,25,0,Math.PI*2);\r\n//3. 剪切\r\nctx.clip();\r\n//4. 在剪切的范围内绘制图形，超过这个范围的不显示\r\nctx.drawImage(headImg,0,0,25,25);\r\n//5. 绘制完后，释放之前保存的图形\r\nctx.restore();\r\n复制代码结语\r\n作者：胡志武\r\n时间：2019/7/17\r\n本人大二，想找个前端实习生的工作。求职中。。。"}
{"title": "1小时带你撸一个小程序cli脚手架 ", "author": "Rolan", "put_time": "2019-7-19 00:12", "content": "在正文之前先大致描述下什么是cli工具，cli工具英文名command-line interface,也就是命令行交互接口，比较典型的几个case例如，create-react-app，vue-cli，具体可以去百度一下，下面gif是小打卡目前用的一套自动化发布工具:wrench:可以看到整个发布流程大致是以选择或默认项的形式实现，大致分析下面几步选择打包形式    开发模式/debug模式/发布模式设置版本号填写发布信息选择环境是否提交版本commit是不是非常无脑？是不是再也不用担心线上发错环境了？有了它就算不同项目间，就算一天发n次版本还需要担心什么呢？当然除了简单的发布功能还，还可以做很多的事情，比如 创建page/component模版 等一些更多有趣的事情为了节约版面就不贴图了，具体可以看下仓库 github.com/jinxuanzhen… （目前该工具是从小打卡现有的cli库中抽离的部分功能）明确痛点也就是我为什么要做这么一个工具，其实最开始我只是为了解决一个问题，就是在整个发布流程中需要人工去改动/确认发布环境和版本信息，大致可以想象下把线下环境发布到线上的尴尬处境后续发现从cli角度触发，很多东西都变得简单了，大致列了下：环境变量切换（线上环境，线下环境）创建启动模版，包括页面，组件自动化发布...准备工作本文会以快速创建页面模版文件为例教你怎么快速撸一个属于自己的cli工具，如果觉得自己做比较麻烦，可以clone下我的仓库自己改装下需要了解的三方库中间会用到一些第三方库commander ， 一个解析命令行命令和参数工具inquirer ，常用交互式命令行用户界面的集合chalk ，美化你的终端输出样式fuzzy，字符串模糊匹配的插件，根据输入关键词进行模糊匹配json-format，json美化/格式化工具其他的一些小知识：比如path模块，fs模块，大家可以去node官网自行查看：nodejs.org/api/搭建开发环境创建一个空文件夹，并且npm初始化, 并且创建一个index.js页面，这个index.js将作为你整个包的入口文件npm init -y\r\n复制代码安装上述的三方包，当然也可以后续按需安装，这样更能清楚每个包是做什么的npm install @moyuyc/inquirer-autocomplete-prompt commander chalk commander fuzzy inquirer json-format --save\r\n复制代码在package.json里添加bin字段, 将自定义的命令软连到全局环境，同时执行npm link创建链接，这里如果报错{code EACCES，errno:13，...}，是因为权限不足，可以尝试sudo npm link\"bin\": {\r\n    \"cli-demo\": \"./index.js\"\r\n  }\r\n复制代码在入口文件，index.js 行首加入一行指定当前脚本由node.js进行解析#!/usr/bin/env node\t\t\t// 指定运行环境\r\n\r\n// 输出文本\r\nconsole.log('Hello World!!!');\r\n复制代码这时可以在命令行中执行 cli-demo 验收一下成果了ok，可以看到当在全局状态下输入自定义命令时，正确运行了入口文件，也就意味着的开发玩具已经搭建完成Let‘ Go整理逻辑以快速创建页面模版文件为例，就需要考虑需要哪些逻辑:设置页面名称找到已有模版文件copy到项目中修改app.json识别命令行在刚才的 Hello World!!! 环节，已经可以正确识别cli-demo，但是需要在一个cli工具中集成更多功能，可能需要有不同的执行策略，以git为例： git clone, git status，git push ，所以需要识别不同的命令和参数，是时候就需要用到 commander 这个第三方包帮助解析命令行参数了，当然你也可以自己撸一个lib，本质上还是方便解析 process.argvindex.js (本质上这个js就是一个路由)#!/usr/bin/env node\r\n\r\nconst version                       = require('./package').version;                 // 版本号\r\n\r\n/* = package import\r\n-------------------------------------------------------------- */\r\n\r\nconst program                       = require('commander');                         // 命令行解析\r\n\r\n/* = task events\r\n-------------------------------------------------------------- */\r\nconst createProgramFs               = require('./lib/create-program-fs');           // 创建项目文件\r\n\r\n\r\n/* = config\r\n-------------------------------------------------------------- */\r\n\r\n// 设置版本号\r\nprogram.version(version, '-v, --version');\r\n\r\n/* = deal receive command\r\n-------------------------------------------------------------- */\r\n\r\nprogram\r\n    .command('create')\t\t\r\n    .description('创建页面或组件')\r\n    .action((cmd, options) => createProgramFs(cmd));\r\n\r\n/* 后续可以根据不同的命令进行不同的处理，可以简单的理解为路由 */\r\n// program\r\n//     .command('build [cli]')\r\n//     .description('执行打包构建')\r\n//     .action((cmd, env) => callback);\r\n\r\n/* = main entrance\r\n-------------------------------------------------------------- */\r\nprogram.parse(process.argv)\r\n复制代码这时候当键入 cli-demo create 时会自动执行createProgramFscreateProgramFs.jsmodule.exports = function () {\r\n    console.log('Hi, create-program-fs.js');\r\n};\r\n复制代码命令行输入 cli-demo create可以看到已经成功的 开辟出了一块独立的业务模块 ，后续就只需要依据需求填补相应的内容即可创建交互命令收到执行命令，这个时候按第一张图，是需要开始一系列QA（当然你也可以不做交互式，直接配置命令行参数），引入三方包  inquirer ，来指定问题队列const question = [\r\n  \r\n    // 选择模式使用 page -> 创建页面 | component -> 创建组件\r\n    {\r\n        type: 'list',\r\n        name: 'mode',\r\n        message: '选择想要创建的模版',\r\n        choices: [\r\n            'page',\r\n            'component',\r\n        ]\r\n    },\r\n    \r\n    // 设置名称\r\n    {\r\n        type: 'input',\r\n        name: 'name',\r\n        message: answer => `设置 ${answer.mode} 名称 (e.g: index):`,\r\n    },\r\n];\r\n\r\nmodule.exports = function() {\r\n\t\r\n    // 问题执行\r\n    inquirer.prompt(question).then(answers => {\r\n\t\tconsole.log(answers);\r\n    });\r\n};\r\n复制代码、可以看到通过一系列QA交互， 实际输出拿到的是一个json对象，第一步已完成创建模版文件创建一个 存放模版文件的文件夹template ，并准备好你希望的模版项目中使用模版文件为了方便阅读，下面的代码，需要明确下面变量的定义， Config.dir_root  = 命令行执行目录 Config.root  = cli项目根目录 Config.appRoot = 小程序项目路径 Config.template = 模版目录这里有两个点，一个是执行路径的问题，另一个是分包的问题，具体如下：执行路径这里一定要弄明白**__dirname， process.cwd()**的区别，同时还有一些小程序是自己搭的gulp/webpack，可能小程序项目是在src目录下，一定要分清楚__dirname： 被执行js文件的绝对路径，一般在index.js执行时缓存起来 作为项目的全局路径，比如找到template文件夹就会使用 ${__dirname}/templateprocess.cwd()：当前 命令行运行时的工作目录 ，比如在/Users/xuan/Documents/cli-demo如果当前项目在src，或其他文件夹里怎么办？可以提供一个给用户项目中的配置文件，类似于gulpfile.js或是webpack.config.js的形式，内容例如（具体可以看 git仓库 ）module.exports = {\r\n\r\n    // 小程序路径\r\n    app: './src',\r\n\r\n    // 模版文件夹\r\n    template: './template'\r\n};\r\n复制代码可以看到对象中app属性，可以 指定你当前小程序项目的路径分包因为小程序的分包机制会导致页面实际路径与在主包的路径不相符，例如：主包：pages/index/index分包：pages/main_module/pages/habit_enlist/habit_enlist解决这个问题一方面是要有页面创建要有一定的 规范，统一格式 ，另一方面需要 根据规则解析app.json，上面的主包，分包路径差不多是我目前使用的规范解析app.json// 获取app.json\r\nfunction getAppJson() {\r\n    let appJsonRoot = path.join(Config.appRoot, '/app.json');\r\n    try {\r\n        return require(appJsonRoot);\r\n    }catch (e) {\r\n        Log.error(`未找到app.json, 请检查当前文件目录是否正确，path: ${appJsonRoot}`);\r\n        process.exit(1);\t\t\t// 异常退出\r\n    }\r\n}\r\n\r\n// 解析app.json\r\nlet parseAppJson = () => {\r\n\r\n    // app Json 原文件\r\n    let appJson = __Data__.appJson = getAppJson();\r\n\r\n    // 获取主包页面\r\n    appJson.pages.forEach(path => __Data__.appPagesList[getPathSubSting(path)] = '');\r\n\r\n    // 获取分包，页面列表\r\n    appJson.subPackages.forEach(item => {\r\n        __Data__.appModuleList[getPathSubSting(item.root)] = item.root;\r\n        item.pages.forEach(path => __Data__.appPagesList[getPathSubSting(path)] = item.root);\r\n    });\r\n};\r\n\r\n// __Data__.appPagesList = 小程序全部页面\r\n// __Data__.appModuleList = 小程序全部分包页面\r\n// item结构 {util_module: 'pages/util_module/'}，这么定义结构是为了方便后续取数\r\n复制代码question队列里，增加删选分包的选项// 设置page所属module\r\n    {\r\n        type: 'autocomplete',\r\n        name: 'modulePath',\r\n        message: 'Set page ownership module',\r\n        choices: [],\r\n        suggestOnly: false,\r\n        source(answers, input) {\r\n            // none 代表放在主包\r\n            return Promise.resolve(fuzzy.filter(input, ['none', ...Object.keys(__Data__.appModuleList)]).map(el => el.original));\r\n        },\r\n        filter(input) {\r\n            if (input === 'none') {\r\n                return '';\r\n            }\r\n            return __Data__.appModuleList[input];\r\n        },\r\n        when(answer) {\r\n            return answer.mode === 'page';\r\n        }\r\n    }\r\n复制代码autocomplete类型本质上是个列表，但是可以进行模糊查询，非常方便，像小打卡有接近30个分包的情况下效果尤为明显有了文件名，有了分包路径，有了可供copy的模版，接下来就很简单了，把模版文件塞进项目就可以了，下面是一串从仓库里copy的代码，利用async/await很方便的写出一维代码，基本上的流程:获取路径 -> 校验 -> 获取文件信息 -> 复制文件 -> 修改app.json -> 输出结果信息async function createPage(name, modulePath = '') {\r\n\r\n    // 获取模版文件路径\r\n    let templateRoot = path.join(Config.template, '/page');\r\n    if (!Util.checkFileIsExists(templateRoot)) {\r\n        Log.error(`未找到模版文件, 请检查当前文件目录是否正确，path: ${templateRoot}`);\r\n        return;\r\n    }\r\n    \r\n    // 获取业务文件夹路径\r\n    let page_root = path.join(Config.appRoot, modulePath, '/pages', name);\r\n\r\n    // 查看文件夹是否存在\r\n    let isExists = await Util.checkFileIsExists(page_root);\r\n    if (isExists) {\r\n        Log.error(`当前页面已存在，请重新确认, path: ` + page_root);\r\n        return;\r\n    }\r\n\r\n    // 创建文件夹\r\n    await Util.createDir(page_root);\r\n\r\n    // 获取文件列表\r\n    let files = await Util.readDir(templateRoot);\r\n\r\n    // 复制文件\r\n    await Util.copyFilesArr(templateRoot, `${page_root}/${name}`, files);\r\n\r\n    // 填充app.json\r\n    await writePageAppJson(name, modulePath);\r\n\r\n    // 成功提示\r\n    Log.success(`createPage success, path: ` + page_root);\r\n}\r\n复制代码扩展一个基本的快速创建页面模版的cli工具就这样完成，但是有可能需要更多的一些功能自定义模版比如说每个项目的模版都有可能不太一样，很大程度上需要根据项目进行定制，这时候可能就需要前文提到的给用户开放config文件的插槽了项目中的config：// xdk.config.js\r\nmodule.exports = {\r\n\r\n    // 小程序路径\r\n    app: './',\r\n\r\n    // 模版文件夹\r\n    template: './template'\r\n};\r\n\r\n// create-program-fs.js\r\nmodule.exports = function() {\r\n\t\r\n     // 校验：当前是否存在配置文件\r\n    let customConfPath = `${Config.dir_root}/xdk.config.js`;\r\n    if (!Util.checkFileIsExists(customConfPath)) {\r\n        Log.error('当前项目尚未创建xdk.config.js文件');\r\n        return;\r\n    }\r\n\r\n    // 获取用户配置项\r\n    let {app, template = ''} = require(customConfPath);\r\n\r\n    // 小程序目录\r\n    Config.appRoot = path.resolve(path.join(Config.dir_root, app));\r\n\r\n    // 模版文件目录（默认使用cli提供的默认模版，当config文件有设置template路径时，使用自定义路径）\r\n    !!template && (Config.template = path.resolve(path.join(Config.dir_root, template))));\r\n    \r\n    // 问题执行\r\n    inquirer.prompt(question).then(answers => {\r\n\t\tconsole.log(answers);\r\n    });\r\n};\r\n复制代码发布的npm仓库目前从开发到调试本质上是在本地提供服务，利用npm link提供软连接到全局PATH，其实也可以直接发到npm上，让其他使用的该cli的成员一建安装，比如npm install -g xxxxxxx, 具体教程的话百度，google有很多，作者表示很懒，遇到问题下面留言吧。。最后可以看到整个功能逻辑相对于平时写的复杂的业务逻辑来说相对简单，主要是工具库的一些使用方面的东西，中间的难点可能就是node中概念性的一些东西，然而这些多看一下文档基本就可以解决，希望大家可以从本文中了解到如何 快速搭建一个属于自己的cli工具顺便预告下后续的话可能会更新一些如何利用cli工具做到自动化发布，版本号控制，环境变量切换，自动生成文档等一系列有趣的功能"}
{"title": "小程序日历组件 ", "author": "Rolan", "put_time": "2019-7-19 00:42", "content": "程序日历组件\r\n闲来没事把之前想做的日历组件给做了 先上图\r\n\r\n参数\r\n\r\n        \r\n            参数\r\n            类型\r\n            说明\r\n            默认值\r\n        \r\n        \r\n            header\r\n            Boolean\r\n            是否显示头部操作栏\r\n            true\r\n        \r\n        \r\n            preMonth\r\n            Boolean\r\n            是否显示上个月按钮\r\n            true\r\n        \r\n         \r\n            nextMonth\r\n            Boolean\r\n            是否显示下个月按钮\r\n            true\r\n        \r\n         \r\n            preYear\r\n            Boolean\r\n            是否显示上一年按钮\r\n            false\r\n        \r\n         \r\n            nextYear\r\n            Boolean\r\n            是否显示下一年按钮\r\n            false\r\n        \r\n         \r\n            today\r\n            Boolean\r\n            是否显示今天按钮\r\n            false\r\n        \r\n        \r\n            weeks\r\n            Boolean\r\n            是否显示周标题\r\n            true\r\n        \r\n        \r\n            weeksType\r\n            String\r\n            周标题类型\r\n            cn\r\n        \r\n        \r\n            showMoreDays\r\n            Boolean\r\n            是否显示前后月份残余数据\r\n            false\r\n        \r\n        \r\n            formatType\r\n            String\r\n            日期连接符\r\n            -\r\n        \r\n    \r\n事件\r\n\r\n\r\n\r\n事件名称\r\n说明\r\n\r\n\r\n\r\n\r\nselect\r\n在选择日期时触发，返回选中的日期\r\n\r\n\r\n\r\n示例\r\nindex.wxml\r\n<calendar today=\"{{true}}\" bind:select=\"select\"></calendar>\r\n复制代码index.json\r\n\"usingComponents\": {\r\n        \"calendar\": \"../../../components/calendar/index\"\r\n    }\r\n复制代码index.js\r\nselect(e) {\r\n        console.log(e)\r\n    },\r\n复制代码返回选中的日期 e.detail.value\r\n\r\n详细代码看github\r\ngithub"}
{"title": "当微信小程序遇上TensorFlow - 官方文档 ", "author": "Rolan", "put_time": "2019-7-19 00:32", "content": "前一段时间为了在微信小程序中使用tensorflow.js，对tfjs-core代码做了一些修改，具体情况请参考我之前写的几篇文档：重磅好消息！ TensorFlow开始支持微信小程序当微信小程序遇上TensorFlow - tensorflow.js篇当微信小程序遇上TensorFlow - 本地缓存模型后来，我厚着脸皮向tensorflow/tfjs-core项目提交了一个PR，不出意外，这个提交被拒了。当然谷歌的开发人员还是比较友好，给了我一个文档链接：https://mp.weixin.qq.com/wxopen/plugindevdoc?appid=wx6afed118d9e81df9原来google有一份这样的开发指导文档，而且还是中文的，为啥没在tfjs的文档中列出？ 循着这份文档，我还找到了tensorflow项目组的tfjs微信小程序示例：https://github.com/tensorflow/tfjs-wechat/tree/master/demo/mobilenet这个项目说明也是中文的，看来微信小程序虽然红红火火，但真的还是仅限于中文世界。就如同我所预想的，按照这个文档，一定不会那么顺利，实际做下来，也确实印证了这一点，下面就谈谈几个要点：官方是采用微信小程序插件来增加tensorflow js支持的，要在微信小程序中使用tfjs插件， 不能使用测试号 ，需要在小程序管理后台的“设置-第三方服务-插件管理”中添加插件。具体方法为：开发者可登录小程序管理后台，通过 appid [wx6afed118d9e81df9] 查找插件并添加。本插件无需申请，添加后可直接使用。直接导入github.com/tensorflow/tfjs-wechat/tree/master/demo/mobilenet中的代码，到了 点击微信开发工具中的‘构建npm’菜单 这一步，总是提示：没有找到可以构建的 npm 包尝试了很多次，也上网寻求帮助，始终无法解决。后来还是决定自己新建一个项目，然后在项目根目录执行：$ npm init在后续的提示里，一直按回车键，使用默认值：This utility will walk you through creating a package.json file.\r\nIt only covers the most common items, and tries to guess sensible defaults.\r\n\r\nSee `npm help json` for definitive documentation on these fields\r\nand exactly what they do.\r\n\r\nUse `npm install <pkg>` afterwards to install a package and\r\nsave it as a dependency in the package.json file.\r\n\r\nPress ^C at any time to quit.\r\npackage name: (wechat-tfjs-examples)\r\nversion: (1.0.0)\r\ndescription:\r\nentry point: (app.js)\r\ntest command:\r\ngit repository: (https://github.com/mogoweb/wechat-tfjs-examples)\r\nkeywords:\r\nauthor:\r\nlicense: (ISC)\r\nAbout to write to D:\\work\\ai\\wechat-tfjs-examples\\package.json:\r\n\r\n{\r\n  \"name\": \"wechat-tfjs-examples\",\r\n  \"version\": \"1.0.0\",\r\n  \"description\": \"微信小程序中使用TensorFlow js的示例代码，pages下面每个目录一个示例。\",\r\n  \"main\": \"app.js\",\r\n  \"scripts\": {\r\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\r\n  },\r\n  \"repository\": {\r\n    \"type\": \"git\",\r\n    \"url\": \"git+https://github.com/mogoweb/wechat-tfjs-examples.git\"\r\n  },\r\n  \"author\": \"\",\r\n  \"license\": \"ISC\",\r\n  \"bugs\": {\r\n    \"url\": \"https://github.com/mogoweb/wechat-tfjs-examples/issues\"\r\n  },\r\n  \"homepage\": \"https://github.com/mogoweb/wechat-tfjs-examples#readme\"\r\n}\r\n\r\nIs this OK? (yes)在项目下多了package.json文件，往该文件中添加：\"devDependencies\": {\r\n    \"miniprogram-api-typings\": \"^2.6.5-2\"\r\n  },\r\n  \"dependencies\": {\r\n    \"@tensorflow/tfjs-core\": \"1.2.2\",\r\n    \"@tensorflow/tfjs-converter\": \"1.2.2\",\r\n    \"@tensorflow/tfjs-layers\": \"1.2.2\",\r\n    \"fetch-wechat\": \"0.0.3\"\r\n  }接着执行：$ npm install再点击开发工具中的 构建npm ，就可以继续下去。这时可能会弹出提示：未找到npm包入口文件忽略之。3. TensorFlow.js有一个联合包 - @tensorflow/tfjs，包含了四个分npm包：tfjs-core: 基础包\r\ntfjs-converter: GraphModel 导入和执行包\r\ntfjs-layers: LayersModel 创建，导入和执行包\r\ntfjs-data：数据流工具包 对于小程序而言，由于有2M的app大小限制，不建议直接使用联合包，而是按照需求加载分包。\r\n如果小程序只需要导入和运行GraphModel模型的的话，建议只加入tfjs-core和tfjs-converter包。这样可以尽量减少导入包的大小。如果需要创建,导入或训练LayersModel模型，需要再加入 tfjs-layers包。在我的示例代码中，使用到tfjs-core和tfjs-layers包，导入代码如下：import * as tf from '@tensorflow/tfjs-layers';\r\nimport * as tfc from '@tensorflow/tfjs-core';小结使用tensorflow的官方方法，可以跟上tfjs的最新进展，可以在第一时间上使用最新特性，推荐使用这种方法。但我之前的尝试也不是毫无价值，tfjs官方没有增加对模型本地缓存的支持，每次都需要从网络加载模型，当然不排除以后tfjs官方也会添加这样的特性。我把调试好的tensorflow示例放在github上，请访问：https://github.com/mogoweb/wechat-tfjs-examples然后切换到 official 分支。"}
{"title": "垃圾分类小程序 ", "author": "Rolan", "put_time": "2019-7-22 00:13", "content": "垃圾分类，从我做起最近垃圾分类比较火，各大城市纷纷开始实施垃圾分类制度，提高垃圾的资源价值和经济价值。但是垃圾分类不好记，然后我自己捣鼓了一款垃圾分类小程序，来帮助大家进行垃圾分类。:smile: 做小程序的同时自己也学习了一波。小程序（垃圾的小窝）该程序实现了文字搜索，图像识别，查看分类等功能，非常具有实用性。下面贴几张图：暂时就贴这几张图了，想要了解更多，可以搜索 垃圾的小窝 或者扫小程序码体验。开发技术栈这次开发用到的技术栈有Taro+TS+Stylus，不得不说，框架还是比原生坑多的，如果不做多端的话不建议尝试框架。后续我可能会发布支付宝小程序端。希望大家能支持。小程序码欢迎大家体验:clap:并给出建议。源码地址： https://github.com/webpig/gar..."}
{"title": "通过json用canvas生成分享海报,支持微信小程序和web ", "author": "Rolan", "put_time": "2019-6-19 00:39", "content": "需求在项目里写过几个canvas生成分享海报页面后,觉得这是个重复且冗余的工作.于是就想有没有能通过类似json直接生成海报的库.然后就在github找到到两个项目:wxa-plugin-canvas ,不太喜欢配置文件的写法.就没多去了解mp_canvas_drawer ,使用方式就比较符合直觉,不过可惜功能有点少.然后就想着能不能自己再造个轮子.于是就有了这个项目 json2canvas ,你可以简单的理解为是mp_canvas_drawer的增强版吧.json2canvas canvas绘制海报,写个json就够了.项目的canvas绘制是基于 cax 实现的.所以天然的带来一个好处,json2canvas同时支持小程序和web功能支持缩放. 如果设计稿是750,而画布只有375时.你不需要任何换算,只需要将scale设置为0.5即可.支持图片圆角支持圆型,矩形,矩形圆角(背景色支持线性渐变)长文本自动换行(感谢 coolzjy@v2ex 提供的正则 https://regexr.com/4f12l ,优化了换行的计算方式(不会粗暴的折断单词))支持分组(cax里很好用的一个功能)同时支持小程序和web示例demo-web 界面左边的json,可以进行编辑,直接看效果哟~小程序demogit clone https://github.com/willnewii/json2canvas.git\r\n微信开发者工具导入项目 example/weapp/小程序安装npm i json2canvas\r\n微信开发者工具->工具->构建npm在需要使用的界面引入Component{\r\n  \"usingComponents\": {\r\n    \"json2canvas\":\"/miniprogram_npm/json2canvas/index\"\r\n  }\r\n}举个例子想要生成一个这样的海报,需要怎么做？(红框是图片元素,蓝框是文字元素,其余的是一张背景图。)简单,一个json搞定.具体支持的元素和参数,请查看项目 readme{\r\n        \"width\": 750,\r\n        \"height\": 1334,\r\n        \"scale\": 0.5,\r\n        \"children\": [\r\n            {\r\n                \"type\": \"image\",\r\n                \"url\": \"http://res.mayday5.me/wxapp/wxavatar/tmp/bg_concerts_1.jpg\",\r\n                \"width\": 750,\r\n                \"height\": 1334\r\n            }, {\r\n                \"type\": \"image\",\r\n                \"url\": \"http://res.mayday5.me/wxapp/wxavatar/tmp/wxapp_code.jpg\",\r\n                \"width\": 100,\r\n                \"x\": 48,\r\n                \"y\": 44,\r\n                \"isCircular\": true,\r\n            }, {\r\n                \"type\": \"circle\",\r\n                \"r\": 50,\r\n                \"lineWidth\": 5,\r\n                \"strokeStyle\": \"#CCCCCC\",\r\n                \"x\": 48,\r\n                \"y\": 44,\r\n            }, {\r\n                \"type\": \"text\",\r\n                \"text\": \"歌词本\",\r\n                \"font\": \"30px Arial\",\r\n                \"color\": \"#FFFFFF\",\r\n                \"x\": 168,\r\n                \"y\": 75,\r\n                \"shadow\": {\r\n                    \"color\": \"#000\",\r\n                    \"offsetX\": 2,\r\n                    \"offsetY\": 2,\r\n                    \"blur\": 2\r\n                }\r\n            }, {\r\n                \"type\": \"image\",\r\n                \"url\": \"http://res.mayday5.me/wxapp/wxavatar/tmp/medal_concerts_1.png\",\r\n                \"width\": 300,\r\n                \"x\": \"center\",\r\n                \"y\": 361\r\n            }, {\r\n                \"type\": \"text\",\r\n                \"text\": \"一生活一场 五月天\",\r\n                \"font\": \"38px Arial\",\r\n                \"color\": \"#FFFFFF\",\r\n                \"x\": \"center\",\r\n                \"y\": 838,\r\n                \"shadow\": {\r\n                    \"color\": \"#000\",\r\n                    \"offsetX\": 2,\r\n                    \"offsetY\": 2,\r\n                    \"blur\": 2\r\n                }\r\n            }, {\r\n                \"type\": \"text\",\r\n                \"text\": \"北京6场，郑州2场，登船，上班，听到你想听的歌了吗？\",\r\n                \"font\": \"24px Arial\",\r\n                \"color\": \"#FFFFFF\",\r\n                \"x\": \"center\",\r\n                \"y\": 888,\r\n                \"shadow\": {\r\n                    \"color\": \"#000\",\r\n                    \"offsetX\": 2,\r\n                    \"offsetY\": 2,\r\n                    \"blur\": 2\r\n                }\r\n            }, {\r\n                \"type\": \"rect\",\r\n                \"width\": 750,\r\n                \"height\": 193,\r\n                \"fillStyle\": \"#FFFFFF\",\r\n                \"x\": 0,\r\n                \"y\": \"bottom\"\r\n            }, {\r\n                \"type\": \"image\",\r\n                \"url\": \"http://res.mayday5.me/wxapp/wxavatar/tmp/wxapp_code.jpg\",\r\n                \"width\": 117,\r\n                \"height\": 117,\r\n                \"x\": 47,\r\n                \"y\": 1180\r\n            }, {\r\n                \"type\": \"text\",\r\n                \"text\": \"长按识别小程序二维码\",\r\n                \"font\": \"26px Arial\",\r\n                \"color\": \"#858687\",\r\n                \"x\": 192,\r\n                \"y\": 1202\r\n            }, {\r\n                \"type\": \"text\",\r\n                \"text\": \"加入五月天 永远不会太迟\",\r\n                \"font\": \"18px Arial\",\r\n                \"color\": \"#A4A5A6\",\r\n                \"x\": 192,\r\n                \"y\": 1249\r\n            }]\r\n    }问题反馈有什么问题可以直接 提issue"}
{"title": "微信小程序 封装路由 mini-router ", "author": "Rolan", "put_time": "2019-4-22 00:38", "content": "1.介绍mini-router 是一个在微信小程序中使用的路由模块，主要用于在小程序中的路由模块化和解耦，解决小程序中的路由地址的硬编码。 Github: https://github.com/hellolad/mini-router原生路由：// 用法：1wx.navigateTo({  url: \"/pages/logs/logs\"})// 用法：2wx.navigateTo({  url: \"/pages/logs/logs\",  success(res) {    console.log(\"success\", res)   },  fail(err) {    console.log(\"fail\", err)  },  complete() {    console.log(\"complete\")  }})// 用法：3（传参）wx.navigateTo({  url: \"/pages/logs/logs?key=value\",})mini-router// 用法：1app.$router.push(\"logs\")// 用法：2app.$router.push(\"mine\")  .success(res => {    console.log(\"success: \", res)  })  .fail(err => {    console.log(\"fail: \", res)  })  .complete(_ => {    console.log(\"complete\")  })// 用法：3 (传参)app.$router.push(\"logs\", { key: value })2.使用方法// 第一步：导入router模块，并且在app.js里 给app设置一个属性$router// app.jsimport MiniRouter from './route/router'onLaunch: function () {  this.$router = new MiniRouter()},// 第二步：配置route文件夹中的pages模块 （url 直接复制app.json里的pages）export default [  {    url: 'pages/index/index',    name: 'index'  },  {    url: 'pages/article/article',    name: 'article'  },  {    url: 'pages/mine/mine',    name: 'mine'  },  {    url: 'pages/logs/logs',    name: 'logs'  },  {    url: 'pages/login/login',    name: 'login'  },  {    url: 'pages/next/next',    name: 'next'  }]// 第三步：在需要的文件里 使用app.$router.push(\"logs\")3.支持的方法目前mini-router支持微信小程序里的路由的所有方法，函数名对比:4.函数介绍push(name, params = null) 保留当前页面，跳转到应用内的某个页面。但是不能跳到 tabbar 页面reLaunch(name, params = null) 关闭所有页面，打开到应用内的某个页面 可传递参数 可跳转到Tabbar页面redirect(name, params = null) 关闭所有页面，打开到应用内的某个页面 可传递参数 不可重定向到Tabbar页面switchTab(name) 跳转到指定的Tabback(delta = 1, params = null) 关闭当前页面，返回上一页面或多级页面。 没有参数 代表返回上一页backHome(params = null) 关闭所有页面返回到首页5.错误处理当你输入一个在pages模块中找不到的路由时(log)，mini-router会抛出错误，例如：app.$router.push(\"log\", { log: \"这是一个Log\" })// 打印/*!! Not found page ->：[log] !!; [Component] Event Handler Error @ pages/index/index#bound handlePushLogs*/6.获取传递的参数mini-router内置了一个属性params，它会根据你跳转的页面，动态的更换当前属性的值。// 当我传递了一个参数 { log: \"这是一个Log\" }app.$router.push(\"logs\", { log: \"这是一个Log\" })// 然后我在下一个界面的onShow/onLoad里接收const params = app.$router.paramsparams.log // 这是一个Log参数存储在storage里，你可以通过小程序调试工具看到:mini-router params获取参数时，你不必知道它存储在storage里的key是什么，你只要拿app.$router.params就可以了7.反向传值mini-router 通过back或者backHome函数实现反向传值（反向携带参数）app.$router.back(1, { isLogin: false })// 中间页传值给最后一页，最后一页携带值给首页const { data } = app.$router.paramsapp.$router.backHome({ data })当你选择不携带参数返回时，在首页你将拿不到app.$router.params,因为mini-router会把params软删除，如果你需要的话，你还是可以从storage里拿到它。8.状态处理mini-router同小程序一样，提供三种状态success， fail， complete 不同于小程序，mini-router使用链式调用来处理这三种状态，app.$router.push(\"mine\")  .success(res => {    console.log(\"success: \", res)  })  .fail(err => {    console.log(\"fail: \", res)  })  .complete(_ => {    console.log(\"complete\")  })9.query方式传参上面的都是通过params传参，传的参数缓存在了storage里，新增加的query类型传参，将参数拼接到了url后面:/** * Query 方式传递参数 */handlePushLogsQuery() {  app.$router.push(\"logs\", { log: \"这是一个Log\", name: \"hellolad\"}, 'query')},handlePushLoginQuery() {  app.$router    .push(\"login\", { phoneNumber: \"1561900000000\" }, 'query')    .success(res => {      console.log(\"success: \", res)    })},handleReLaunchArticleQuery() {  app.$router.reLaunch(\"article\", { articleId: '10002' }, 'query')    .success(res => {      console.log(\"success: \", res)    })},handleRedirectLoginQuery() {  app.$router.redirect(\"login\", { phoneNumber: '1561900000000' }, 'query')    .success(res => {      console.log(\"success: \", res)    })},// 获取参数和普通的params传参获取参数一样:const { phoneNumber } = app.$router.params// 也可以在onLoad(options)里获取console.log(\"login options\", options)// 生成的url类似：/pages/login/login?phoneNumber=1561900000000寄语：对于前端来说，可以说初窥门径，想要更深入一步，还是要坚持不断的学习和看源码。mini-router可以实现小程序里路由的跳转，也将成为我下一个小程序使用的路由模块，如果有不足的地方欢迎题issuse，如果有好的想法，欢迎pull request。Github: https://github.com/hellolad/mini-router"}
{"title": "微信小程序Page对象重写 ", "author": "Rolan", "put_time": "2019-4-23 00:21", "content": "关于重写微信小程序Page对象如下：let orgainPage = Page; // 保存原本的Page对象\r\nlet basePage = function (data) {\r\n  // 生成初始data，如果页面已经有该值不在重新赋值\r\n  if (typeof data.data.dataVal === 'undefined') {\r\n    data.data.dataVal = '具体值';\r\n  }\r\n  // 重写onLoad默认执行一些初始事件\r\n  let orgainOnLoad = data.onLoad;\r\n  data.onLoad = function (o) {\r\n    // 执行的初始事件 start\r\n\r\n    // 执行的初始事件 end\r\n    orgainOnLoad.call(this, o);\r\n  }\r\n  // 默认初始方法，如果页面已经有该方法不在重写该方法\r\n  if (typeof data.orgainFun !== 'function') {\r\n    data.orgainFun = function () {\r\n      // 执行具体函数 start\r\n\r\n      // 执行具体函数 end\r\n    }\r\n  }\r\n  return orgainPage(data);\r\n}; 重写后的Page可以直接挂到App里面App({\r\n  onLaunch() { },\r\n   // 直接挂到这边，新页面直接调用app.Base替换Page\r\n  Base: basePage,\r\n  globalData: {}\r\n})不直接重写Page是因为使用app.json插件时，不允许修改全局变量“Page”。 每个Page页面调用const app = getApp();\r\napp.Base({\r\n  data: {\r\n  }\r\n})页面必须有data,不然.call会报错。"}
{"title": "服务端使用 nodejs 获取带参微信小程序码图片 ", "author": "Rolan", "put_time": "2019-4-23 00:25", "content": "服务器使用 nodejs 请求获取微信小程序图片的教程，附详细代码。\r\n\r\n\r\n此文于2018.09.19完成，无法保证现在微信小程序的接口没有改变。\r\n\r\n调研\r\n首先看微信小程序的 获取二维码 文档，可以看到微信支持三种接口，其中只有B接口没有生成个数限制，长远来看，我选择使用 B 接口。\r\n根据文档，要使用 B 接口生成小程序码，就需要一个 access_token，这个 token 可以通过另一个接口传入appId和密钥来获得。详情看 该接口文档。\r\n实现\r\n获取 access_token\r\nnodejs 的版本为 8.x。\r\n考虑到服务端发送的请求并不多，不打算引入 request、axios 之类的三方库，用原生 https 模块实现（其实我只是想学习 nodejs 的原生 api 哈）。\r\n首先，要获取 access_token，要用到 appid 和 appsecret。\r\nconst https = require('https');\r\nhttps.get(`https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&appid=${appid}&secret=${appsecret}`, res => {\r\n    let resData = '';\r\n    res.on('data', data => {\r\n        resData += data;\r\n    });\r\n    res.on('end', () => {\r\n        resData = JSON.parse(resData);\r\n    })\r\n})\r\n复制代码通过 end 事件，我们获得了返回的完整的 JSON 对象 resData。\r\n如果参数正确的话，会返回 {\"access_token\":\"ACCESS_TOKEN\",\"expires_in\":7200} 这样的 JSON 对象。expires_in 指的是 token 的有效期时间，单位是秒，获取了这个对象后，我添加了一个 timestamp 属性，存储当前时间，来确定这个 access_token 什么时候过期。这个对象，你可以存在 global 下，但最好存到 redis，这样即使你重启服务器就不需要重新获取 access_token 了。\r\n获取小程序码图片\r\n有了 access_token，我们就可以通过 post 请求来获取图片二进制流了。\r\n发送 post 请求，要用到 https.request 方法，比 https.get 要复杂一点。\r\n首先我们用自带的 url 模块，将 url 字符串转换为 URL 对象。因为我们要用到 post 方法，并指定一些headers，所以还要给这个对象追加一些属性。 url 字符串转为对象有两种方法，一种是 new URL(<urlString>)，还有一个是 url.parse(<urlString>)。请不要使用第一种方式，因为给转换后的对象添加属性，然后转为 JSON 对象时，不会存在（具体原因不明，有空我研究下。）第二种方式生成的对象则没有这些问题。\r\n具体代码如下：\r\nconst url = require('url');\r\nlet options = url.parse(`https://api.weixin.qq.com/wxa/getwxacodeunlimit?access_token=${access_token}`);\r\n\r\n// 添加必要的属性\r\noptions = Object.assign(options, {\r\n    method: 'POST',\r\n    headers: {\r\n        // 'Content-Length': Buffer.byteLength(post_data),\r\n        'Content-Type': 'application/json',\r\n        'Content-Length': post_data.length,\r\n    }\r\n});\r\n复制代码这里的 post_data 其实就是请求主题里的数据。\r\n注意获取二维码的 api 文档里的 Bug & Tip 明确说明了, POST 参数需要转成 json 字符串，不支持 form 表单提交。\r\nconst post_data = JSON.stringify({\r\n    scene: '你要传的参数',      // 最多32个字符。\r\n    width: 200,               // 生成的小程序码宽度。\r\n});\r\n复制代码然后我们就可以用 https.request 方法去请求图片了\r\nlet req = https.request(options, (res) => {\r\n    let resData = '';\r\n    res.setEncoding(\"binary\");\r\n    res.on('data', data => {\r\n        resData += data;\r\n    });\r\n    res.on('end', () => {\r\n        // 微信api可能返回json，也可能返回图片二进制流。这里要做个判断。\r\n        // errcode:42001 是指 token 过期了，需要重新获取。40001 是指token格式不对或很久之前的token。\r\n        const contentType = res.headers['content-type'];\r\n        if ( !contentType.includes('image') ) {\r\n            console.log('获取小程序码图片失败，微信api返回的json为：')\r\n            console.log( JSON.parse(resData) )\r\n            return resolve(null);\r\n        }\r\n        const imgBuffer = Buffer.from(resData, 'binary');\r\n        resolve( {imgBuffer, contentType} );\r\n    });\r\n});\r\nreq.on('error', (e) => {\r\n    console.log('获取微信小程序图片失败')\r\n    console.error(e);\r\n});\r\nreq.write(post_data);   // 写入post请求的请求主体。\r\nreq.end();\r\n复制代码注意点：\r\n\r\n\r\n这里比较重要的是这个 res.setEncoding(\"binary\");，因为服务器默认返回的数据会编码为 utf8 格式，但我们只需要二进制，且二进制转 utf8 再转回二进制貌似会丢失数据（具体我还不知道为什么）。\r\n\r\n\r\n另外，这个返回的 req 对象，可以诸如 setHeader(name, value), getHeader(name), removeHeader(name) 的api，直到你使用 request.end() 才真正把请求发送出去。如果你忘了调用 request.end 而执行了代码，过了一段时间会报一个超时错误。\r\n\r\n\r\n考虑到返回的不一定是图片，也有可能返回 JSON，所以做了一些判断。\r\n\r\n\r\n如果参数比较固定，你可以把图片下载下来，将图片路径映射到 redis 上，做个缓存。用户第二次访问的时候，直接传对应的图片就行了。\r\n\r\n\r\n完整代码（仅供参考）\r\n下面是完整代码和一些简单的注释，另外因为使用了 Koa 框架，需要用到 async/await 的同步方式，我把请求包装成了 Promise。\r\nconst https = require('https');\r\nconst url = require('url');\r\n\r\nconst uid = '你要传的参数';\r\n\r\nconst S_TO_MS = 1000;  // 秒到毫秒的转换。\r\nif (!global.access_token || global.access_token.timestamp + global.access_token.expires_in * S_TO_MS <= new Date() - 300) {\r\n    // 过期，获取新的 token\r\n    const appid = '小程序的appId';\r\n    const appsecret = '密钥';\r\n\r\n    const accessTokenObj = await new Promise( (resolve, reject) =>{\r\n        https.get(`https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&appid=${appid}&secret=${appsecret}`, res => {\r\n            let resData = '';\r\n            res.on('data', data => {\r\n                resData += data;\r\n            });\r\n            res.on('end', () => {\r\n                resolve( JSON.parse(resData) );\r\n            })\r\n        })\r\n    }).catch(e => {\r\n        console.log(e);\r\n    });\r\n    \r\n    // 这里应该加一个判断的，因为可能请求失败，返回另一个 JSON 对象。\r\n    global.access_token = Object.assign(accessTokenObj, {timestamp: +new Date()});\r\n}\r\n\r\nconst access_token = global.access_token.access_token;\r\n\r\nconst post_data = JSON.stringify({\r\n    scene: uid,     // 最多32个字符。\r\n    width: 200,     // 生成的小程序码宽度。\r\n});\r\n\r\nlet options = url.parse(`https://api.weixin.qq.com/wxa/getwxacodeunlimit?access_token=${access_token}`);\r\noptions = Object.assign(options, {\r\n    method: 'POST',\r\n    headers: {\r\n        'Content-Type': 'application/json',\r\n        'Content-Length': post_data.length,\r\n    }\r\n});\r\n\r\n// 获取图片二进制流\r\nconst {imgBuffer, contentType} = await new Promise((resolve, reject) => {\r\n    let req = https.request(options, (res) => {\r\n        let resData = '';\r\n        res.setEncoding(\"binary\");\r\n        res.on('data', data => {\r\n            resData += data;\r\n        });\r\n        res.on('end', () => {\r\n            // 微信api可能返回json，也可能返回图片二进制流。这里要做个判断。\r\n            const contentType = res.headers['content-type'];\r\n            if ( !contentType.includes('image') ) {\r\n                console.log('获取小程序码图片失败，微信api返回的json为：')\r\n                console.log( JSON.parse(resData) )\r\n                return resolve(null);\r\n            }\r\n            const imgBuffer = Buffer.from(resData, 'binary');\r\n            resolve( {imgBuffer, contentType} );\r\n        });\r\n    });\r\n    req.on('error', (e) => {\r\n        console.log('获取微信小程序图片失败')\r\n        console.error(e);\r\n    });\r\n    req.write(post_data);   // 写入 post 请求的请求主体。\r\n    req.end();\r\n}).catch(() => {\r\n    return null;\r\n});\r\n\r\nif (imgBuffer == null) {\r\n    ctx.body = {code: 223, msg: '获取小程序码失败'};\r\n    return;\r\n}\r\nctx.res.setHeader('Content-type', contentType);\r\nctx.body = imgBuffer;\r\n复制代码后面的话\r\n\r\n原生 api 有点繁琐，建议使用一些流行的请求库，可读性高且方便修改。\r\n微信 api 返回的图片流，是先获取到完整的二进制数据，再返回到客户端的。如果可以直接把传回来的每一个数据块直接发到客户端，无疑可以缩短响应时间，貌似这里可以进行优化。\r\n涉及到了编码和解码的问题，这块内容要多学习。\r\n\r\n参考\r\n\r\nwww.cnblogs.com/chyingp/p/c…\r\nwww.ruanyifeng.com/blog/2007/1…"}
{"title": "适用于小程序的 ES6 ", "author": "Rolan", "put_time": "2019-4-23 00:56", "content": "JavaScript内部，字符以UTF-16的格式储存，每个字符固定为2个字节。对于那些需要4个字节储存的字符（Unicode码点大于0xFFFF的字符），JavaScript会认为它们是两个字符。ES6新增了完全支持UTF-16的方法codePointAt()，该方法接受编码单元的位置而非字符位置作为参数，返回与字符串中给定位置对应的码位，即一个整数值var text = \"a\" ;\r\n\r\nconsole.log(text.charCodeAt(0)); // 55362\r\nconsole.log(text.charCodeAt(1)); // 57271\r\nconsole.log(text.charCodeAt(2)); // 97\r\n\r\nconsole.log(text.codePointAt(0)); // 134071\r\nconsole.log(text.codePointAt(1)); // 57271\r\nconsole.log(text.codePointAt(2)); // 97二、includes1. indexOf用来查找某个元素的位置，如果不存在就返回-1，但是不能判断是否有NaN的元素。2. Array.includes()函数判断是否包含某一元素，返回 true / false，不能定位元素，但是能判断 NaN。const arr1 = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', NaN]\r\nconsole.log('%s', arr1.indexOf(NaN)) // -1\r\nconsole.log(arr1.includes('c')) // true\r\nconsole.log(arr1.includes('z')) // false\r\nconsole.log(arr1.includes(NaN))  // true复制代码三、startsWith1. 确定字符串是否以指定字符串的字符开头，返回 true/false。注意：区分大小写！2. 接受两个参数：  第一个参数，要在此字符串开头搜索的字符；  第二个参数是指定从字符串开始的位置，默认从零开始 四、endsWith1. 从字符串的末尾开始查找五、repeat1. 返回一个新字符串，表示将原字符串重复n次let str1='a';\r\nlet str2=str1.repeat(3);\r\nconsole.log(str2)//aaa复制代码六、String.fromCodePoint七、copyWithin1. 用于操作当前数组自身，用来把某些位置的元素复制并覆盖到其他位置上去。2. 该函数有三个参数：  target：目的起始位置；  start：复制源的起始位置，可以省略，可以是负数；  end：复制源的结束位置，可以省略，可以是负数，实际结束位置是end-1。3. const arr1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]\r\narr1.copyWithin(1, 3, 6)\r\nconsole.log('%s', JSON.stringify(arr1)) // [1,4,5,6,5,6,7,8,9,10,11]\r\n复制代码目标的位置不够的，能覆盖多少就覆盖多少const arr2 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]\r\narr2.copyWithin(3)\r\nconsole.log('%s', JSON.stringify(arr2)) // [1,2,3,1,2,3,4,5,6,7,8]复制代码start和end都可以是负数，负数表示从右边数过来第几个const arr3 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]\r\narr3.copyWithin(3, -3, -2)\r\nconsole.log(JSON.stringify(arr3)) // [1,2,3,9,5,6,7,8,9,10,11]复制代码八、find1. 查找目标元素，找到就返回该元素，找不到返回undefinedconst arr1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]\r\nvar ret1 = arr1.find((value, index, arr) => { \r\nreturn value > 4\r\n})\r\nvar ret2 = arr1.find((value, index, arr) => { \r\nreturn value > 14\r\n})\r\nconsole.log('%s', ret1) // 5\r\nconsole.log('%s', ret2) // undefined复制代码九、findIndex1. 查找目标元素，找到就返回元素的位置，找不到就返回-1var ret3 = arr1.findIndex((value, index, arr) => { \r\nreturn value > 4\r\n}) \r\nvar ret4 = arr1.findIndex((value, index, arr) => { \r\nreturn value > 14\r\n})\r\nconsole.log('%s', ret3) // 4\r\nconsole.log('%s', ret4) // -1复制代码十、fill1. 使用制定的元素填充数组2. 参数：  value：填充值。  start：填充起始位置，可以省略。  end：填充结束位置，可以省略，实际结束位置是end-1。const arr1 = [1, 2, 3, 4, 5]\r\narr1.fill(7)\r\nconsole.log(arr1) // [7, 7, 7, 7, 7]复制代码十一、entries()，keys()和values() —— 用于遍历数组1. 区别是keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历for (let index of ['a', 'b'].keys()) {\r\n console.log(index) // 0 1\r\n}复制代码十二、Array.from1. 将对象转换成数组2. 条件：  1）部署了Iterator接口的对象，比如：Set，Map，Array  2）类数组对象，就是一个对象必须有length属性，没有length，转出来的就是空数组。转换map转换set转换字符串Array.from('hello world') // [\"h\", \"e\", \"l\", \"l\", \"o\", \" \", \"w\", \"o\", \"r\", \"l\", \"d\"]复制代码Array.from('\\u767d\\u8272\\u7684\\u6d77') // [\"白\", \"色\", \"的\", \"海\"]复制代码类数组对象Array.from({\r\n  0: '0',\r\n  1: '1',\r\n  3: '3',\r\n  length:4\r\n}) \r\n// [\"0\", \"1\", undefined, \"3\"]复制代码Array.from({\r\n  0: 0,\r\n  1: 1\r\n})\r\n// []复制代码3. 参数： 1）被转换的的对象。 2）map函数。3）map函数中this指向的对象。let diObj = {\r\n  handle: function(n){\r\n    return n + 2\r\n  }\r\n}\r\nArray.from(\r\n  [1, 2, 3, 4, 5], \r\n  function (x){\r\n    return this.handle(x)\r\n  }, \r\n  diObj\r\n) // [3, 4, 5, 6, 7]复制代码十三、Array.of1. new Array()构造数组的时候，是有二意性的  构造时，传一个参数，表示生成多大的数组。  构造时，传多个参数，每个参数都是数组的一个元素。2.  将一个或多个值转换成数组 === new Array() 传多个参数 的情况"}
{"title": "微信小程序之自定义倒计时组件 ", "author": "Rolan", "put_time": "2019-4-29 00:11", "content": "最近写小程序写上瘾了,业务上需要实现一个倒计时的功能,考虑到可拓展以及使用方便,便将其封装成组件(写习惯了JSX不得不吐槽小程序自定义组件的繁琐)萌新第一次在掘金写东西,东西比较简单可能拉低整个掘金的文章水平了(求轻喷~)需求可配置倒计时的时间倒计时结束后执行事件可配置倒计时时间的格式步骤先定义自定义组件的 properties ,这里有两个父组件传给该倒计时组件的参数 target 倒计时的时间, format 倒计时时间的格式properties: {\r\n    target: {\r\n      type: String,\r\n    },\r\n    format: {\r\n      type: Function,\r\n      default: null\r\n    }\r\n},\r\n复制代码定义组件生命周期函数lifetimes: {\r\n    attached() {\r\n      //组件创建时\r\n      this.setData({\r\n        lastTime: this.initTime(this.properties).lastTime,  //根据 target 初始化组件的lastTime属性\r\n      }, () => {\r\n        //开启定时器\r\n        this.tick();\r\n        //判断是否有format属性 如果设置按照自定义format处理页面上显示的时间 没有设置按照默认的格式处理\r\n        if (typeof this.properties.format === 'object') {\r\n          this.defaultFormat(this.data.lastTime)\r\n        }\r\n      })\r\n    },\r\n\r\n    detached() {\r\n      //组件销毁时清除定时器 防止爆栈\r\n      clearTimeout(timer);\r\n    },\r\n},\r\n复制代码微信小程序自定义组件的生命周期指的是指的是组件自身的一些函数，这些函数在特殊的时间点或遇到一些特殊的框架事件时被自动触发。其中，最重要的生命周期是 created attached detached ，包含一个组件实例生命流程的最主要时间点。具体微信自定义组件学习参考官方文档定义组件自身的状态/**\r\n * 组件的初始数据\r\n*/\r\ndata: {\r\n    d: 0, //天\r\n    h: 0, //时\r\n    m: 0, //分\r\n    s: 0, //秒\r\n    result: '',  //自定义格式返回页面显示结果\r\n    lastTime:''  //倒计时的时间错\r\n},\r\n复制代码组件自身的方法methods: {\r\n    //默认处理时间格式\r\n    defaultFormat: function(time) {\r\n      const day = 24 * 60 * 60 * 1000\r\n      const hours = 60 * 60 * 1000;\r\n      const minutes = 60 * 1000;\r\n\r\n      const d = Math.floor(time / day);\r\n      const h = Math.floor((time - d * day) / hours);\r\n      const m = Math.floor((time - d * day - h * hours) / minutes);\r\n      const s = Math.floor((time - d * day - h * hours - m * minutes) / 1000);\r\n      this.setData({\r\n        d,\r\n        h,\r\n        m,\r\n        s\r\n      })\r\n    },\r\n\r\n    //定时事件\r\n    tick: function() {\r\n      let {\r\n        lastTime\r\n      } = this.data;\r\n\r\n      timer = setTimeout(() => {\r\n        if (lastTime < interval) {\r\n          clearTimeout(timer);\r\n          this.setData({\r\n              lastTime: 0,\r\n              result: ''\r\n            },\r\n            () => {\r\n              this.defaultFormat(lastTime)\r\n              if (this.onEnd) {\r\n                this.onEnd();\r\n              }\r\n            }\r\n          );\r\n        } else {\r\n          lastTime -= interval;\r\n          this.setData({\r\n              lastTime,\r\n              result: this.properties.format ? this.properties.format(lastTime) : ''\r\n            },\r\n            () => {\r\n              this.defaultFormat(lastTime)\r\n              this.tick();\r\n            }\r\n          );\r\n        }\r\n      }, interval);\r\n    },\r\n\r\n    //初始化时间\r\n    initTime: function(properties) {\r\n      let lastTime = 0;\r\n      let targetTime = 0;\r\n      try {\r\n        if (Object.prototype.toString.call(properties.target) === '[object Date]') {\r\n          targetTime = Number(properties.target).getTime();\r\n        } else {\r\n          targetTime = new Date(Number(properties.target)).getTime();\r\n        }\r\n      } catch (e) {\r\n        throw new Error('invalid target properties', e);\r\n      }\r\n\r\n      lastTime = targetTime - new Date().getTime();\r\n      return {\r\n        lastTime: lastTime < 0 ? 0 : lastTime,\r\n      };\r\n    },\r\n    //时间结束回调事件\r\n    onEnd: function() {\r\n      this.triggerEvent('onEnd');\r\n    }\r\n  }\r\n复制代码defaultFormat :默认时间处理函数 tick :定时事件 initTime 初始化时间 onEnd :时间结束的回调倒计时组件 countDown.js 完整代码var timer = 0;\r\nvar interval = 1000;\r\nComponent({\r\n  /**\r\n   * 组件的属性列表\r\n   */\r\n  properties: {\r\n    target: {\r\n      type: String,\r\n    },\r\n    format: {\r\n      type: Function,\r\n      default: null\r\n    }\r\n  },\r\n\r\n  lifetimes: {\r\n    attached() {\r\n      //组件创建时\r\n      this.setData({\r\n        lastTime: this.initTime(this.properties).lastTime,  //根据 target 初始化组件的lastTime属性\r\n      }, () => {\r\n        //开启定时器\r\n        this.tick();\r\n        //判断是否有format属性 如果设置按照自定义format处理页面上显示的时间 没有设置按照默认的格式处理\r\n        if (typeof this.properties.format === 'object') {\r\n          this.defaultFormat(this.data.lastTime)\r\n        }\r\n      })\r\n    },\r\n\r\n    detached() {\r\n      //组件销毁时清除定时器 防止爆栈\r\n      clearTimeout(timer);\r\n    },\r\n  },\r\n\r\n  /**\r\n   * 组件的初始数据\r\n   */\r\n  data: {\r\n    d: 0, //天\r\n    h: 0, //时\r\n    m: 0, //分\r\n    s: 0, //秒\r\n    result: '',  //自定义格式返回页面显示结果\r\n    lastTime:''  //倒计时的时间错\r\n  },\r\n\r\n  /**\r\n   * 组件的方法列表\r\n   */\r\n  methods: {\r\n    //默认处理时间格式\r\n    defaultFormat: function(time) {\r\n      const day = 24 * 60 * 60 * 1000\r\n      const hours = 60 * 60 * 1000;\r\n      const minutes = 60 * 1000;\r\n\r\n      const d = Math.floor(time / day);\r\n      const h = Math.floor((time - d * day) / hours);\r\n      const m = Math.floor((time - d * day - h * hours) / minutes);\r\n      const s = Math.floor((time - d * day - h * hours - m * minutes) / 1000);\r\n      this.setData({\r\n        d,\r\n        h,\r\n        m,\r\n        s\r\n      })\r\n    },\r\n\r\n    //定时事件\r\n    tick: function() {\r\n      let {\r\n        lastTime\r\n      } = this.data;\r\n\r\n      timer = setTimeout(() => {\r\n        if (lastTime < interval) {\r\n          clearTimeout(timer);\r\n          this.setData({\r\n              lastTime: 0,\r\n              result: ''\r\n            },\r\n            () => {\r\n              this.defaultFormat(lastTime)\r\n              if (this.onEnd) {\r\n                this.onEnd();\r\n              }\r\n            }\r\n          );\r\n        } else {\r\n          lastTime -= interval;\r\n          this.setData({\r\n              lastTime,\r\n              result: this.properties.format ? this.properties.format(lastTime) : ''\r\n            },\r\n            () => {\r\n              this.defaultFormat(lastTime)\r\n              this.tick();\r\n            }\r\n          );\r\n        }\r\n      }, interval);\r\n    },\r\n\r\n    //初始化时间\r\n    initTime: function(properties) {\r\n      let lastTime = 0;\r\n      let targetTime = 0;\r\n      try {\r\n        if (Object.prototype.toString.call(properties.target) === '[object Date]') {\r\n          targetTime = Number(properties.target).getTime();\r\n        } else {\r\n          targetTime = new Date(Number(properties.target)).getTime();\r\n        }\r\n      } catch (e) {\r\n        throw new Error('invalid target properties', e);\r\n      }\r\n\r\n      lastTime = targetTime - new Date().getTime();\r\n      return {\r\n        lastTime: lastTime < 0 ? 0 : lastTime,\r\n      };\r\n    },\r\n    //时间结束回调事件\r\n    onEnd: function() {\r\n      this.triggerEvent('onEnd');\r\n    }\r\n  }\r\n})\r\n复制代码倒计时组件 countDown.wxml 完整代码<wxs src=\"../wxs/utils.wxs\" module=\"utils\" />\r\n<wxs src=\"../../comm.wxs\" module=\"comm\" />\r\n<view class=\"count-down\">\r\n  <text wx:if=\"{{result!==''}}\">{{result}}text>\r\n  <block wx:else>\r\n    <text wx:if=\"{{comm.numberToFixed(d)>0}}\">{{d}}天text>\r\n    <text>{{utils.fixedZero(h)}}text>\r\n    <text style=\"font-weight: 500\">:text>\r\n    <text>{{utils.fixedZero(m)}}text>\r\n    <text style=\"font-weight: 500\">:text>\r\n    <text>{{utils.fixedZero(s)}}text>\r\n  block>\r\nview>\r\n复制代码其中引入了两个wxs文件中的函数WXS（WeiXin Script）是小程序的一套脚本语言，结合 WXML，可以构建出页面的结构。官方文档function fixedZero(val) {\r\n  return val * 1 < 10 ? '0' + val : val;\r\n}\r\n//保留 pos位小数\r\nfunction numberToFixed(number, pos) {\r\n  if (number === null || number === '' || number < 0) return ''\r\n  return parseFloat(number).toFixed(pos)\r\n}\r\n复制代码组件使用引入方式\"usingComponents\": {\r\n    \"countDown\": \"../../../components/countDown/countDown\"\r\n  },\r\n复制代码代码演示<countDown bind:onEnd=\"getPageList\" format=\"{{formatTime}}\" target=\"{{creatTargetTime}}\" />\r\n复制代码const formatChinaDate = mss => {\r\n  let days = parseInt(mss / (1000 * 60 * 60 * 24));\r\n  let hours = parseInt((mss % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));\r\n  let minutes = parseInt((mss % (1000 * 60 * 60)) / (1000 * 60));\r\n  let seconds = parseInt((mss % (1000 * 60)) / 1000);\r\n  return days + ' 天 ' + hours + ' 小时 ' + minutes + ' 分钟 ' + seconds + ' 秒 ';\r\n};\r\ndata:{\r\n    formatTime:formatChinaDate,\r\n    creatTargetTime:1556428889000, //时间戳\r\n}\r\n\r\ngetPageList:function(){\r\n    //倒计时结束啦\r\n    console.log('倒计时结束啦')\r\n}\r\n复制代码"}
{"title": "在微信小程序与小游戏中使用 LeanCloud ", "author": "Rolan", "put_time": "2019-4-29 00:37", "content": "微信小程序是一个全新的跨平台移动应用平台，小游戏是小程序的一个类目，在小程序的基础上开放了游戏相关的 API。LeanCloud 为小程序提供一站式后端云服务，为你免去服务器维护、证书配置等繁琐的工作，大幅降低你的开发和运维成本。本文说明了如何在微信小程序与小游戏中使用 LeanCloud 提供的各项服务。+Demo我们在小程序上实现了 LeanTodo 应用。在这个 Demo 中你可以看到：+如何集成 LeanCloud 用户系统，包括自动登录、unionid 绑定以及如何在登录后设置账号与密码以供用户在其他平台的 LeanTodo 应用上登录如何对云端数据进行查询、增加、修改与删除如何将查询结果数组绑定到视图层进行展示，以及如何在点击事件中得到对应的数组项如何使用 LiveQuery 实现对查询结果的实时更新和多端同步如何集成微信支付你可以通过微信扫描以下二维码进入 Demo。 Demo 的源码与运行说明请参考 https://github.com/leancloud/leantodo-weapp。+准备工作创建应用如果你还没有创建过 LeanCloud 应用，请登录 LeanCloud 控制台 创建一个新应用。如果你还没有小程序帐号，请访问 微信公众平台 注册一个小程序帐号。如果你不需要进行真机调试可以跳过这一步。下载 小程序开发工具，按照 小程序开发教程 创建一个项目。配置域名白名单请按照 小程序域名白名单配置 的步骤配置。如果你不需要进行真机调试可以跳过这一步（可在开发者工具的 详情 > 项目设置 中勾选不校验安全域名、TLS 版本以及 HTTPS 证书）。+安装与初始化 SDK要使用 LeanCloud 的结构化对象存储、文件存储、用户系统等功能，需要使用 LeanCloud 存储 SDK。存储 SDK 的安装与初始化请请参阅《JavaScript SDK 安装指南》中对应平台的说明。+安装存储 SDK 后即可在 app.js 中初始化应用：+// 获取 AV 命名空间的方式根据不同的安装方式而异，这里假设是通过手动导入文件的方式安装的 SDK\r\nconst AV = require('./libs/av-weapp-min.js');\r\nAV.init({\r\n  appId: '{{appid}}',\r\n  appKey: '{{appkey}}',\r\n});\r\n 要使用 LeanCloud 的即时通讯服务实现聊天等功能，需要使用 LeanCloud 即时通讯 SDK。即时通讯 SDK 是与存储 SDK 独立的 SDK，我们在单独的 即时通讯 章节介绍其安装与初始化的步骤。+结构化对象存储所有的结构化对象存储 API 都能正常使用，详细的用法请参考 JavaScript 数据存储开发指南。+数据绑定AV.Object 实例是一些携带很多信息与方法的对象，而小程序的存放渲染用数据的 data 字段需要的是 JSON 类型的数据，因此我们需要将 AV.Object 实例处理为 JSON 数据后再设置给 data。+以 LeanTodo Demo 中的 Todo 列表为例，要实现「将 AV.Query 查询结果 Todo 列表中的 content 与 done 字段展示为列表」的功能，我们可以定义一个 getDataForRender 来做上面说的「处理」：+const getDataForRender = todo => ({\r\n  content: todo.get('content'),\r\n  done: todo.get('done')\r\n});\r\n\r\nPage({\r\n  data: {\r\n    todos: []\r\n  },\r\n  onReady() {\r\n    new AV.Query('Todo')\r\n      .find()\r\n      .then(todos => this.setData({\r\n        todos: todos.map(getDataForRender)\r\n      }))\r\n      .catch(console.error);\r\n  }\r\n});AV.Object 提供了一个 #toJSON() 方法以 JSON 的形式返回其携带的有效信息。因此如果不考虑渲染性能，getDataForRender 可以简化为：+const getDataForRender = todo => todo.toJSON();使用 #toJSON() 会比手动 pick 需要的数据带来更多的性能消耗。这是因为小程序的 data 在逻辑层与渲染层之间是通过序列化后的字符串格式通讯的，过大的 data 结构会造成渲染耗时过久。因此对于结构复杂的 AV.Object，特别是如果是一个列表，手动 pick 需要的数据设置为 data 是一种常见的优化方法。+当然，每次 setData 时遇到不同结构中的 AV.Object 都要进行这样的处理会让代码充斥噪音，你可以使用各种技巧对此进行优化。这里分享一个 Demo 中使用的一个统一对 setData 的对象进行「处理」的 utility 方法 jsonify：+const isPlainObject = target =>\r\n  target &&\r\n  target.toString() == '[object Object]' &&\r\n  Object.getPrototypeOf(target) == Object.prototype;\r\nconst _jsonify = target => {\r\n  if (target && typeof target.toJSON === 'function') return target.toJSON();\r\n  if (Array.isArray(target)) return target.map(_jsonify);\r\n  return target;\r\n};\r\n\r\nconst jsonify = target =>\r\n  isPlainObject(target)\r\n    ? Object.keys(target).reduce(\r\n      (result, key) => ({\r\n        ...result,\r\n        [key]: _jsonify(target[key])\r\n      }),\r\n      {}\r\n    )\r\n    : _jsonify(target);jsonify 能正确的处理 AV.Object、AV.Object 数组以及其他类型的数据。使用时可以简单的在所有的 setData 之前对数据调用一次 jsonify 方法：+this.setData(jsonify({\r\n  todos, // AV.Object list\r\n  user, // AV.Object\r\n}));值得注意的是从 AV.Object 到 JSON 数据的处理是不可逆的，如果在之后还需要用到查询结果的 AV.Object，我们可以将其保存到 Page 实例上：+Page({\r\n  // todos 存放的是 AV.Object 列表，后续可以这些对象进行操作（比如调用其 save 方法），不参与渲染\r\n  todos: [],\r\n  data: {\r\n    // data.todo 存放的是 JSON 数据，供 WXML 页面渲染用\r\n    todos: []\r\n  },\r\n  onReady() {\r\n    new AV.Query('Todo')\r\n      .find()\r\n      .then(todos => {\r\n        this.todos = todos;\r\n        this.setData(jsonify({\r\n          todos\r\n        });\r\n      })\r\n      .catch(console.error);\r\n  },\r\n  saveAll() {\r\n    // 可以在这里获取到 this.todos 进行操作\r\n    return AV.Object.saveAll(this.todos)\r\n  }\r\n});你可能会在某些过时的文档或者 Demo 中看到直接使用 this.setData() 将 AV.Object 对象设置为当前页面的 data 的用法。我们 不再推荐这种用法。这是 SDK 针对小程序做的特殊「优化」，利用了小程序渲染机制中的一个未定义行为，目前已知在使用了自定义组件（usingComponents）时这种用法会失效。+文件存储在小程序中，可以将用户相册或拍照得到的图片上传到 LeanCloud 服务器进行保存。首先通过 wx.chooseImage 方法选择或拍摄照片，得到本地临时文件的路径，然后按照下面的方法构造一个 AV.File 将其上传到 LeanCloud：+wx.chooseImage({\r\n  count: 1,\r\n  sizeType: ['original', 'compressed'],\r\n  sourceType: ['album', 'camera'],\r\n  success: function(res) {\r\n    var tempFilePath = res.tempFilePaths[0];\r\n    // 使用本地临时文件的路径构造 AV.File\r\n    new AV.File('file-name', {\r\n      blob: {\r\n        uri: tempFilePath,\r\n      },\r\n    })\r\n      // 上传\r\n      .save()\r\n      // 上传成功\r\n      .then(file => console.log(file.url()))\r\n      // 上传发生异常\r\n      .catch(console.error);\r\n  }\r\n});上传成功后可以通过 file.url() 方法得到服务端的图片 url。+关于文件存储更详细的用法请参考 JavaScript 数据存储开发指南 · 文件。+用户系统小程序中提供了登录 API 来获取微信的用户登录状态，应用可以访问到用户的昵称、性别等基本信息。但是如果想要保存额外的用户信息，如用户的手机号码、收货地址等，或者需要在其他平台使用该用户登录，则需要使用 LeanCloud 的用户系统。+一键登录LeanCloud 的用户系统支持一键使用微信用户身份登录。要使用一键登录功能，需要先设置小程序的 AppID 与 AppSecret：+登录 微信公众平台，在 设置 > 开发设置 中获得 AppID 与 AppSecret。前往 LeanCloud 控制台 > 组件 > 社交，保存「微信小程序」的 AppID 与 AppSecret。这样你就可以在应用中使用 AV.User.loginWithWeapp() 方法来使用当前用户身份登录了。+AV.User.loginWithWeapp().then(user => {\r\n  this.globalData.user = user;\r\n}).catch(console.error);使用一键登录方式登录时，LeanCloud 会将该用户的小程序 openid 与 session_key 等信息保存在对应的 user.authData.lc_weapp 属性中，你可以在控制台的 _User 表中看到：+{\r\n  \"authData\": {\r\n    \"lc_weapp\": {\r\n      \"session_key\": \"2zIDoEEUhkb0B5pUTzsLVg==\",\r\n      \"expires_in\": 7200,\r\n      \"openid\": \"obznq0GuHPxdRYaaDkPOHk785DuA\"\r\n    }\r\n  }\r\n}如果用户是第一次使用此应用，调用登录 API 会创建一个新的用户，你可以在 控制台 > 存储 中的 _User 表中看到该用户的信息，如果用户曾经使用该方式登录过此应用（存在对应 openid 的用户），再次调用登录 API 会返回同一个用户。+用户的登录状态会保存在客户端中，可以使用 AV.User.current() 方法来获取当前登录的用户，下面的例子展示了如何为登录用户保存额外的信息：+// 假设已经通过 AV.User.loginWithWeapp() 登录\r\n// 获得当前登录用户\r\nconst user = AV.User.current();\r\n// 调用小程序 API，得到用户信息\r\nwx.getUserInfo({\r\n  success: ({userInfo}) => {\r\n    // 更新当前用户的信息\r\n    user.set(userInfo).save().then(user => {\r\n      // 成功，此时可在控制台中看到更新后的用户信息\r\n      this.globalData.user = user;\r\n    }).catch(console.error);\r\n  }\r\n});authData 默认只有对应用户可见，开发者可以使用 masterKey 在云引擎中获取该用户的 openid 与 session_key 进行支付、推送等操作。详情的示例请参考 支付。+小程序的登录态（session_key）存在有效期，可以通过 wx.checkSession() 方法检测当前用户登录态是否有效，失效后可以通过调用 AV.User.loginWithWeapp() 重新登录。+使用 unionid微信开放平台使用 unionid 来区分用户的唯一性，也就是说同一个微信开放平台帐号下的移动应用、网站应用和公众帐号（包括小程序），用户的 unionid 都是同一个，而 openid 会是多个。如果你想要实现多个小程序之间，或者小程序与使用微信开放平台登录的应用之间共享用户系统的话，则需要使用 unionid 登录。+要在小程序中使用 unionid 登录，请先确认已经在 微信开放平台 绑定了该小程序+在小程序中有很多途径可以 获取到 unionid。不同的 unionid 获取方式，接入 LeanCloud 用户系统的方式也有所不同。+一键登录时静默获取 unionid当满足以下条件时，一键登录 API AV.User.loginWithWeapp() 能静默地获取到用户的 unionid 并用 unionid + openid 进行匹配登录。+微信开放平台帐号下存在同主体的公众号，并且该用户已经关注了该公众号。微信开放平台帐号下存在同主体的公众号或移动应用，并且该用户已经授权登录过该公众号或移动应用。要启用这种方式，需要在一键登录时指定参数 preferUnionId 为 true：+AV.User.loginWithWeapp({\r\n  preferUnionId: true,\r\n});使用 unionid 登录后，用户的 authData 中会增加 _weixin_unionid 一项（与 lc_weapp 平级）：+{\r\n  \"authData\": {\r\n    \"lc_weapp\": {\r\n      \"session_key\": \"2zIDoEEUhkb0B5pUTzsLVg==\",\r\n      \"expires_in\": 7200,\r\n      \"openid\": \"obznq0GuHPxdRYaaDkPOHk785DuA\",\r\n      \"unionid\": \"ox7NLs5BlEqPS4glxqhn5kkO0UUo\"\r\n    },\r\n    \"_weixin_unionid\": {\r\n      \"uid\": \"ox7NLs5BlEqPS4glxqhn5kkO0UUo\"\r\n    }\r\n  }\r\n}用 unionid + openid 登录时，会按照下面的步骤进行用户匹配：+如果已经存在对应 unionid（authData._weixin_unionid.uid）的用户，则会直接作为这个用户登录，并将所有信息（openid、session_key、unionid 等）更新到该用户的 authData.lc_ewapp 中。如果不存在匹配 unionid 的用户，但存在匹配 openid（authData.lc_weapp.openid）的用户，则会直接作为这个用户登录，并将所有信息（session_key、unionid 等）更新到该用户的 authData.lc_ewapp 中，同时将 unionid 保存到 authData._weixin_unionid.uid 中。如果不存在匹配 unionid 的用户，也不存在匹配 openid 的用户，则创建一个新用户，将所有信息（session_key、unionid 等）更新到该用户的 authData.lc_ewapp 中，同时将 unionid 保存到 authData._weixin_unionid.uid 中。不管匹配的过程是如何的，最终登录用户的 authData 都会是上面这种结构。+LeanTodo Demo 便是使用这种方式登录的，如果你已经关注了其关联的公众号（搜索 AVOSCloud，或通过小程序关于页面的相关公众号链接访问），那么你在登录后会在 LeanTodo Demo 的 设置 - 用户 页面看到当前用户的 authData 中已经绑定了 unionid。+需要注意的是：+如果用户不符合上述静默获取 unionid 的条件，那么就算指定了 preferUnionId 也不会使用 unionid 登录。如果用户符合上述静默获取 unionid 的条件，但没有指定 preferUnionId，那么该次登录不会使用 unionid 登录，但仍然会将获取到的 unionid 作为一般字段写入该用户的 authData.lc_weapp 中。此时用户的 authData 会是这样的：+{\r\n  \"authData\": {\r\n    \"lc_weapp\": {\r\n      \"session_key\": \"2zIDoEEUhkb0B5pUTzsLVg==\",\r\n      \"expires_in\": 7200,\r\n      \"openid\": \"obznq0GuHPxdRYaaDkPOHk785DuA\",\r\n      \"unionid\": \"ox7NLs5BlEqPS4glxqhn5kkO0UUo\"\r\n    }\r\n  }\r\n}通过其他方式获取 unionid 后登录如果开发者自行获得了用户的 unionid（例如通过解密 wx.getUserInfo 获取到的用户信息），可以在小程序中调用 AV.User.loginWithWeappWithUnionId() 投入 unionid 完成登录授权：+AV.User.loginWithWeappWithUnionId(unionid, {\r\n  asMainAccount: true\r\n}).then(console.log, console.error);通过其他方式获取 unionid 与 openid 后登录如果开发者希望更灵活的控制小程序的登录流程，也可以自行在服务端实现 unionid 与 openid 的获取，然后调用通用的第三方 unionid 登录接口指定平台为 lc_weapp 来登录：+const unionid = '';\r\nconst authData = {\r\n  openid: '',\r\n  session_key: ''\r\n};\r\nconst platform = 'lc_weapp';\r\nAV.User.loginWithAuthDataAndUnionId(authData, platform, unionid, {\r\n  asMainAccount: true\r\n}).then(console.log, console.error);相对上面提到的一些 Weapp 相关的登录 API，loginWithAuthDataAndUnionId 是更加底层的第三方登录接口，不依赖小程序运行环境，因此这种方式也提供了更高的灵活度：+可以在服务端获取到 unionid 与 openid 等信息后返回给小程序客户端，在客户端调用 AV.User.loginWithAuthDataAndUnionId 来登录。也可以在服务端获取到 unionid 与 openid 等信息后直接调用 AV.User.loginWithAuthDataAndUnionId 登录，成功后得到登录用户的 sessionToken 后返回给客户端，客户端再使用该 sessionToken 直接登录。关联第二个小程序这种用法的另一种常见场景是关联同一个开发者帐号下的第二个小程序。+因为一个 LeanCloud 应用默认关联一个微信小程序（对应的平台名称是 lc_weapp），使用小程序系列 API 的时候也都是默认关联到 authData.lc_weapp 字段上。如果想要接入第二个小程序，则需要自行获取到 unionid 与 openid，然后将其作为一个新的第三方平台登录。这里同样需要用到 AV.User.loginWithAuthDataAndUnionId 方法，但与关联内置的小程序平台（lc_weapp）有一些不同：+需要指定一个新的 platform需要将 openid 保存为 uid（内置的微信平台做了特殊处理可以直接用 openid 而这里是作为通用第三方 OAuth 平台保存因此需要使用标准的 uid 字段）。这里我们以新的平台 weapp2 为例：+const unionid = '';\r\nconst openid = '';\r\nconst authData = {\r\n  uid: openid,\r\n  session_key: ''\r\n};\r\nconst platform = 'weapp2';\r\nAV.User.loginWithAuthDataAndUnionId(authData, platform, unionid, {\r\n  asMainAccount: true\r\n}).then(console.log, console.error);获取 unionid 后与现有用户关联如果一个用户已经登录，现在通过某种方式获取到了其 unionid（一个常见的使用场景是用户完成了支付操作后在服务端通过 getPaidUnionId 得到了 unionid）希望与之关联，可以在小程序中使用 AV.User#associateWithWeappWithUnionId()：+const user = AV.User.current(); // 获取当前登录用户\r\nuser.associateWithWeappWithUnionId(unionid, {\r\n  asMainAccount: true\r\n}).then(console.log, console.error);启用其他登录方式上述的登录 API 对接的是小程序的用户系统，所以使用这些 API 创建的用户无法直接在小程序之外的平台上登录。如果需要使用 LeanCloud 用户系统提供的其他登录方式，如用手机号验证码登录、邮箱密码登录等，在小程序登录后设置对应的用户属性即可：+// 小程序登录\r\nAV.User.loginWithWeapp().then(user => {\r\n  // 设置并保存手机号\r\n  user.setMobilePhoneNumber('13000000000');\r\n  return user.save();\r\n}).then(user => {\r\n  // 发送验证短信\r\n  return AV.User.requestMobilePhoneVerify(user.getMobilePhoneNumber());\r\n}).then({\r\n  // 用户填写收到短信验证码后再调用 AV.User.verifyMobilePhone(code) 完成手机号的绑定\r\n  // 成功后用户的 mobilePhoneVerified 字段会被置为 true\r\n  // 此后用户便可以使用手机号加动态验证码登录了\r\n}).catch(console.error);验证手机号码功能要求在 控制台 > 存储 > 设置 > 用户账号 启用「用户注册时，向注册手机号码发送验证短信」。+绑定现有用户如果你的应用已经在使用 LeanCloud 的用户系统，或者用户已经通过其他方式注册了你的应用（比如在 Web 端通过用户名密码注册），可以通过在小程序中调用 AV.User#associateWithWeapp() 来关联已有的账户：+// 首先，使用用户名与密码登录一个已经存在的用户\r\nAV.User.logIn('username', 'password').then(user => {\r\n  // 将当前的微信用户与当前登录用户关联\r\n  return user.associateWithWeapp();\r\n}).catch(console.error);即时通讯要使用 LeanCloud 的即时通讯服务实现聊天等功能，需要使用 LeanCloud 即时通讯 SDK。+安装与初始化请参阅《JavaScript SDK 安装指南》中对应平台的说明。+安装 SDK 后即可在 app.js 中初始化应用：+// Realtime 类获取的方式根据不同的安装方式而异，这里假设是通过手动导入文件的方式安装的 SDK\r\nconst { Realtime } = require('./libs/realtime.weapp.min.js');\r\nconst realtime = new Realtime({\r\n  appId: '{{appid}}',\r\n  appKey: '{{appkey}}',\r\n});\r\n 需要特别注意的是，小程序对 WebSocket 连接的数量是有限制的，因此推荐的用法是初始化 Realtime 一次，挂载到全局的 App 实例上，然后在所有需要的时候都使用这个 Realtime 实例。+// app.js\r\nconst { Realtime } = require('./libs/realtime.weapp.min.js');\r\nconst realtime = new Realtime({\r\n  appId: '{{appid}}',\r\n  appKey: '{{appkey}}',\r\n});\r\nApp({\r\n  realtime: realtime,\r\n  // ...\r\n});\r\n\r\n// some-page.js\r\nconst realtime = getApp().realtime;\r\n 即时通讯 SDK 的详细用法请参考 即时通讯开发指南。+富媒体消息要在小程序中使用即时通讯 SDK 的富媒体消息插件，有一些额外的约束：+安装存储 SDK 至 libs 目录，并将文件重命名为 leancloud-storage.js。安装即时通讯 SDK 至 libs 目录，并将文件重命名为 leancloud-realtime.js。下载 leancloud-realtime-plugin-typed-messages.js，移动到 libs 目录。必须保证三个文件在同一目录中。在 app.js 中依次加载 leancloud-storage.js、leancloud-realtime.js 和 leancloud-realtime-plugin-typed-messages.js。const AV = require('./libs/leancloud-storage.js');\r\nconst Realtime = require('./libs/leancloud-realtime.js').Realtime;\r\nconst TypedMessagesPlugin = require('./libs/leancloud-realtime-plugin-typed-messages.js').TypedMessagesPlugin;\r\nconst ImageMessage = require('./libs/leancloud-realtime-plugin-typed-messages.js').ImageMessage;在 app.js 中初始化应用：// 初始化存储 SDK\r\nAV.init({\r\n appId: '{{appid}}',\r\n appKey: '{{appkey}}',\r\n});\r\n// 初始化即时通讯 SDK\r\nconst realtime = new Realtime({\r\n appId: '{{appid}}',\r\n appKey: '{{appkey}}',\r\n plugins: [TypedMessagesPlugin], // 注册富媒体消息插件\r\n});\r\n 富媒体消息的用法请参考 即时通讯开发指南 - 富媒体消息。+数据绑定使用即时通讯 SDK，一个常见的需求是将 Conversation 与 Message 类型的数据绑定到视图层进行渲染。这里会遇到一些与结构化数据存储 SDK 一样的问题，其解决方案与最佳实践请参考结构化数据存储的 数据绑定 章节（Conversation 与 Message 都实现了 #toJSON 方法，上文中介绍的 jsonify 方法同样适用于Conversation 与 Message 实例）。+支付配置在开始之前，请确保已经在微信小程序后台开启了「微信支付」功能，然后按照下面的步骤配置云引擎环境变量：2进入应用控制台 - 云引擎 - 设置设置应用的二级域名并保存添加并保存以下环境变量WEIXIN_APPID：小程序 AppIdWEIXIN_MCHID：微信支付商户号WEIXIN_PAY_SECRET：微信支付 API 密钥（微信商户平台 - 账户设置 - API安全 - 密钥设置）WEIXIN_NOTIFY_URL：https://.leanapp.cn/weixin/pay-callback，其中 yourdomain 是第二步中设置的二级域名查看示例服务端开发首先确认本机已经安装 Node.js 运行环境和 LeanCloud 命令行工具，然后执行下列指令下载示例项目：+$ git clone https://github.com/leancloud/weapp-pay-getting-started.git\r\n$ cd weapp-pay-getting-started安装依赖：+npm install登录并关联应用：+lean login\r\nlean switch启动项目：+lean up之后你就可以在 localhost:3001 调试云函数了。+示例项目中与支付直接相关代码有三部分：+order.js：对应 Order 表，定义了部分字段的 getter/setter，以及 place 方法用于向微信 API 提交订单。cloud.js：其中定义了名为 order 的云函数，这个云函数会获取当前用户的 openid，以其身份创建了一个 1 分钱的 order 并下单，最后返回签名过的订单信息。routers/weixin.js：其中定义了 pay-callback 的处理函数，当用户支付成功后微信调用这个 URL，这个函数将对应的订单状态更新为 SUCCESS。请根据你的业务需要修改代码。参考文档：+微信支付统一下单 API 参数与错误码微信支付结果通知参数完成开发后部署到预备环境（若无预备环境则直接部署到生产环境）：+lean deploy客户端开发客户端完成一次支付需要分两步：+用户登录后，调用名为 order 的云函数下单，返回签名过的订单信息。调用支付 API（wx.requestPayment），传入上一步返回的订单信息，发起支付。AV.Cloud.run('order').then((data) => {\r\n  data.success = () => {\r\n    // 支付成功\r\n  });\r\n  data.fail = ({ errMsg }) => {\r\n    // 错误处理\r\n  });\r\n  wx.requestPayment(data);\r\n}).catch(error => {\r\n  // 错误处理\r\n})客户端的示例代码参见 Demo 打赏功能。参考文档：2小程序客户端发起支付 APIFAQ配置 download 合法域名时显示「该域名因违规被禁止设置。」请前往 控制台 > 存储 > 设置 > 文件 配置你自己的文件域名。+Access denied by api domain white list如果你的应用启用并配置了 Web 安全域名，你可能会 catch 到 Access denied by api domain white list 异常，请将提示的域名添加至应用的 Web 安全域名列表。+小程序真机上传数据时，控制台存储中显示的 Class 表名被压缩为单个字母。例如新建一个名为「Todo」的表，上传数据成功后进入控制台查看，其表名称显示为像 i、u 这样的单个字母。这是因为真机上代码会被压缩，解决办法是在创建 Class 后向 SDK 注册该 Class 的名字：AV.Object.register(Todo, 'Todo');。+反馈如果在微信小程序中使用 LeanCloud 时遇到问题，欢迎通过我们的 论坛 进行反馈。"}
{"title": "微信小程序怎么使用icon ", "author": "Rolan", "put_time": "2019-4-30 00:21", "content": "小程序怎么使用icon第一步 下载icon我选择的图标库是阿里图标官网， 加入购物车第二步 转换ttf因为小程序的wxss文件的font-face的url不接受http地址作为参数,但可以接受base64,因此需将字体文件下载后,转换为base64，然后引用进入https://transfonter.org/平台点击Add fonts，添加iconfont.ttf勾选Base64 encode点击 convert 完成转换按照上图1,2,3的步骤 转换完成， 点击Download第三步 在微信小程序中使用icon解压 第二步中的文件夹找到stylesheet.css 文件打开第一步中压缩包的iconfont.css，把里面圈红的部分（即fontface部分我们不需要啦）复制到stylesheet.css修改后的stylesheet.css修改stylesheet.css的文件后缀为wxss，即stylesheet.wxss把stylesheet.wxss放进微信小程序的公共文件里面，然后把整个文件import到页面的样式表里在wxml页面引入使用完结"}
{"title": "微信小程序生命周期与性能指标 ", "author": "Rolan", "put_time": "2019-5-5 00:47", "content": "本文将介绍微信小程序整个App的生命周期、单个页面的生命周期和组件的生命周期，并研究了这三个元素生命周期的关系，这在学习和开发过程中对理解小程序运行机制有重要意义。最终，由生命周期整理出小程序的关键指标，仅供参考。App的生命周期在app.js中有其生命周期相关的三个方法：onLaunch、onShow和onHide。首先是onLaunch，这是整个小程序的第一个生命周期回调函数，在小程序初始化完成后调用。接着，小程序将触发onShow事件，如果小程序从后台切回前台后也会触发该事件。最后，是小程序切到后台的事件onHide。Page的生命周期在每个页面注册函数Page()的参数中，有生命周期的方法：onLoad、onShow、onReady、onHide、onUnload。页面触发的第一个生命周期回调是onLoad，在页面加载的时候触发，其参数是页面的query参数，一个页面只有一次；接着是onShow，监听页面的显示，与onLoad不同，如果页面被隐藏后再次显示（例如：进入下一页后返回），也会触发该生命周期；触发onShow之后，逻辑层会向渲染层发送初始化数据，渲染层完成第一次渲染之后，会通知逻辑层触发onReady生命周期，一个页面只有一次；onHide是页面隐藏但未卸载的时候触发的，如 wx.navigateTo 或底部tab切换到其他页面，小程序切入后台等。onUnload是页面卸载时触发，如wx.redirectTo或wx.navigateBack到其他页面时。Component的生命周期组件最重要的生命周期是created、attached、detached ，包含一个组件实例生命流程的最主要时间点。首先，当组件实例刚被创建时， created生命周期被触发。此时，还不能调用setData 。 通常情况下，这个生命周期只应该用于给组件this添加一些自定义属性字段。接着，在组件完全初始化完毕并且进入页面节点树后， attached生命周期被触发。此时， this.data 已被初始化为组件的当前值，绝大多数初始化工作可以在这个时机进行。在组件离开页面节点树后， detached生命周期被触发。退出一个页面时，如果组件还在页面节点树中，则 detached 会被触发。此外，组件生命周期还有ready和move生命周期，分别在视图层布局完成和组件实例被移动到节点树另一个位置时执行。整体周期现在我们知道了App、Page、和Component分别的生命周期顺序，那么他们之间的生命周期顺序又是如何？通过开发一个简单的demo，观察运行结果，可以得到如下结论：打开页面的情况首先，前一个页面隐藏，在加载下一个页面之前，需要先初始化新页面的组件。页面首次渲染之后，会触发组件的ready，最后触发的是页面的onReady，如下图：从PageA打开pageB时的生命周期顺序离开页面的情况离开当前页面时，首先触发当前页面的卸载onUnload，接着是组件离开节点树的detached。最后显示之前的页面，触发onShow。如下图：从PageB返回到PageA的生命周期顺序打开App的情况App、Page与Component生命周期运行顺序，先从App加载然后再加载Page，在加载Page之前会先初始化该页面所用的所有组件，之后才触发页面的onLoad生命周期，如下图：打开App时的生命周期顺序切换到后台切换到后台时，小程序和页面并没有卸载，只会触发隐藏。先触发页面的onHide，接着是App的onHide。如下图：切换到后台时的生命周期顺序切换到前台切换到后台时，小程序会先触发onShow，之后才是页面的onShow。如下图：切换到前台时的生命周期顺序关键性能指标了解了小程序各个阶段的生命周期，我们可以制定出关键节点的性能指标，整理如下表：参考文档官方文档 Page：developers.weixin.qq.com/miniprogram…官方文档 App：developers.weixin.qq.com/miniprogram…官方文档 页面生命周期：developers.weixin.qq.com/miniprogram…官方文档 组件生命周期：developers.weixin.qq.com/miniprogram…"}
{"title": "手把手教你写一个微信小程序日历组件 ", "author": "Rolan", "put_time": "2019-5-6 00:24", "content": "今天我们一起写一个微信小程序日历组件\r\n\r\n微信小程序日历组件\r\ngithub.com/749264345/w…\r\n\r\n好，我们先看一下要实现的模样，如下图\r\n\r\n\r\n由以上截图我们可以看到\r\n\r\n1.日历可以通过按钮【切换展示效果】改变日历的呈现效果，上图是平铺模式，下图是收起滚动模式。\r\n2.通过点击具体的日期可以在页面上显示当前选中的具体日期。\r\n3.点击【今天】快速回到当日视图。\r\n4.点击【◀】和【▶】切换月份。\r\n上面的四点也是基本的交互需求，我们马上开始。\r\n首先，我们先结构后样式，做出最基本的界面结构\r\n这边我们把整体结构分成上中下，操作显示区，星期显示区，日期显示区。\r\n\r\n<view class='calendar'>\r\n    <!--显示当前年月日-->\r\n    <view class='calendar-title'>\r\n        <view class='item ctrl' bindtap='lastMonth'>{{lastMonth}}</view>\r\n        <view class='item title'>{{title}}</view>\r\n        <view class='item ctrl' bindtap='nextMonth'>{{nextMonth}}</view>\r\n        <view class='item ctrl today' bindtap='today'>今天</view>\r\n    </view>\r\n\r\n    <!--星期-->\r\n    <view class='calendar-week'>\r\n        <view class='item'>{{item}}</view>\r\n    </view>\r\n\r\n    <!--日期-->\r\n    <view class='calendar-container'>\r\n        <!--上个月占位格子-->\r\n        <view class='grid gray'>{{item}}</view>\r\n\r\n        <!--当月格子-->\r\n        <view class='grid'>\r\n            <view class=\"wrap\">{{item.date}}</view>\r\n        </view>\r\n\r\n        <!--下个月占位格子-->\r\n        <view class='grid gray'>{{item}}</view>\r\n    </view>\r\n</view>\r\n复制代码这是我们基本的日历结构，机智的小伙伴已经从布局中知道我们实现的大致逻辑了，是的，我们先获取当月有多少天，上月和下月有多少天，这样我们的日历就出来了。好，慢慢来，下面我们详细说，我们先写上基本的样式。\r\n.calendar {\r\n    width: 100%;\r\n    text-align: center;\r\n    font-size: 30rpx;\r\n    box-sizing: border-box;\r\n}\r\n\r\n/* 标题 */\r\n.calendar-title {\r\n    line-height: 70rpx;\r\n    font-size: 30rpx;\r\n    text-align: left;\r\n    padding: 0 20rpx;\r\n    box-sizing: border-box;\r\n}\r\n\r\n.calendar-title .ctrl {\r\n    display: inline-block;\r\n    padding: 0 20rpx;\r\n    background: #f5f5f5;\r\n    border-radius: 10rpx;\r\n}\r\n\r\n.calendar-title .item {\r\n    display: inline-block;\r\n    vertical-align: middle;\r\n    line-height: 50rpx;\r\n}\r\n\r\n.calendar-title .title {\r\n    min-width: 300rpx;\r\n    text-align: center;\r\n}\r\n\r\n.calendar-title .today {\r\n    float: right;\r\n    margin-top: 10rpx;\r\n}\r\n\r\n/* 星期 */\r\n.calendar-week {\r\n    display: flex;\r\n    text-align: center;\r\n    padding: 20rpx 10rpx;\r\n    box-sizing: border-box;\r\n    border-top: 1rpx solid #e0e0e0;\r\n    border-bottom: 1rpx solid #e0e0e0;\r\n    background: #f5f5f5;\r\n}\r\n\r\n.calendar-week .item {\r\n    flex: 1;\r\n}\r\n\r\n/* 日期 */\r\n.calendar-container {\r\n    display: flex;\r\n    flex-wrap: wrap;\r\n    padding: 20rpx 10rpx;\r\n    box-sizing: border-box;\r\n}\r\n\r\n.calendar-container .grid {\r\n    display: inline-block;\r\n    width: 14.28571428571429%;\r\n    line-height: 70rpx;\r\n    position: relative;\r\n    z-index: 1;\r\n}\r\n\r\n.calendar-container .grid.gray {\r\n    color: #ccc;\r\n}\r\n\r\n.calendar-container .grid .wrap.select {\r\n    background: rgb(49, 120, 228);\r\n    border-radius: 10rpx;\r\n    color: #fff;\r\n    width: 80%;\r\n    margin: 0 auto;\r\n}\r\n复制代码以上我们基本试下了日历的界面，下面我们来实现星期和日期的展示。\r\n好，我们先显示星期，我们先在组件中定义一个数组，用来遍历显示星期的标题；\r\nComponent({\r\n    properties: {\r\n        //星期数组\r\n        weekText: {\r\n            type: Array,\r\n            value: ['周日', '周一', '周二', '周三', '周四', '周五', '周六']\r\n        }\r\n    },\r\n    ...\r\n})\r\n复制代码我们将星期的标题定义为可配置的模式，默认显示如上的文字，之后我们可以在组件外自定义，个性化显示。于是我们调整下wxml的代码。\r\n    <!--遍历星期-->\r\n    <view class='calendar-week'>\r\n        <view wx:for='{{weekText}}' class='item' wx:key='{{item}}'>{{item}}</view>\r\n    </view>\r\n复制代码这样我们就能看到我们想要的效果。\r\n\r\n下面我们开始日期的显示，我们先获取当月有几天，这里的核心代码是\r\n\r\nnew Date(year, month, date).getDate();\r\n\r\n\r\n由此我们做如下尝试\r\n\r\n我们如期获得了返回值，而当我们传入日期为0时返回了31为当月的全部天数。\r\n\r\n由于JavaScript中day的范围为1~31中的值，所以当设为0时，会向前 一天，也即表示上个月的最后一天，通过这种方式可以得到每个月份的天数。\r\n\r\n知道了获取当月天数的原理，我们还需要知道当月1号是星期几。\r\n我们使用如下的方法：\r\n\r\nnew Date(Date.UTC(year, month-1, date)).getDay();\r\n\r\n\r\n我们同样在控制台做出调试；\r\n\r\n需要注意的是，上面的month是实际的月份，而下面这个方法需要在实际的月份上减去1。\r\n于是我们获取0-6之间的值，分别对应周日~周六。\r\n值为6是周六，值为0是周日。\r\n由于日历的第一天是周日，周日对应的是0，于是传入每月1日，返回值为多少，就是星期几，也就说明当月1日前面空几格。\r\n知道了当月就几天，当月前面有几天，我们做一下算法就可以得出，当月后面有几天，于是我们建立如下函数：\r\n    // 组件的初始数据\r\n    data: {\r\n        //当月格子\r\n        thisMonthDays: [],\r\n        //上月格子\r\n        empytGridsBefore: [],\r\n        //下月格子\r\n        empytGridsAfter: [],\r\n},\r\n\r\nmethods: {\r\n        //获取当月天数\r\n        getThisMonthDays: function (year, month) {\r\n            return new Date(year, month, 0).getDate();\r\n        },\r\n        // 绘制当月天数占的格子\r\n        createDays: function (year, month) {\r\n            let thisMonthDays = [],\r\n                days = this.getThisMonthDays(year, month);\r\n            for (let i = 1; i <= days; i++) {\r\n                thisMonthDays.push({\r\n                    date: i,\r\n                    dateFormat: this.zero(i),\r\n                    monthFormat: this.zero(month),\r\n                    week: this.data.weekText[new Date(Date.UTC(year, month - 1, i)).getDay()]\r\n                });\r\n            }\r\n            this.setData({\r\n                thisMonthDays\r\n            })\r\n        },\r\n        //获取当月空出的天数\r\n        createEmptyGrids: function (year, month) {\r\n            let week = new Date(Date.UTC(year, month - 1, 1)).getDay(),\r\n                empytGridsBefore = [],\r\n                empytGridsAfter = [],\r\n                emptyDays = (week == 0 ? 7 : week);\r\n            //当月天数\r\n            var thisMonthDays = this.getThisMonthDays(year, month);\r\n            //上月天数\r\n            var preMonthDays = month - 1 < 0 \r\n                ? this.getThisMonthDays(year - 1, 12) \r\n                : this.getThisMonthDays(year, month - 1);\r\n\r\n            //空出日期\r\n            for (let i = 1; i <= emptyDays; i++) {\r\n                empytGridsBefore.push(preMonthDays - (emptyDays - i));\r\n            }\r\n\r\n            var after = (42 - thisMonthDays - emptyDays) - 7 >= 0 \r\n                        ? (42 - thisMonthDays - emptyDays) - 7 \r\n                        : (42 - thisMonthDays - emptyDays);\r\n            for (let i = 1; i <= after; i++) {\r\n                empytGridsAfter.push(i);\r\n            }\r\n            this.setData({\r\n                empytGridsAfter,\r\n                empytGridsBefore\r\n            })\r\n        },\r\n\r\n        //补全0\r\n        zero: function (i) {\r\n            return i >= 10 ? i : '0' + i;\r\n        },\r\n}\r\n复制代码我们同样修改下wxml代码，同时我们为上月，下月，今天，三个按钮添加相关事件监听。\r\n    <!--显示当前年月日-->\r\n    <view class='calendar-title'>\r\n        <view class='item ctrl' bindtap='lastMonth'>{{lastMonth}}</view>\r\n        <view class='item title'>{{title}}</view>\r\n        <view class='item ctrl' bindtap='nextMonth'>{{nextMonth}}</view>\r\n        <view class='item ctrl today' bindtap='today'>今天</view>\r\n    </view>\r\n复制代码<!--上个月占位格子-->\r\n<view class='grid gray' wx:for='{{empytGridsBefore}}' wx:key='{{item}}'>{{item}}</view>\r\n\r\n<!--当月格子-->\r\n<view class='grid' wx:for='{{thisMonthDays}}' wx:key='{{indx}}'>\r\n   <view class='self' wx:if=\"{{ format === year+'-'+item.monthFormat+'-'+item.dateFormat }}\"></view>\r\n   <view class=\"wrap {{ select === year+'-'+item.monthFormat+'-'+item.dateFormat ? 'select' :''}}\" bindtap='select' data-date='{{item.date}}'>{{item.date}}</view>\r\n</view>\r\n\r\n<!--下个月占位格子-->\r\n<view class='grid gray' wx:for='{{empytGridsAfter}}' wx:key='{{item}}'>{{item}}</view>\r\n复制代码相关的事件监听：\r\n//默认选中当天 并初始化组件\r\ntoday: function () {\r\n    let DATE = this.data.defaultValue ? new Date(this.data.defaultValue) : new Date(),\r\n        year = DATE.getFullYear(),\r\n        month = DATE.getMonth() + 1,\r\n        date = DATE.getDate(),\r\n        select = year + '-' + this.zero(month) + '-' + this.zero(date);\r\n\r\n    this.setData({\r\n        format: select,\r\n        select: select,\r\n        year: year,\r\n        month: month,\r\n        date: date,\r\n        YEAR: year,\r\n        MONTH: month,\r\n        DATE: date,\r\n    })\r\n\r\n    //初始化日历组件UI\r\n    this.display(year, month, date);\r\n\r\n    //发送事件监听\r\n    this.triggerEvent('select', select);\r\n},\r\n//上个月\r\nlastMonth: function () {\r\n    let month = this.data.month == 1 ? 12 : this.data.month - 1;\r\n    let year = this.data.month == 1 ? this.data.year - 1 : this.data.year;\r\n    //初始化日历组件UI\r\n    this.display(year, month, 0);\r\n},\r\n//下个月\r\nnextMonth: function () {\r\n    let month = this.data.month == 12 ? 1 : this.data.month + 1;\r\n    let year = this.data.month == 12 ? this.data.year + 1 : this.data.year;\r\n    //初始化日历组件UI\r\n    this.display(year, month, 0);\r\n},\r\n复制代码代码中我们使用this.display(year, month, 0)为组件统一初始化；\r\n同时在today函数中我们添加事件监听函数，将选中的日期发送到页面，我们通过事件订阅来获取的相关值。\r\n<Calendar id=\"Calendar\" bind:select=\"select\"></Calendar>\r\n复制代码//组件监听事件\r\nselect(e) {\r\n    this.setData({\r\n        selectVal:e.detail\r\n    })\r\n},\r\n复制代码最后我们为切换显示效果的按钮添加事件：\r\n    toggleType(){\r\n        this.selectComponent('#Calendar').toggleType();\r\n    }\r\n复制代码组件中对应的方法，每当切换展示效果，组件都需要初始化\r\n        //切换展示\r\n        toggleType(){\r\n            this.setData({\r\n                toggleType: this.data.toggleType == 'mini' ? 'large' :'mini'\r\n            })\r\n            //初始化日历组件UI\r\n            this.display(this.data.year, this.data.month, this.data.date);\r\n        },\r\n复制代码以上基本上是小程序日历组件实现的基本逻辑，介于篇幅太长还有很多实现上的细节不在此一一细说，大家可以移步我的github\r\n\r\n微信小程序日历组件\r\ngithub.com/749264345/w…\r\n\r\n上文中有不足之处，请给出建议或更优的实现方案，谢谢~\r\n最后祝大家五一快乐~~"}
{"title": "微信小程序---支付密码的输入框 ", "author": "Rolan", "put_time": "2019-5-6 00:51", "content": "效果如下：干货：<view class=\"pay\"><view class=\"title\">支付方式</view><view catchtap=\"wx_pay\" class=\"wx_pay\"><i class=\"icon {{payment_mode==1?'active':''}}\" type=\"String\"></i><text>微信支付</text></view><view catchtap=\"offline_pay\" class=\"offline_pay\"><i class=\"icon {{payment_mode==0?'active':''}}\" type=\"String\"></i><text>对公打款</text></view><block wx:if=\"{{balance!=0}}\"><view catchtap=\"wallet_pay\" class=\"wallet_pay\"><i class=\"icon {{payment_mode==2?'active':''}}\" type=\"String\"></i><text>钱包支付(余额:{{balance/100}}元)</text></view></block><block wx:if=\"{{balance==0}}\"><view class=\"wallet_pay\"><i class=\"icon\" type=\"String\" style=\"background:#e8e8e8;border:none;\"></i><text style=\"color:#999\">钱包支付(余额不足)</text></view></block></view><view catchtap=\"pay\" class=\"save\">确定</view><!--输入钱包密码--><view wx:if=\"{{wallets_password_flag}}\" class=\"wallets-password\"><view class=\"input-content-wrap\"><view class=\"top\"><view catchtap=\"close_wallets_password\" class=\"close\">×</view><view class=\"txt\">请输入支付密码</view><view catchtap=\"modify_password\" class=\"forget\">忘记密码</view></view><view class=\"actual_fee\"><span>￥</span><text>{{actual_fee/100}}</text></view><view catchtap=\"set_Focus\" class=\"input-password-wrap\"><view class=\"password_dot\"><i wx:if=\"{{wallets_password.length>=1}}\"></i></view><view class=\"password_dot\"><i wx:if=\"{{wallets_password.length>=2}}\"></i></view><view class=\"password_dot\"><i wx:if=\"{{wallets_password.length>=3}}\"></i></view><view class=\"password_dot\"><i wx:if=\"{{wallets_password.length>=4}}\"></i></view><view class=\"password_dot\"><i wx:if=\"{{wallets_password.length>=5}}\"></i></view><view class=\"password_dot\"><i wx:if=\"{{wallets_password.length>=6}}\"></i></view></view></view><input bindinput=\"set_wallets_password\" class=\"input-content\" password type=\"number\" focus=\"{{isFocus}}\" maxlength=\"6\" /></view>//index.jsPage({  data: {    payment_mode: 1,//默认支付方式 微信支付    isFocus: false,//控制input 聚焦    balance:100,//余额    actual_fee:20,//待支付    wallets_password_flag:false//密码输入遮罩  },  //事件处理函数  onLoad: function () {  },  wx_pay() {//转换为微信支付    this.setData({      payment_mode: 1    })  },  offline_pay() {//转换为转账支付    this.setData({      payment_mode: 0    })  },  wallet_pay() {    this.setData({//转换为钱包支付      payment_mode: 2    })  },  set_wallets_password(e) {//获取钱包密码    this.setData({      wallets_password: e.detail.value    });    if (this.data.wallets_password.length == 6) {//密码长度6位时，自动验证钱包支付结果      wallet_pay(this)    }  },  set_Focus() {//聚焦input    console.log('isFocus', this.data.isFocus)    this.setData({      isFocus: true    })  },  set_notFocus() {//失去焦点    this.setData({      isFocus: false    })  },  close_wallets_password () {//关闭钱包输入密码遮罩    this.setData({      isFocus: false,//失去焦点      wallets_password_flag: false,    })  },  pay() {//去支付    pay(this)  }})/*-----------------------------------------------*//*支付*/function pay(_this) {  let apikey = _this.data.apikey;  let id = _this.data.id;  let payment_mode = _this.data.payment_mode  if (payment_mode == 1) {  //  微信支付  // 微信自带密码输入框    console.log('微信支付')  } else if (payment_mode == 0) {  //  转账支付 后续跳转至传转账单照片    console.log('转账支付')  } else if (payment_mode == 2) {    // 钱包支付 输入密码    console.log('钱包支付')    _this.setData({      wallets_password_flag: true,      isFocus: true    })  }}// 钱包支付function wallet_pay(_this) {  console.log('钱包支付请求函数')  /*  1.支付成功  2.支付失败：提示；清空密码；自动聚焦isFocus:true，拉起键盘再次输入  */}index.wxsspage {  height: 100%;  width: 100%;  background: #e8e8e8;}page .pay {  display: flex;  flex-direction: column;  background: #fff;}page .pay .title {  height: 90rpx;  line-height: 90rpx;  font-size: 28rpx;  color: #353535;  padding: 0 23rpx;  border-bottom: 1rpx solid #ddd;  box-sizing: border-box;}page .pay .wx_pay, page .pay .offline_pay, page .pay .wallet_pay {  margin: 0 26rpx;  height: 90rpx;  line-height: 90rpx;  border-bottom: 2rpx solid #ddd;  box-sizing: border-box;  display: flex;  align-items: center;  justify-content: flex-start;}page .pay .wx_pay .icon, page .pay .offline_pay .icon,page .pay .wallet_pay .icon {  width: 34rpx;  height: 34rpx;  border: 2rpx solid #ddd;  box-sizing: border-box;  border-radius: 50%;}page .pay .wx_pay .icon.active, page .pay .offline_pay .icon.active,page .pay .wallet_pay .icon.active {  border: 10rpx solid #00a2ff;}page .pay .wx_pay text, page .pay .offline_pay text, page .pay .wallet_pay text {  margin-left: 20rpx;  color: #353535;  font-size: 26rpx;}page .pay .wallet_pay {  border: 0;  border-top: 2rpx solid #ddd;}page .pay .offline_pay {  border: 0 none;}page .save {  margin: 80rpx 23rpx;  color: #fff;  background: #00a2ff;  height: 88rpx;  line-height: 88rpx;  text-align: center;  font-size: 30rpx;  border-radius: 10rpx;}page .wallets-password {  position: absolute;  left: 0;  top: 0;  width: 100%;  height: 100%;  background: rgba(0, 0, 0, 0.6);}page .wallets-password .input-content-wrap {  position: absolute;  top: 200rpx;  left: 50%;  display: flex;  flex-direction: column;  width: 600rpx;  margin-left: -300rpx;  background: #fff;  border-radius: 20rpx;}page .wallets-password .input-content-wrap .top {  display: flex;  align-items: center;  height: 90rpx;  border-bottom: 2rpx solid #ddd;  justify-content: space-around;}page .wallets-password .input-content-wrap .top .close {  font-size: 44rpx;  color: #999;  font-weight: 100;}page .wallets-password .input-content-wrap .top .forget {  color: #00a2ff;  font-size: 22rpx;}page .wallets-password .input-content-wrap .actual_fee {  display: flex;  align-items: center;  justify-content: center;  color: #000;  height: 100rpx;  margin: 0 23rpx;  border-bottom: 2rpx solid #ddd;}page .wallets-password .input-content-wrap .actual_fee span {  font-size: 24rpx;}page .wallets-password .input-content-wrap .actual_fee text {  font-size: 36rpx;}page .wallets-password .input-content-wrap .input-password-wrap {  display: flex;  align-items: center;  justify-content: center;  height: 150rpx;}page .wallets-password .input-content-wrap .input-password-wrap .password_dot {  display: flex;  align-items: center;  justify-content: center;  text-align: center;  color: #000;  box-sizing: border-box;  width: 90rpx;  height: 90rpx;  border: 2rpx solid #ddd;  border-left: none 0;}page .wallets-password .input-content-wrap .input-password-wrap .password_dot:nth-child(1) {  border-left: 2rpx solid #ddd;}page .wallets-password .input-content-wrap .input-password-wrap .password_dot i {  background: #000;  border-radius: 50%;  width: 20rpx;  height: 20rpx;}page .wallets-password .input-content {  position: absolute;  opacity: 0;  left: -100%;  top: 600rpx;  background: #f56;  z-index: -999;}page .wallets-password .input-content.active {  z-index: -99;}github地址：-\">https://github.com/fiveTree/--"}
{"title": "微信小程序全屏模式（自定义导航栏） ", "author": "Rolan", "put_time": "2019-5-6 00:53", "content": "导航栏背景图要自定义导航栏，首先需要在app.json里设置：{\"window\": {        \"navigationStyle\": \"custom\"    }}设置之后进入小程序就只剩下右上角的胶囊了。 在设置导航栏样式时需要知道它的高度，在app.json的onLaunch里获取状态栏高度：App({    onLaunch: function(options) {        wx.getSystemInfo({            success: (res) => {                this.globalData.statusBarHeight = res.statusBarHeight                this.globalData.navBarHeight = 44 + res.statusBarHeight            }        })    },    globalData: {        statusBarHeight: 0,        screenHeight: 0    }})44是导航栏除去状态栏的高度，单位px。 因为导航栏每个页面都会用到，所以我们用组件会方便使用一些，这里创建一个叫nav的组件： 首先在组件js里设置statusBarHeight和一个可以通过外部设置状态栏颜色的backgroundColor的属性，默认透明。 nav.js:const app = getApp()Component({    options: {        multipleSlots: true    },    properties: {        backgroundColor:{            type: String,            value: 'rgba(0,0,0,0)'        }    },    data: {},    ready() {        let {            statusBarHeight,            navBarHeight        } = app.globalData;        this.setData({            statusBarHeight,            navBarHeight        })    },    methods: {        back() {            wx.navigateBack({                delta:1            })        }    }})content里放置内容，返回按钮固定在左边。 nav.wxml:<view class='nav-wrap' style=\"background-color:{{bgColor}};\">    <view style=\"height:{{statusBarHeight}}px;\"></view>    <view class='content'>        <slot name=\"content\"></slot>        <view class='back' bindtap='back'></view>    </view></view>nav.wxss:.nav-wrap {    position: fixed;    top: 0;    left: 0;    width: 750rpx;    z-index: 1;}.content {    position: relative;    width: 100%;    height: 44px;}.back {    position: absolute;    left: 0;    top: 0;    width: 88px;    height: 44px;    background: pink;}在页面中使用：<nav bgColor=\"black\">    <view slot=\"content\">        <view class='txt'>Nav title</view>    </view></nav><view>page content</view>效果图：效果图这里txt里的样式、内容都是可以自定义的，如果想要使用通用样式，可以写在组件里。 比如把导航栏title放在组件里，通过外部传值设置： nav.js:Component({    // ...    properties: {        title:{            type: String,            value: ''        }    },    // ...})nav.wxml:<view class='nav-wrap' style=\"background-color:{{bgColor}};\">    <view style=\"height:{{statusBarHeight}}px;\"></view>    <view class='content'>        <view class=\"title\">{{title}}</view>        <view class='back' bindtap='back'></view>    </view></view>nav.wxss:/* ... */.title {    color: white;    text-align: center;    line-height: 44px;    font-weight: 500;}/* ... */调用就可以了。 在第一次使用nav组件的页面代码中，page content是看不见的，因为是直接从状态栏开始显示的，被nav挡住了。 这里可以加一个高度为导航栏高度的view当做顶部padding： nav.wxml<view class='nav-wrap' style=\"background-color:{{bgColor}};\">    <view style=\"height:{{statusBarHeight}}px;\"></view>    <view class='content'>        <view class=\"title\">{{title}}</view>        <view class='back' bindtap='back'></view>    </view></view><view wx:if=\"{{hastop}}\" class='padding' style=\"width:100;height:{{navBarHeight}}px;\"></view>这里在properties里设置了一个hastop，用来控制是否有顶部padding。 页面中：<nav bgColor=\"black\" title=\"Nav title\" hastop></nav><view>page content</view>这样就可以显示出来了：导航栏背景图 还可以做导航栏背景图，添加一个image，绝对定位放置在nav-wrap底部： nav.wxml<view class='nav-wrap' style=\"background-color:{{bgColor}};\">    <image class='bgimg' wx:if=\"{{bgsrc}}\" src='{{bgsrc}}' mode='aspectFill'></image>    <view style=\"height:{{statusBarHeight}}px;\"></view>    <view class='content'>        <view class='title'>{{title}}</view>        <view class='back' bindtap='back'></view>    </view></view><view wx:if=\"{{hastop}}\" class='padding' style=\"width:100;height:{{navBarHeight}}px;\"></view>nav.wxss.bgimg {    position: absolute;    left: 0;    top: 0;    width: 100%;    height: 100%;}页面：<nav bgColor=\"black\" title=\"Nav title\" hastop bgsrc=\"/images/bg.jpeg\"></nav><view>page content</view>导航栏背景图全屏背景 将bgColor、hastop、bgsrc都去掉，在页面中放置一个position: fixed;，并且铺满全屏的图片。<nav title=\"Nav title\"></nav><image class='pagebg' src='/images/bg.jpeg' mode='aspectFill'></image>全屏背景back的内容自定义就行了，我这里只是简单放置了一个色框。注意事项 官方文档中的注意事项：注1：HexColor（十六进制颜色值），如\"#ff00ff\" 注2：关于navigationStyle客户端 7.0.0 以下版本，navigationStyle 只在 app.json 中生效。 客户端 6.7.2 版本开始，navigationStyle: custom 对 组件无效 开启 custom 后，低版本客户端需要做好兼容。开发者工具基础库版本切到 1.7.0（不代表最低版本，只供调试用）可方便切到旧视觉"}
{"title": "[UI组件] 来做一个可配置的滑块进度条吧 ", "author": "Rolan", "put_time": "2019-5-7 00:32", "content": "在一些需要用户填写资料的业务场景中，有时会让用户选择某个业务的范围，这时就需要用到滑块进度条。然后你们最爱的产品经理会说，给我整一个颜色可控，滑块按钮可大可小，滑块边框也要可大可小的滑动条来..emmm，一看这样的设计需求就意味着小程序原生的slider组件就不能用了。因为这玩意在样式上就不能自由的配置，只好来手动实现一个。结构设计行吧，那说干就干。首先滑动条可以从俯视图角度来看，分为三层。分别是底部滑轨区域，进度条区域以及供用户操作的滑块本身。在结构设计中，可以将底部滑轨区域，进度条区域分为一块，这样进度条区域可以根据随着滑动条的高度变化而变化, 宽度则由js控制。除此之外还需要暴露一些参数给外部，让它自己定义长粗宽。Component({\r\n    /**\r\n     * 组件的属性列表\r\n     */\r\n    properties: {\r\n        // 滑块大小\r\n        blockSize: {\r\n            type: Number,\r\n            value: 32,\r\n        },\r\n\r\n        // 滑块宽度\r\n        blockBorderWidth: {\r\n            type: Number,\r\n            value: 3\r\n        },\r\n\r\n        // 滑轨高度\r\n        height: {\r\n            type: Number,\r\n            value: 2\r\n        },\r\n\r\n        // 滑轨进度\r\n        step: {\r\n            type: Number,\r\n            value: 0,\r\n        },\r\n\r\n        // 进度值小数位\r\n        digits: {\r\n            type: Number,\r\n            value: 0,\r\n        },\r\n    },\r\n});<view id=\"slider-wrap\" class=\"slider-wrap\">\r\n    <view class=\"silder-bg\" style=\"height: {{height}}rpx;\">\r\n        <view  class=\"silder-bg-inner\"></view>\r\n    </view>\r\n    <view\r\n        class=\"silder-block\"\r\n        style=\"height: {{blockSize}}rpx; border-width: {{blockBorderWidth}}rpx;\"\r\n    ></view>\r\n</view>.slider-wrap {\r\n    position: relative;\r\n    display: flex;\r\n    align-items: center;\r\n    width: 100%;\r\n}\r\n\r\n.silder-bg,\r\n.silder-bg-inner,\r\n.silder-block {\r\n    position: absolute;\r\n    left: 0;\r\n}\r\n\r\n.silder-bg,\r\n.silder-bg-inner {\r\n    width: 100%;\r\n    height: 2rpx;\r\n    flex: 1;\r\n}\r\n\r\n.silder-bg {\r\n    overflow: hidden;\r\n    background-color: #eeeeee;\r\n    border-radius: 8rpx;\r\n    z-index: 0;\r\n}\r\n\r\n.silder-bg-inner {\r\n    height: 100%;\r\n    background-color: #66a6ff;\r\n    /* border-radius: 8rpx; */\r\n    z-index: 1;\r\n    border-bottom-left-radius: 8rpx;\r\n    border-top-left-radius: 8rpx;\r\n}\r\n\r\n.silder-block {\r\n    width: 32rpx;\r\n    height: 32rpx;\r\n    background-color: #ffffff;\r\n    border: solid 3rpx #66a6ff;\r\n    z-index: 2;\r\n    border-radius: 50%;\r\n    box-sizing: border-box;\r\n}\r\n点击行为事件滑块进度条的滑块是一个听话的小朋友，就是说我们叫它去哪它就听话的过去。所以就不要抓它去煲汤了~在组件外部容器中绑定一个点击事件，我们必须得要知道用户点击位置，在bind:tap事件中取到clientX属性。除此之外还需要取到进度条的位置信息。得到两个关键数据后，将用户点击的位置ClintX与进度条组件的偏移量offset相减，得出相对于组件内的进度progress.再用组件的宽度width减去progress乘于100得到目前进度的百分比percentage。同时为了防止进度条超出进度条如下图所示：((191 - 36) / 301) * 100 ≈ 52<view class=\"slider-wrap\" bindtap=\"tappingSlider\">\r\n    <!-- ...other -->\r\n</view>Component({\r\n    // ...\r\n\r\n    /**\r\n     * 组件的初始数据\r\n     */\r\n    data: {\r\n        containerInfo: null,\r\n        percentage: 0,\r\n    },\r\n\r\n    ready() {\r\n        // 取到滑块进度条的位置信息\r\n        wx.createSelectorQuery().in(this)\r\n            .select('.slider-wrap')\r\n            .boundingClientRect((rect) => {\r\n                if (!rect) return;\r\n\r\n                this.data.container = rect;\r\n                this._initBloackPos();\r\n            }).exec()\r\n    },\r\n\r\n    // 点击进度条\r\n    tappingSlider(evt) {\r\n        const { containerInfo } = this.data;\r\n        if (!containerInfo) return;\r\n\r\n        const { clientX } = evt.changedTouches[0];\r\n        const { digits, _maxDistance } = this.data;\r\n\r\n        // 需要做边界处理\r\n        const perc = this._computeOffset(clientX, containerInfo.left, 100);\r\n        const percentage = this._boundaryHandler(perc);\r\n\r\n        this.setData({ percentage });\r\n        this.triggerEvent('change', {\r\n              value: percentage.toFixed(digits) * 1\r\n          });\r\n    },\r\n\r\n    /**\r\n     * 计算相对容器的偏移距离\r\n     *\r\n     * @param { Number } x - X 坐标\r\n     * @param { Number } offset - 偏移量\r\n     * @param { Number } maxVal - 在 maxVal 范围内求百分比\r\n     */\r\n    _computeOffset(x, offset, maxVal) {\r\n        const { width } = this.data.containerInfo;\r\n\r\n        // 底层保证一定精度\r\n        return (((x - offset) / width) * maxVal).toFixed(4) * 1;\r\n    },\r\n\r\n    /**\r\n     * 边界处理\r\n     * @param { Number } num - 待处理的最值\r\n     * @param { Number } maxNum - num 最大值\r\n     * @param { Number } minNum - num 最小值\r\n     */\r\n    _boundaryHandler(num, maxNum = 100, minNum = 0) {\r\n        return num > maxNum ? maxNum : (num < minNum ? minNum : num);\r\n    },\r\n});<view class=\"slider-wrap\" bindtap=\"tappingSlider\" bindtouchmove=\"onTouchMove\">\r\n    <view class=\"silder-bg\" style=\"height: {{height}}rpx;\">\r\n        <view\r\n            class=\"silder-bg-inner\"\r\n            style=\"width: {{percentage}}%; height: {{height}}rpx;\"\r\n        ></view>\r\n    </view>\r\n    <view\r\n        class=\"silder-block\"\r\n        style=\"left: {{percentage}}%;width: {{blockSize}}rpx;height: {{blockSize}}rpx; border-width: {{blockBorderWidth}}rpx;\"\r\n    ></view>\r\n</view>虽然实现了点击滑动到指定位置的功能，但仔细一看还是有一些瑕疵的~ 当我们点击到百分百时，滑块超出原先设定的容器宽度。超出的原因是因为在布局上，我们使用绝对定位absolute，通过设置滑块left属性来控制滑块位置的。偏移量中还包含了滑块自身的宽度，因此还需要对滑块的偏移量做一定的处理，去掉自身宽度再获取百分比。在文章开头我们已经暴露了一个blockSize的属性，利用该属性可以计算滑块的最大偏移量：Component({\r\n    // ...\r\n    data: {\r\n        // other data...\r\n\r\n        _blockOffset: 0,\r\n        _maxDistance: 100,\r\n    },\r\n\r\n    methods: {\r\n        // 点击进度条\r\n        tappingSlider(evt) {\r\n            const { containerInfo } = this.data;\r\n            if (!containerInfo) return;\r\n\r\n            const { clientX } = evt.changedTouches[0];\r\n            const { digits, _maxDistance } = this.data;\r\n            const computeOffset = (maxVal) => {\r\n                return this._computeOffset(clientX, containerInfo.left, maxVal);\r\n            }\r\n\r\n            // 滑块偏移度\r\n            const _blockOffset = this._boundaryHandler(\r\n                computeOffset(_maxDistance), _maxDistance\r\n            );\r\n\r\n            // 实际百分比\r\n            const percentage = this._boundaryHandler(computeOffset(100));\r\n\r\n            this.setData({ _blockOffset, percentage });\r\n            this.triggerEvent('change', { value: percentage.toFixed(digits) * 1 });\r\n        },\r\n    }\r\n\r\n})<!-- other code -->\r\n<view\r\n    class=\"silder-block\"\r\n    style=\"left: {{_blockOffset}}%;width: {{blockSize}}rpx;height: {{blockSize}}rpx; border-width: {{blockBorderWidth}}rpx;\"\r\n></view>如此，该事件就完成啦~滑动事件完成点击事件后，我们还得让它能进行自由的滑动。进度条组件的拖动的流程大致是：点击滑块 -> 拖动滑块 -> 释放滑块这三个步骤。因此跟H5的思路一样，我们只需监听touchmove、touchstatr、touchend三个事件。首先先监听touchmove，用户点击滑块后，记录当前的clientX属性, 随后还需要记录当前进度和滑块的偏移量；touchmove事件则由外层容器相关联，并更新滑动的距离。由于touchmove里针对拖动事件逻辑不能被随便触发，因此需要加一个标识的锁；在touchend事件触发后释放锁即可：Component({\r\n    methods: {\r\n        onTouchStart(evt) {\r\n            this.data.moving = true;\r\n\r\n            // 记录原始坐标\r\n            this.data.originPos = this.data._blockOffset;\r\n            this.data.originPercentage = this.data.percentage;\r\n\r\n            this.data._startTouchX = evt.changedTouches[0].clientX;\r\n        },\r\n\r\n        // 滑块移动\r\n        onTouchMove(evt) {\r\n            const { moving, containerInfo } = this.data;\r\n            if (!moving || !containerInfo) return;\r\n\r\n            const { clientX } = evt.changedTouches[0];\r\n            const {\r\n                digits,\r\n                originPos,\r\n                originPercentage,\r\n                _startTouchX,\r\n                _maxDistance\r\n            } = this.data;\r\n\r\n            // 计算偏移量\r\n            const computeOffset = (maxVal) => {\r\n                return this._computeOffset(clientX, _startTouchX, maxVal);\r\n            }\r\n\r\n            // 实际百分比\r\n            const perc = originPercentage + computeOffset(100);\r\n            const percentage = this._boundaryHandler(perc);\r\n\r\n            // 滑块偏移度\r\n            const offset = originPos + computeOffset(_maxDistance);\r\n            const _blockOffset = this._boundaryHandler(offset, _maxDistance);\r\n\r\n            this.setData({ percentage, _blockOffset });\r\n            this.triggerEvent('change', {\r\n                value: percentage.toFixed(digits) * 1\r\n            });\r\n        },\r\n\r\n        onTouchEnd(evt) {\r\n            this.data.moving = false;\r\n        },\r\n    }\r\n})<view class=\"slider-wrap\" bindtap=\"tappingSlider\" bindtouchmove=\"onTouchMove\">\r\n    <view class=\"silder-bg\" style=\"height: {{height}}rpx;\">\r\n        <view\r\n            class=\"silder-bg-inner\"\r\n            style=\"width: {{percentage}}%; height: {{height}}rpx;\"\r\n        ></view>\r\n    </view>\r\n    <view\r\n        class=\"silder-block\"\r\n        style=\"left: {{_blockOffset}}%;width: {{blockSize}}rpx;height: {{blockSize}}rpx; border-width: {{blockBorderWidth}}rpx;\"\r\n        bindtouchstart=\"onTouchStart\"\r\n        bindtouchend=\"onTouchEnd\"\r\n    ></view>\r\n</view>总结以上就是滑块进度条组件的实现~ 实际上该组件还有更多可供配置的地方，如颜色值，背景控制等这些比较基础的东西就不继续展开讲啦~本文是以小程序进行示例。但思路是共通的，也可以使用同样思路在H5实现，只不过是 API 的差异罢了~微信代码片段, 可以直接拿来就用。2019/05/04 更新：后面又重新看了一遍，发现该组件还是有可优化的空间：操作不必局限于滑块上，可以将bindtap事件废弃，其余的所有事件都代理到最外部的节点中。touchstar的同时就渲染位置信息，还允许它自由的滑动:<view class=\"slider-wrap\"\r\n    bindtouchstart=\"onTouchStart\"\r\n    bindtouchmove=\"onTouchMove\"\r\n    bindtouchend=\"onTouchEnd\"\r\n>\r\n    <view class=\"silder-bg\" style=\"height: {{height}}rpx;\">\r\n        <view\r\n            class=\"silder-bg-inner\"\r\n            style=\"width: {{percentage}}%; height: {{height}}rpx;\"\r\n        ></view>\r\n    </view>\r\n    <view\r\n        class=\"silder-block\"\r\n        style=\"left: {{_blockOffset}}%;width: {{blockSize}}rpx;height: {{blockSize}}rpx; border-width: {{blockBorderWidth}}rpx;\"\r\n    ></view>\r\n</view>Component({\r\n    // other options ...\r\n\r\n    methods: {\r\n        // other method ...\r\n        onTouchStart(evt) {\r\n            this.data.moving = true;\r\n\r\n            const { containerInfo } = this.data;\r\n            if (!containerInfo) return;\r\n\r\n            const { clientX } = evt.changedTouches[0];\r\n            const { digits, _maxDistance } = this.data;\r\n            const computeOffset = (maxVal) => {\r\n                return this._computeOffset(clientX, containerInfo.left, maxVal);\r\n            }\r\n\r\n            // 滑块偏移度\r\n            const _blockOffset = this._boundaryHandler(\r\n                computeOffset(_maxDistance), _maxDistance\r\n            );\r\n\r\n            // 实际百分比\r\n            const percentage = this._boundaryHandler(computeOffset(100));\r\n\r\n            // 记录原始坐标\r\n            this.data.originPos = _blockOffset;\r\n            this.data.originPercentage = percentage;\r\n\r\n            this.data._startTouchX = clientX;\r\n\r\n            this.setData({ _blockOffset, percentage });\r\n            this.triggerEvent('change', { value: percentage.toFixed(digits) * 1 });\r\n        },\r\n    }\r\n});微信代码片段 v0.0.2"}
